---
slug: /rust-types
sidebar_label: 型
---

# 【Rust】型

Rust プログラムのすべての変数、アイテム、および値には型があります。値の型は、値を保持するメモリの解釈と、値に対して実行される可能性のある操作を定義します。

組み込み型は、ユーザー定義型ではエミュレートできない重要な方法で、言語に緊密に統合されています。ユーザー定義型の機能は制限されています。

型の分類：

- _プリミティブ型_
  - [論理型](#ブール型)
  - [数値型](#数値型)
  - [テキスト型](#テキスト型)
  - [Never 型](#never-型)
- _シーケンス型_
  - [タプル型](#タプル型)
  - [配列型](#配列型)
  - [スライス型](#スライス型)
- _ユーザー定義型_
  - [構造体型](#構造体型)
  - [列挙型](#列挙型)
  - [共用体型](#共用体型)
- _関数型_
  - [関数アイテム型](#関数アイテム型)
  - [クロージャ型](#クロージャ型)
- _ポインタ型_
  - [参照型](#参照型)
  - [Raw ポインタ型](#raw-ポインタ)
  - [関数ポインタ型](#関数ポインタ)
- _トレイト型_
  - [トレイトオブジェクト型](#トレイトオブジェクト)
  - [Impl トレイト型](#impl-トレイト)

## ブール型

論理型 `bool` は、真偽値を表す型で、その値は `true`（真）または `false`（偽）のいずれかです。

```rust title="例：ブール表現"
let a: bool = true;
let b: bool = false;
```

## 数値型

数値型は、整数型と浮動小数点型に分けられます。

### 整数型

- 符号なし

  | 型       | 最小値 | 最大値 |
  ---------|----| --- | --- |
  | `u8`    | 0  | 2^8-1 |
  | `u16`   | 0  | 2^16-1 |
  | `u32`   | 0  | 2^32-1 |
  | `u64`   | 0  | 2^64-1 |
  | `u128`  | 0  | 2^128-1 |
  | `usize` | 0  | _マシン依存_ |

- 符号あり

  | 型       | 最小値 | 最大値 |
  ---------| --- | --- | --- |
  | `i8`    | -(2^7) | 2^7-1 |
  | `i16`   | -(2^15) | 2^15-1 |
  | `i32`   | -(2^31) | 2^31-1 |
  | `i64`   | -(2^63) | 2^63-1 |
  | `i128`  | -(2^127) | 2^127-1 |
  | `isize` | _マシン依存_ | _マシン依存_ |

`usize` 型は、プラットフォームのポインタ型と同じビット数の符号なし整数型です。プロセス内のすべてのメモリアドレスを表すことができます。

`isize` 型は、プラットフォームのポインタ型と同じビット数の符号付き整数型です。オブジェクトと配列サイズの理論上の上限は、最大 `isize` 値です。これにより、`isize` を使用して、オブジェクトまたは配列へのポインター間の差を計算し、オブジェクト内のすべてのバイトを、終了後の1バイトとともにアドレス指定できるようになります。

###  浮動小数点型

IEEE 754-2008 の「binary32」および「binary64」浮動小数点型は、それぞれ `f32` および `f64` です。

## テキスト型

テキスト型は、`char` または `str` で、テキストデータを保持します。

- `char`

  `char` 型の値は、Unicode スカラー値（つまり、サロゲートではないコードポイント）であり、0x0000〜0xD7FF または 0xE000〜0x10FFFF の範囲の32ビット符号なしワードとして表されます。この範囲外の文字を作成することは、即時の未定義動作です。`[char]` は、事実上、長さ1の UCS-4/UTF-32 文字列です。

- `str`
  
  型 `str` の値は、`[u8]` と同じ方法で表され、8ビットの符号なしバイトのスライスです。ただし、Rust 標準ライブラリは `str` について追加の仮定を行います。`str` で動作するメソッドは、そこにあるデータが有効な UTF-8 であることを仮定して保証します。非 UTF-8 バッファを使用して `str` メソッドを呼び出すと、現在または将来、未定義動作が発生する可能性があります。また、`str` は動的なサイズの型であるため、`&str` などのポインタ型を介してのみインスタンス化できます。

## Never 型

Never 型 `!` は、値の無い型であり、決して完了しない計算の結果を表します。

## タプル型

タプル型は、0個以上の任意の型の組み合わせで成る固定サイズのシーケンスです。

タプル型の例：

- `()` — ユニット型
- `(f64, f64)`
- `(String, i32)`
- `(i32, String)` — 前の例とは異なるタイプ
- `(i32, f64, Vec<String>, Option<bool>)`

## 配列型

配列型は、型 `T` の `N` 個の固定サイズのシーケンスで、`[T; N]` と表現されます。

## スライス型

スライスは、型 `T` の要素のシーケンスへの「ビュー」を表す動的にサイズ設定された型です。スライス型は `[T]` と記述されます。

スライス型は通常、ポインタ型を介して使用されます。例えば：

- `&[T]`：「共有スライス」。「スライス」と呼ばれることもあります。指し示すデータを所有していません。それを _借用_ します。
- `&mut [T]`：「可変スライス」。指すデータを可変的に借用します。
- `Box<[T]>`：「ボックス化されたスライス」

## 構造体型

構造体型は、0個以上の任意の型のフィールドを持たせることができます。それぞれのフィールドは、モジュールの外部に対する可視性を指定することができます。

### タプル構造体型

_タプル構造体_型は、フィールドが匿名であることを除いて、構造体型と同じです。

### ユニットライク構造体型

フィールドを持たない構造体型も定義することができます。

## 列挙型

列挙型は、いくつかの値を列挙する方法です。列挙された値を **ヴァリアント** と呼び、それら全てののヴァリアントが列挙型のとりうる値と言えます。各ヴァリアントには、データを付与することができ、それはヴァリアントごと異なる構造にすることもできます。

## 共用体型

共用体型は、構造体型に似ていますが、各フィールドが同じ領域をとります。即ち、値はいずれかのフィールドの型となります。領域サイズは、フィールドの中で最大のサイズを確保されます。

## 関数アイテム型

## クロージャ型

## 参照型

## Raw ポインタ型

## 関数ポインタ型

## トレイトオブジェクト型

## Impl トレイト型

`impl Trait` は、特定のトレイトを実装する名前のない具体的なタイプを指定する方法を提供します。引数の位置（関数の匿名型パラメーターとして機能できる場所）と返り値の位置（抽象の返り型として機能できる場所）の2種類の場所に表示されます。

```rust title="例：Impl-Trait"
trait Trait {}

// 引数の位置：匿名型パラメーター
fn foo(arg: impl Trait) {
}

// 返り値の位置：抽象戻りタイプ
fn bar() -> impl Trait {
}
```
