---
slug: /design-mistakes-in-node
sidebar_label: Node.js に関する10の反省点
---

# Node.js に関する10の反省点

:::note このドキュメントについて

このドキュメントは、2018年6月にベルリンで開催された JSConf EU で発表された資料 [『Design Mistakes in Node』（Ryan Dahl 著）](https://tinyclouds.org/jsconf2018.pdf) を翻訳したものです。

<iframe width="560" height="315" src="https://www.youtube.com/embed/M3BM9TB-8yA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

:::

## 背景

- 私は Node を開発し、初期の開発管理を行っていました。
- 私の目標は、**イベント駆動型 HTTP サーバー** のプログラミングに重点を置いていました。
- その焦点は、当時のサーバーサイド JavaScript を軌道に乗せるためにとても重要であることが判明しました。そのときは明らかではありませんでしたが、サーバー側の JS が成功するためにイベントループを必要としました。

2012年を過ぎた頃、Node は（多かれ少なかれ）ユーザーフレンドリーなノンブロッキングフレームワークの目標を達成したと感じました：

- コアは多くのプロトコルをサポートしました：HTTP、SSL、…
- Windows（[IOCP](http://tinyclouds.org/iocp-links.html) を使用）、Linux（epoll）、Mac（kqueue）で動作
- やや安定した API を備えた比較的小さなコア。
- NPM を介した外部モジュールの成長するエコシステム。

しかし、それは大きな間違いでした — やるべきことがたくさん残っていました...

## 以来、重要な作業によりノードは成長を続けています。

- npm（別名「Isaac」）はコアノードライブラリを分離し、エコシステムを分散できるようにしました。
- N-API は美しくデザインされたバインディング API です。
- Ben Noordhuis と Bert Belder が libuv を作成しました。
- Mikeal Rogers は、ガバナンスとコミュニティ　　を組織しました。
- Fedor Indutny は、コードベース全体、特に暗号通貨に多大な影響を与えてきました。
- その他多数：TJ Fontaine、Rod Vagg、Myles Borins、Nathan Rajlich、Dave Pacheco、Robert Mustacchi、Bryan Cantrill、Igor Zinkovsky、Aria Stewart、Paul Querna、FelixGeisendörfer、Tim Caswell、Guillermo Rauch、Charlie Robbins、Matt Ranney、Rich Trott、Michael Dawson、James Snell

Node を再び盛んに使い始めたのはここ6か月のことです。<br />
最近、私の目標は異なります。<br />
動的言語は、科学計算に適したツールであり、多くの場合、迅速な1回限りの計算を行います。<br />
そして JavaScript は最高の動的言語です。

むしろ、Nodeのすべての疣贅について文句を言います。<br />
バグは、あなたがバグの責任者である場合ほど明白ではありません。<br />
時々、Node は私にとって黒板の釘のようなものです。<br />
それはとても良かったかもしれません。

## 後悔

### Promise を使い続けなかった

- 私は [2009年6月](https://github.com/nodejs/node/commit/7cd09874c666f0ce64b1d7776de74f55ff3e53ab) に Node に Promise を追加しましたが、[2010年2月](https://github.com/nodejs/node/commit/0485cc41d5c260458f590d249c073794047434fb) に愚かにもそれらを削除しました。
- Promise は、async/await に必要な抽象化です。
- Node で Promise を統一的に使用すると、最終的な標準化と async/await の配信が高速化される可能性があります。
- 今日、Node の多くの非同期 API は、これが原因でひどく古くなっています。

### セキュリティ

- V8 自体は、非常に優れたセキュリティサンドボックスです。
- 特定のアプリケーションでそれをどのように維持できるかをもっと考えていたら、Node には他の言語では利用できない優れたセキュリティ保証があったはずです。
- 例：リンターがコンピューターとネットワークに完全にアクセスできないようにする必要があります。

### ビルドシステム（GYP）

- ビルドシステムは非常に難しく、非常に重要です。
- V8（Chrome 経由）が GYP の使用を開始し、Node を2つに切り替えました。
- その後、Chrome は GN 用の GYP を削除しました。Node を唯一の GYP ユーザーのままにします。
- GYP も醜い内部インターフェースではありません — V8にバインドしようとしている人に公開されています。
- それはユーザーにとってひどい経験です。これは、JSON ではなく、Python による JSON の適応です。
- GYP の継続的な使用は、Node コアのおそらく最大の障害です。
- ユーザーに V8 への C++ バインディングを作成するように案内する代わりに、コアの外部関数インターフェイス（FFI）を提供する必要がありました。
- 多くの人が早い段階で FFI（つまり Cantrill）に移行することを提案しましたが、残念ながら私はそれらを無視しました。
- （そして、libuv が autotools を採用したことに非常に不満を持っています。）

### package.json

- Isaac は、NPM で package.json を発明しました（ほとんどの部分）。
- しかし、ノードの `require()` が package.json ファイルの `"main"` を検査できるようにすることでそれを認可しました。
- 最終的に、Node ディストリビューションに NPM を含めたため、デファクトスタンダードになりました。
- モジュール用に一元化された（プライベートに制御された）リポジトリがあるのは残念です。

`require("somemodule")` は特定されていません。<br />
それが定義されている場所が多すぎます。

```js title="あなたの javascript プログラム"
require("somemodule")

// Code that uses
// somemodule
```

```json title="package.json"
{
  ...
  "dependencies": {
    "somemodule": "^0.0.1"
  }
  ...
}
```

```
NPM のデータベース   ローカルの node_modules フォルダ
 + ---------- +         + ---------- +
 + ---------- +         + ---------- +
 |            |         |            |
 | somemodule |         | somemodule |
 |            |         |            |
 + ---------- +         + ---------- |
```

package.json を許可すると、ファイルのディレクトリとしての「モジュール」の概念が生まれました。

これは厳密に必要な抽象化ではなく、Web 上には存在しません。

package.json には、あらゆる種類の不要な情報が含まれるようになりました。<br />
ライセンス？リポジトリ？説明？<br />
**ボイラープレートノイズ**です。

インポート時に相対ファイルと URL のみが使用された場合、パスはバージョンを定義します。依存関係をリストする必要はありません。

```text title="宇宙で最も重い物体"
太陽 < 中性子星 < ブラックホール << node_modules
```

### node_modules

これは、モジュール解決アルゴリズムを非常に複雑にします。

デフォルトでベンダー化されたものには善意がありますが、実際には
`$NODE_PATH` はそれを排除しなかったでしょう。

ブラウザのセマンティクスから大きく逸脱しています。

それは私のせいです、ごめんなさい。<br />
残念ながら、今は元に戻すことはできません。

### 拡張子「.js」無しの `require("module")`

- 不必要に明確ではありません。
- ブラウザの JavaScript がどのように機能するかではありません。スクリプトタグの src 属性の「.js」は省略できません。
- モジュールローダーは、ユーザーが何を意図していたかを推測するために、複数の場所でファイルシステムにクエリを実行する必要があります。

### index.js

index.html があったのでかわいいと思いました...

それは不必要にモジュールローディングシステムを複雑にしました。

サポートされている package.json が必要になった後は、特に不要になりました。

---

Node に関する私の問題は、ほぼ完全に、Node がユーザーコードを管理する方法にあります。

初期のイベント I/O に焦点を当てていたのとは対照的に、モジュールシステムは本質的に後付けでした。

これを念頭に置いて、私はそれをより良くする方法について長い間考えてきました。

**免責事項**：私は**非常に初期の**プロトタイプを提示しています。

袖をまくり上げて lldb に飛び込むことに熱心でない限り、**わざわざビルドしようとしないでください**。

そうは言っても...

## Deno

Deno https://github.com/ry/deno

V8 での安全な TypeScript ランタイム

## Deno のゴール

### セキュリティ

- JavaScript が安全なサンドボックスであるという事実を利用してください。
  - デフォルトでは、スクリプトはネットワークまたはファイルシステムの書き込みアクセスなしで実行する必要があります。
  - ユーザーはフラグを介してアクセスすることを選択できます：--allow-net --allow-write
  - これにより、ユーザーは信頼できないユーティリティ（リンターなど）を実行できます。
- 任意のネイティブ関数を V8 にバインドしないでください
  - すべてのシステムコールはメッセージパッシング（protobuf シリアル化）によって行われます
  - `send` と `recv` の2つのネイティブ関数があります。
  - これにより、設計が簡素化され、システムの監査が容易になります。

```text title="Deno Procces (Privileged)"
                                         + --------------------------------------- +
                                         | V8 VM (Unprivileged)                    |
                     + ---------- +      |     + ---------- +                      |
[    Timers   ] <--> |            |      |     |            | <--> [   Timers    ] |
                     |            |      |     |            |                      |
[ File System ] <--> | Dispatcher | <--------> | Dispatcher | <--> [ File System ] |
                     |            |  Protobuf  |            |                      |
[   Network   ] <--> |            |      |     |            | <--> [   Network   ] |
                     + ---------- +      |     + ---------- +                      |
                                         |           ^                             |
                                         |           |                             |
                                         |           v                             |
                                         |     + ------------------------------- + |
                                         |     |           TypeScript            | |
                                         |     |            Compiler             | |
                                         |     + ------------------------------- + |
                                         + --------------------------------------- +
```

### モジュールシステムを簡素化する

- 既存のノードモジュールとの互換性の試みはありません。
- インポートは相対URLまたは絶対URLのみです。（[セマンティックバージョニング](https://research.swtch.com/vgo-import) を参照）

```ts
import { test } from "https://unpkg.com/deno_testing@0.0.5/testing.ts"
import { log } from "./util.ts"
```

- インポートは拡張子を提供する必要があります。
- リモート URL は、最初のロード時に無期限にフェッチおよびキャッシュされます。<br />
  `--reload` フラグが指定されている場合にのみ、リソースが再度フェッチされます。
- デフォルト以外のキャッシュディレクトリを指定することで、ベンドリングを実行できます。

### 実行可能ファイルに組み込まれた TypeScript コンパイラ。

- TS は絶対に美しいです。
  - それはついに実用的なオプションでタイプされた言語を提供しました。
  - 迅速なハッキングから大規模で適切に構造化された機械まで、コードをシームレスに拡張できます。
- Deno は TS コンパイラにフックして、モジュールの解決とビルドアーティファクトのインクリメンタルキャッシュを実行します。
- 変更されていない TS ファイルは再コンパイルしない。
- 通常の JS も機能するはずです（ただし、TS は JS のスーパーセットであるため、これは簡単です）
- 高速起動のために V8 スナップショットを使用する必要があります（まだプロトタイプにはありません）

### 最小限のリンクで実行可能ファイルを1つだけ出荷します

```bash
$ ls -lh deno
-rwxrwxr-x 1 ryan ryan 55M May 28 23:46 deno
$ ldd deno
linux-vdso.so.1 => (0x00007ffc6797a000)
libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f104fa47000)
libstdc++.so.6 => /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f104f6c5000)
libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f104f3bc000)
libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f104f1a6000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f104eddc000)
/lib64/ld-linux-x86-64.so.2 (0x00007f104fc64000)
```

### 2018年を活用する

- Parcel を使用して Node モジュールをバンドルにコンパイルすることにより、ランタイムをブートストラップします。<br />
  （これは、Node が実行しなければならなかったことを大幅に単純化したものです。）
- 優れたインフラストラクチャがネイティブコードに存在するようになりました：
  - EG は HTTPについて心配する必要はありません。他の誰かがすでにそれを機能させています。<br />
    （Node ではそうではありませんでした。Web サーバーは100％手作業で作成されました）
  - 現在、Deno の非 JS 部分は **Go** を使用していますが、プロトタイプが完成したので、私は完全に販売されておらず、代替案を研究しています。
    - Rust は良い選択かもしれません。
    - C++ は、他の人が Go または Rust をターゲットにした独自の Denos を構築できるのであれば、それでも良い選択かもしれません。

### その他

- 未処理の Promise では常にすぐに死にます。<br />
  （めちゃくちゃこれは Node には当てはまりません。）
- トップレベルの `await` をサポートします（まだプロトタイプではありません）
- 機能が重複するブラウザ互換。

Deno https://github.com/ry/deno<br />
生後わずか1ヶ月です。あまり使えません。<br />
でも今のところデザインには満足しています。

---

コメント？ 質問？ 懸念？<br />
ry@tinyclouds.org

<small>これらのスライド：http://tinyclouds.org/jsconf2018.pdf</small>