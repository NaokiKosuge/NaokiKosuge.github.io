---
slug: /git-commands
sidebar_label: 一般的なコマンド
---

# 【git】一般的なコマンド

- [`git`](#git)
  - _作業領域を開始する_
    - [`clone`](#clone)
    - [`init`](#init)
  - _現在の変更に取り組む_
    - [`add`](#add)
    - [`mv`](#mv)
    - [`restore`](#restore)
    - [`rm`](#rm)
  - _歴史と状態を調べる_
    - [`bisect`](#bisect)
    - [`diff`](#diff)
    - [`grep`](#grep)
    - [`log`](#log)
    - [`show`](#show)
    - [`status`](#status)
  - _共通の歴史を成長させ、マークし、微調整する_
    - [`branch`](#branch)
    - [`commit`](#commit)
    - [`merge`](#merge)
    - [`rebase`](#rebase)
    - [`reset`](#reset)
    - [`switch`](#switch)
    - [`tag`](#tag)
  - _コラボレーション_
    - [`fetch`](#fetch)
    - [`pull`](#pull)
    - [`push`](#push)


## `git`

### NAME

git — 愚かなコンテンツトラッカー

### SYNOPSIS

```
git [--version] [--help] [-C <path>] [-c <name>=<value>]
    [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
    [-p|--paginate|-P|--no-pager] [--no-replace-objects] [--bare]
    [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
    [--super-prefix=<path>] [--config-env <name>=<envvar>]
    <command> [<args>]
```

### DESCRIPTION

Git は、高速でスケーラブルな分散型リビジョン管理システムであり、高レベルの操作と内部へのフルアクセスの両方を提供する非常に豊富なコマンドセットを備えています。

開始するには [gittutorial[7]](https://git-scm.com/docs/gittutorial) を参照してください。次に、便利な最小限のコマンドセットについては [giteveryday[7]](https://git-scm.com/docs/giteveryday) を参照してください。 Git [ユーザーズマニュアル](https://git-scm.com/docs/user-manual) には、より詳細な紹介があります。

基本的な概念をマスターしたら、このページに戻って Git が提供するコマンドを学ぶことができます。「githelpcommand」を使用して、個々の Git コマンドについて詳しく知ることができます。[gitcli[7]](https://git-scm.com/docs/gitcli) のマニュアルページには、コマンドラインコマンド構文の概要が記載されています。

最新の Git ドキュメントのフォーマットされ、ハイパーリンクされたコピーは、https://git.github.io/htmldocs/git.html または https://git-scm.com/docs で表示できます。

### OPTIONS

- `--version`

  _git_ プログラムの元となった Git スイートのバージョンを出力します。

- `--help`

  概要と最も一般的に使用されるコマンドのリストを出力します。オプション `--all` または `-a` を指定すると、使用可能なすべてのコマンドが出力されます。Git コマンドに名前が付けられている場合、このオプションはそのコマンドのマニュアルページを表示します。

  マニュアルページの表示方法を制御するために、他のオプションを使用できます。`git --help ...` は内部で `git help ...` に変換されるため、詳細については [git-help[1]](https://git-scm.com/docs/git-help) を参照してください。

- `-C <path>`

  現在の作業ディレクトリではなく、`<path>` で git が開始されたかのように実行します。複数の `-C` オプションが指定されている場合、後続の非絶対 `-C <path>` は、先行する `-C <path>` に関連して解釈されます。`<path>` は存在するが空の場合、例：`-C ""` の場合、現在の作業ディレクトリは変更されません。

  ```bash
  git --git-dir=a.git --work-tree=b -C c status
  git --git-dir=c/a.git --work-tree=c/b status
  ```

- `-c <name>=<value>`

  構成パラメーターをコマンドに渡します。指定された値は、構成ファイルの値を上書きします。`<name>` は、`git config`（ドットで区切られたサブキー）でリストされているものと同じ形式である必要があります。

  `git -c foo.bar ...`で `=` を省略することは許可されており、`foo.bar` をブールの true 値に設定することに注意してください（`[foo] bar` が構成ファイルで行うのと同じように）。等しいが空の値（`git -c foo.bar= ...` など）を含む場合、`foo.bar` は空の文字列に設定され、`git config --type=bool` は `false` に変換します。

- `--config-env=<name>=<envvar>`

  `-c <name>=<value>` と同様に、構成変数 `<name>` に値を指定します。ここで、`<envvar>` は、値を取得する環境変数の名前です。`-c` とは異なり、値を空の文字列に直接設定するためのショートカットはありません。代わりに、環境変数自体を空の文字列に設定する必要があります。`<envvar>` が環境に存在しない場合はエラーです。`<envvar>` には等号を含めないでください。これは、`<name>` に等号が含まれている場合のあいまいさを避けるためです。

  これは、一時的な構成オプションを git に渡したいが、他のプロセスがコマンドライン（`/proc/self/cmdline` など）を読み取れるが環境（`/proc` など）は読み取れない可能性がある OS でそうしている場合に役立ちます。`/self/environment`）。この動作は Linux のデフォルトですが、システムにない場合があります。

  これにより、`http.extraHeader` のように、機密情報が値の一部であるような変数のセキュリティが強化されるかもしれませんが、`url.<base>.insteadOf` のように、機密情報がキーの一部であるような変数のセキュリティは強化されないことに注意してください。

- `--exec-path[=<path>]`

  Git のコアプログラムがインストールされている場所へのパス。これは、環境変数 `GIT_EXEC_PATH` を設定することでも制御できます。パスを指定しなかった場合、git は現在の設定を表示して終了します。

- `--html-path`

  Git の HTML ドキュメントがインストールされているパスを、末尾のスラッシュを除いて表示し、終了します。

- `--man-path`

  このバージョンの Git の man ページの manpath（man(1) 参照）を表示して終了します。

- `--info-path`

  このバージョンの Git を説明する Info ファイルがインストールされているパスを表示して終了します。

- `-p`, `--paginate`

  標準出力がターミナルの場合、すべての出力を `less` (または、設定されていれば `$PAGER`) にパイプします。これは、`pager.<cmd>` の設定オプションを上書きします（後述の「Configuration Mechanism」のセクションを参照）。

- `-P`, `--no-pager`

  Git の出力をページャーにパイプしない。

- `--git-dir=<path>`

  リポジトリ（「.git」ディレクトリ）へのパスを設定します。これは、環境変数 `GIT_DIR` を設定することでも制御できます。絶対パスでもカレントワーキングディレクトリへの相対パスでも構いません。

  このオプション（あるいは環境変数 `GIT_DIR`）を使って「.git」ディレクトリの場所を指定すると、「.git」サブディレクトリを持つディレクトリを探そうとするリポジトリの発見（リポジトリや作業ツリーのトップレベルを発見する方法）がオフになり、作業ツリーのトップレベルにいることが Git に伝えられます。作業ツリーのトップレベルのディレクトリにいない場合は、`--work-tree=<path>` オプション (あるいは環境変数 `GIT_WORK_TREE`) を使って作業ツリーのトップレベルがどこにあるのかを Git に伝えなければなりません。

  あたかも `<path>` で起動したかのように git を実行したいだけなら、`git -C <path>` を使います。

- `--work-tree=<path>`

  作業ツリーへのパスを設定します。絶対パスか、あるいは現在の作業ディレクトリからの相対パスを指定します。これは、環境変数 `GIT_WORK_TREE` や設定変数 `core.worktree` を設定することでも制御できます (より詳しい説明は [git-config[1]](https://git-scm.com/docs/git-config) の `core.worktree` を参照ください)。

- `--namespace=<path>`

  Git の名前空間を設定します。詳しくは [gitnamespaces[7]](https://git-scm.com/docs/gitnamespaces) を参照してください。環境変数 `GIT_NAMESPACE` を設定するのと同じです。

- `--super-prefix=<path>`

  現在は内部使用のみです。リポジトリの上位からそのルートまでのパスを与えるプレフィックスを設定します。サブモジュールに、起動したスーパープロジェクトのコンテキストを与えるために使用します。

- `--bare`

  リポジトリをベアリポジトリとして扱います。`GIT_DIR` 環境が設定されていない場合は、現在の作業ディレクトリに設定されます。

- `--no-replace-objects`

  Git オブジェクトの置換に refs 置換を使用しません。詳しくは [git-replace[1]](https://git-scm.com/docs/git-replace) を参照してください。

- `--literal-pathspecs`

  パス指定を文字通りに扱います (つまり、グロブやパス指定のマジックは使用しません)。これは、環境変数 `GIT_LITERAL_PATHSPECS` を `1` に設定することと同じです。

  - `--glob-pathspecs`

    すべての pathspec に "glob" マジックを追加します。これは、環境変数 `GIT_GLOB_PATHSPECS` を `1` に設定することと同じです。個々のパス指定でグロブを無効にするには、パス指定マジック ":(literal)" を使用します。

- `--noglob-pathspecs`

  すべてのパススペックに "literal" マジックを追加します。これは、環境変数 `GIT_NOGLOB_PATHSPECS` を `1` に設定するのと同じです。個々のパス指定でグロブを有効にするには、パス指定マジック ":(glob)" を使います。

- `--icase-pathspecs`

  すべてのパスペックに "icase" マジックを追加します。これは、環境変数 `GIT_ICASE_PATHSPECS` を `1` に設定することと同じです。

- `--no-optional-locks`

  ロックを必要とするオプション操作を行わない。これは環境変数 `GIT_OPTIONAL_LOCKS` を `0` に設定することと同じです。

- `--list-cmds=group[,group...]`

  グループ別にコマンドを一覧表示します。これは内部/実験的なオプションであり、将来的に変更または削除される可能性があります。サポートされているグループは次のとおりです: `builtins`、`parseopt`（parse-options を使用する builtin コマンド）、`main`（libexec ディレクトリにあるすべてのコマンド）、`others`（`$PATH` にある git- 接頭辞を持つその他のすべてのコマンド）、`list-<category>`（command-list.txt のカテゴリを参照）、`nohelpers`（ヘルパーコマンドを除外）、`alias` および `config`（config 変数 completion.commands からコマンドリストを取得）。

## `clone`

### NAME

git-clone — リポジトリを新しいディレクトリに複製する

### SYNOPSIS

```
git clone [--template=<template_directory>]
          [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror]
          [-o <name>] [-b <name>] [-u <upload-pack>] [--reference <repository>]
          [--dissociate] [--separate-git-dir <git dir>]
          [--depth <depth>] [--[no-]single-branch] [--no-tags]
          [--recurse-submodules[=<pathspec>]] [--[no-]shallow-submodules]
          [--[no-]remote-submodules] [--jobs <n>] [--sparse]
          [--filter=<filter>] [--] <repository>
          [<directory>]
```


### DESCRIPTION

リポジトリを新しく作成されたディレクトリに複製し、
複製されたリポジトリ内の各ブランチのリモート追跡ブランチを作成し（git branch --remotes を使用して表示）、
複製されたリポジトリの現在アクティブなブランチからフォークされた初期ブランチを作成してチェックアウトします。

クローン作成後、引数のないプレーンな git fetch は、すべてのリモートトラッキングブランチを更新し、
引数のない git pull は、リモートマスターブランチを現在のマスターブランチにマージします
（「--single-branch」が指定されている場合、これは当てはまりません；以下を参照してください）。

このデフォルト構成は、refs/remotes/origin の下にリモートブランチヘッドへの参照を作成し、
remote.origin.url および remote.origin.fetch 構成変数を初期化することによって実現されます。

### OPTIONS

- `-l`, `--local`

  クローンを作成するリポジトリがローカルマシン上にある場合、このフラグは通常の「Git を意識した」トランスポートメカニズムをバイパスし、HEAD と objects および refs ディレクトリ以下のすべてのコピーを作成してリポジトリをクローンします。`.git/objects/` ディレクトリ以下のファイルは、可能な限りスペースを節約するためにハードリンクされます。

  リポジトリをローカルパス（例：`/path/to/repo`）で指定した場合は、これがデフォルトであり、`--local` は基本的に何もしません。リポジトリが URL として指定されている場合は、このフラグは無視されます（ローカルでの最適化も使用しません）。`--no-local` を指定すると、`/path/to/repo` を指定したときのデフォルトを上書きし、代わりに通常の Git トランスポートを使用します。

  NOTE: この操作は、ソースリポジトリを同時に変更した場合に競合する可能性があります。これは、`src` を変更しながら `cp -r src dst` を実行した場合と同様です。

- `--no-hardlinks`

  ローカルファイルシステム上のリポジトリからのクローン作成時に、ハードリンクを使わずに `.git/objects` ディレクトリの下にファイルをコピーするようにします。これは、リポジトリのバックアップを取る場合などに有効です。

- `-s`, `--shared`

  複製するリポジトリがローカルマシン上にある場合、ハードリンクを使う代わりに、`.git/objects/info/alternates` を自動的にセットアップして複製元リポジトリとオブジェクトを共有します。複製元のリポジトリは、最初は自分のオブジェクトがありません。

  NOTE: これは危険な操作なので、理解できないうちは使わないでください。このオプションを使ってリポジトリをクローンした後、ソースリポジトリでブランチを削除したり（あるいは既存のコミットを参照しなくなるような Git コマンドを使ったり）すると、いくつかのオブジェクトが参照されなくなる（あるいはぶら下がる）可能性があります。これらのオブジェクトは、`git maintenance run --auto` を自動的に呼び出す通常の Git 操作 (`git commit` など) で削除することができます。([git-maintenance[1]](https://git-scm.com/docs/git-maintenance) を参照)。これらのオブジェクトが削除された後にクローンリポジトリが参照していた場合、クローンリポジトリは壊れてしまいます。

  なお、`--shared` でクローンしたリポジトリで `--local` オプションを指定せずに `git repack` を実行すると、ソースリポジトリのオブジェクトがクローンしたリポジトリのパックにコピーされてしまい、`clone --shared` で得られるディスクスペースの節約効果がなくなってしまいます。しかし、git gc を実行すれば安全です。`git gc` はデフォルトで `--local` オプションを使用します。

  `--shared` でクローンしたリポジトリのソースリポジトリへの依存関係を断ち切りたい場合は、単純に `git repack -a` を実行すると、ソースリポジトリのすべてのオブジェクトがクローンしたリポジトリのパックにコピーされます。

- `--reference[-if-able] <repository>`

  参照リポジトリがローカルマシンにある場合は、`.git/objects/info/alternates` を自動的に設定して、参照リポジトリからオブジェクトを取得します。既存のリポジトリを代替品として使用すると、クローンを作成するリポジトリからコピーするオブジェクトの数が少なくなり、ネットワークやローカルストレージのコストを削減できます。`--reference-if-able` を使用すると、存在しないディレクトリはクローンを中止するのではなく、警告を表示してスキップされます。

  NOTE: `--shared` オプションの NOTE、および `--dissociate` オプションの NOTE を参照してください。

- `--dissociate`

  ネットワーク転送を減らすために `--reference` オプションで指定された参照リポジトリからのみオブジェクトを借り、借りたオブジェクトの必要なローカルコピーを作成することで、クローン作成後に借り入れを停止します。このオプションは、すでに他のリポジトリからオブジェクトを借用しているリポジトリからローカルにクローンを作成する場合にも使用できます。新しいリポジトリは同じリポジトリからオブジェクトを借用しますが、このオプションを使用して借用を停止することができます。

- `-q`, `--quiet`

  静かに動作します。進捗状況が標準エラーストリームに報告されません。

- `-v`, `--verbose`

  冗長に動作します。標準エラーストリームへの進捗状況の報告には影響しません。

- `--progress`

  `--quiet` が指定されていない限り、標準エラーストリームがターミナルに接続されている場合、デフォルトで進捗状況が報告されます。このフラグは、標準エラーストリームがターミナルに向けられていない場合でも、プログレスステータスを強制します。

- `--server-option=<option>`

  プロトコル バージョン 2 で通信している場合、指定した文字列をサーバに送信します。指定する文字列には、NULまたはLFを含めてはいけません。未知のものも含めて、サーバーのオプションの扱いはサーバーごとに異なります。複数の `--server-option=<option>` が指定された場合は、コマンドラインに記載されている順に、すべてのオプションが相手側に送信されます。

- `-n`, `--no-checkout`

  クローンが完了しても、HEAD のチェックアウトを行いません。

- `--[no-]reject-shallow`

  ソースリポジトリがシャローリポジトリの場合に失敗します。`clone.rejectShallow` 設定変数でデフォルトを指定することができます。

- `--bare`

  ベア Git リポジトリを作成します。つまり、`<directory>` を作成して管理用のファイルを `<directory>/.git` に置くのではなく、`<directory>` 自体を `$GIT_DIR` にするのです。これは明らかに `--no-checkout` を意味します。作業ツリーをチェックアウトする場所がないからです。また、リモートのブランチヘッドは、`refs/remotes/origin/` にマッピングされることなく、対応するローカルのブランチヘッドに直接コピーされます。このオプションを使用すると、リモートトラッキングブランチも関連する設定変数も作成されません。

- `--sparse`

  sparse-checkout ファイルを初期化して、作業ディレクトリがリポジトリのルートにあるファイルだけで始まるようにします。sparse-checkout ファイルは、必要に応じて作業ディレクトリを増やすように変更できます。

- `--filter=<filter-spec>`

  パーシャルクローン機能を使用して、与えられたオブジェクトフィルタに従って、到達可能なオブジェクトのサブセットを送信するようにサーバに要求します。`--filter` を使用すると、指定された`<filter-spec>` がパーシャル クローンフィルタに使用されます。たとえば、`--filter=blob:none` は、Git が必要とするまで、すべてのブロブ（ファイルの内容）をフィルタリングします。また、`--filter=blob:limit=<size>` とすると、少なくとも `<size>` 以上のサイズのブロブをすべてフィルタリングします。フィルタの仕様についての詳細は、[git-rev-list[1]](https://git-scm.com/docs/git-rev-list) の `--filter` オプションを参照ください。

- `--mirror`

  ソースリポジトリのミラーを設定します。これは `--bare` を意味します。`--bare` と比べて `--mirror` は、ソースのローカルブランチをターゲットのローカルブランチにマップするだけでなく、すべての refs (リモートトラッキングブランチやノートなどを含む) をマップし、ターゲットリポジトリの `git remote update`によってこれらの refs がすべて上書きされるように refspec 設定を行います。

- `-o <name>`, `--origin <name>`

  上流のリポジトリを追跡するためにリモート名 `origin` を使う代わりに、`<name>` を使います。設定の `clone.defaultRemoteName` を上書きします。

- `-b <name>`, `--branch <name>`

  新しく作成された HEAD を、クローンされたリポジトリの HEAD が指すブランチに向けるのではなく、`<name>` ブランチに向けるようにします。ベアリポジトリでない場合、これがチェックアウトされるブランチになります。`--branch` はタグを取り、結果のリポジトリのそのコミットで HEAD をデタッチすることもできます。

- `-u <upload-pack>`, `--upload-pack <upload-pack>`

  クローンを作成するリポジトリにsshでアクセスする場合、相手側で実行するコマンドにデフォルト以外のパスを指定します。

- `--template=<template_directory>`

  テンプレートを使用するディレクトリを指定します ([git-init[1]](https://git-scm.com/docs/git-init) の "TEMPLATE DIRECTORY" セクションを参照)。

- `-c <key>=<value>`, `--config <key>=<value>`

  新しく作成されたリポジトリに設定変数を設定します。この設定は、リポジトリが初期化された直後に有効になりますが、リモートの履歴が取得されたり、ファイルがチェックアウトされたりする前に有効になります。キーは、[git-config[1]](https://git-scm.com/docs/git-init) で期待されるのと同じ形式です (例: `core.eol=true`)。同じキーに複数の値を指定すると、それぞれの値が設定ファイルに書き込まれます。これにより、たとえばオリジンのリモートに追加のフェッチ refspec を追加しても安全になります。

  現在の実装の制限により、一部の設定変数は最初のフェッチとチェックアウトが終わるまで有効になりません。反映されない設定変数としては、`remote.<name>.mirror` と `remote.<name>.tagOpt` があります。代わりに、対応する `--mirror` および `--no-tags` オプションを使用してください。

- `--depth <depth>`

  指定された数のコミットに切り詰められた履歴を持つ、浅いクローンを作成します。`--no-single-branch` が指定されていない限り、`--single-branch` を暗示し、すべてのブランチの先端付近の履歴を取得します。サブモジュールを浅くクローンしたい場合は、`--shallow-submodules` も渡してください。

- `--shallow-since=<date>`

  指定された時間以降の履歴を持つ浅いクローンを作成します。


- `--shallow-exclude=<revision>`

  指定されたリモートブランチやタグから到達可能なコミットを除いた履歴を持つシャロークローンを作成します。このオプションは複数回指定することができます。

- `--[no-]single-branch`

  `--branch` オプションで指定されたブランチ、またはリモートの HEAD が指しているプライマリブランチの先端に至るまでの履歴のみをクローンします。結果として得られるリポジトリをさらにフェッチすると、最初のクローン作成時にこのオプションが使用されたブランチのリモートトラッキングブランチのみが更新されます。`--single-branch` クローンが作成されたときに、リモートの HEAD がどのブランチも指していなかった場合、リモートトラッキングブランチは作成されません。


- `--no-tags`

  タグのクローンを作成せず、設定ファイルで `remote.<remote>.tagOpt=--no-tags` を設定すると、今後の `git pull` や `git fetch` の操作でタグを追いかけることができなくなります。その後、明示的にタグを取得しても動作します ([git-fetch[1]](https://git-scm.com/docs/git-fetch) を参照ください)。

  `--single-branch` と一緒に使うと、クローンされたブランチ以外の参照を持たないブランチを維持することができます。これは、例えばあるリポジトリのデフォルトブランチの最小限のクローンを維持して検索インデックスを作成する場合などに便利です。

- `--recurse-submodules[=<pathspec>]`

  クローンが作成された後、提供された pathspec に基づいて、その中のサブモジュールを初期化し、クローンを作成します。pathspec が指定されていない場合は、すべてのサブモジュールが初期化され、クローンが作成されます。このオプションは、複数のエントリからなる pathspec に対して複数回指定できます。複製されたサブモジュールの `submodule.active` には、指定されたパス指定が設定されますが、"." (すべてのサブモジュールを意味する) に設定されます。

  サブモジュールは初期化され、デフォルトの設定でクローンされます。これは、クローンが終了した直後に `git submodule update --init --recursive <pathspec>` を実行するのと同じです。このオプションは、クローンされるリポジトリに worktree/checkout がない場合 (つまり `--no-checkout`/`-n`, `--bare`, `--mirror` のいずれかが指定されている場合) には無視されます。

- `--[no-]shallow-submodules`

  複製されるすべてのサブモジュールは、深さが1の浅いものになります。

- `--[no-]remote-submodules`

  複製されたすべてのサブモジュールは、スーパープロジェクトに記録されている SHA-1 ではなく、サブモジュールのリモート追跡ブランチの状態を使ってサブモジュールを更新します。`git submodule update` に `--remote` を渡すのと同じです。

- `--separate-git-dir=<git dir>`

  クローンリポジトリを本来あるべき場所に置くのではなく、クローンリポジトリを指定したディレクトリに置き、そこにファイルシステムに依存しないGitシンボリックリンクを作成します。その結果、Git リポジトリを作業ツリーから切り離すことができるようになります。

- `-j <n>`, `--jobs <n>`

  一度に取得するサブモジュールの数を指定します。デフォルトでは `submodule.fetchJobs` オプションが指定されます。

- `<repository>`

  クローンを作成するリポジトリ(リモートの場合もあります)です。リポジトリの指定についての詳細は、下記の [GIT URLS](https://git-scm.com/docs/git-clone#URLS) セクションを参照してください。

- `<directory>`

  クローンを作成する新しいディレクトリの名前です。ディレクトリが明示的に指定されていない場合は、ソースリポジトリの "humanish" 部分が使用されます (`repo` は `/path/to/repo.git`、`foo` は `host.xz:foo/.git`)。既存のディレクトリへのクローン作成は、そのディレクトリが空の場合のみ可能です。

### GIT URLS

一般に、URL にはトランスポートプロトコル、リモートサーバーのアドレス、そしてリポジトリへのパスの情報が含まれています。トランスポート・プロトコルによっては、これらの情報の一部が含まれていないこともあります。

Git は、ssh、git、http、https の各プロトコルをサポートしています (さらに、ftp や ftps もフェッチに使用できますが、これは非効率で非推奨です。使用しないでください)。

ネイティブトランスポート (つまり git:// URL) は認証を行わないので、セキュリティが確保されていないネットワークでの使用には注意が必要です。

以下のような構文が使用できます：

- `ssh://[user@]host.xz[:port]/path/to/repo.git/`

- `git://host.xz[:port]/path/to/repo.git/`

- `http[s]://host.xz[:port]/path/to/repo.git/`

- `ftp[s]://host.xz[:port]/path/to/repo.git/`

scp に似た別の構文を ssh プロトコルで使うこともできます：

- `[user@]host.xz:path/to/repo.git/`

この構文は、最初のコロンの前にスラッシュがない場合にのみ認識されます。これは、コロンを含んだローカルパスを区別するのに役立ちます。たとえば、ローカルパス `foo:bar` を絶対パスで指定したり `./foo:bar` としたりすることで、ssh の url と誤解されないようにします。

ssh および git プロトコルは、さらに ~username の展開にも対応しています：

- `ssh://[user@]host.xz[:port]/~[user]/path/to/repo.git/`

- `git://host.xz[:port]/~[user]/path/to/repo.git/`

- `[user@]host.xz:/~[user]/path/to/repo.git/`

また、Git がネイティブにサポートしているローカルリポジトリの場合は、次のような構文を使用できます：

- `/path/to/repo.git/`

- `file:///path/to/repo.git/`

このふたつの構文はほとんど同じです。ただし、前者は `--local` オプションを必要とします。

`git push` ではなく、`git clone`、`git fetch`、`git pull` でも適切なバンドルファイルを受け取ることができます。[git-bundle[1]](https://git-scm.com/docs/git-bundle)を参照してください。

Git が特定のトランスポートプロトコルの扱い方を知らない場合は、`remote<transport>` というリモートヘルパーがあればそれを使おうとします。リモートヘルパーを明示的に要求するには、次のような構文を使います：

- `<transport>::<address>`

ここで `<address>` には、パス、サーバーとパス、あるいは特定のリモートヘルパーが認識する任意の URL のような文字列を指定します。詳細は [gitremote-helpers[7]](https://git-scm.com/docs/gitremote-helpers) を参照ください。

似たような名前のリモートリポジトリが大量にあって、それらに対して別のフォーマットを使いたい (使用する URL を動作する URL に書き換えるような) 場合は、次のような形式の設定セクションを作ることができます：

```
[url "<actual url base>"]
        insteadOf = <other url base>
```

たとえば、これで：

```
[url "git://git.host.xz/"]
        insteadOf = host.xz:/path/to/
        insteadOf = work:
```

"work:repo.git" や "host.xz:/path/to/repo.git" のようなURLは、"git://git.host.xz/repo.git" という URL を受け取るすべてのコンテキストで書き換えられます。

プッシュ時のみにURLを書き換えたい場合は、以下のような形式の設定部分を作ります：

```
[url "<actual url base>"]
        pushInsteadOf = <other url base>
```

例えば、これで：

```
[url "ssh://example.org/"]
        pushInsteadOf = git://example.org/
```

のようなURLは、プッシュ時には "git://example.org/path/to/repo.git "に書き換えられますが、プル時には元の URL が使われます。

### EXAMPLES

- 上流からのクローンを作成します：

  ```
  $ git clone git://git.kernel.org/pub/scm/.../linux.git my-linux
  $ cd my-linux
  $ make
  ```

- カレントディレクトリから、チェックアウトせずに借りてくるローカルクローンを作ります：

  ```
  $ git clone -l -s -n . ../copy
  $ cd ../copy
  $ git show-branch
  ```

- 既存のローカルディレクトリから借用しながら、アップストリームからクローンを作成します：

  ```
  $ git clone --reference /git/linux.git \
          git://git.kernel.org/pub/scm/.../linux.git \
          my-linux
  $ cd my-linux
  ```

- 変更を公開するためのベアリポジトリを作成します：

  ```
  $ git clone --bare -l /home/proj/.git /pub/scm/proj.git
  ```

## `init`

### NAME

git-init — 空の Git リポジトリを作成するか、既存の Git リポジトリを再初期化する

### SYNOPSIS
```
git init [-q | --quiet] [--bare] [--template=<template_directory>]
          [--separate-git-dir <git dir>] [--object-format=<format>]
          [-b <branch-name> | --initial-branch=<branch-name>]
          [--shared[=<permissions>]] [directory]
```

### DESCRIPTION

このコマンドは、空の Git リポジトリを作成します。基本的には、`object`、`refs/heads`、`refs/tags`、およびテンプレートファイルのサブディレクトリを含む `.git` ディレクトリです。コミットのない初期ブランチが作成されます（名前については、以下の `--initial-branch` オプションを参照してください）。

`$GIT_DIR` 環境変数が設定されている場合、リポジトリのベースに `./.git` の代わりに使用するパスを指定します。

オブジェクトストレージディレクトリが `$GIT_OBJECT_DIRECTORY` 環境変数を介して指定されている場合、sha1 ディレクトリがその下に作成されます。それ以外の場合は、デフォルトの `$GIT_DIR/objects` ディレクトリが使用されます。

既存のリポジトリで `git init` を実行しても安全です。すでに存在するものを上書きすることはありません。`git init` を再実行する主な理由は、新しく追加されたテンプレートを取得することです（または、`--separate-git-dir` が指定されている場合はリポジトリを別の場所に移動します）。

### OPTIONS

- `-q`, `--quiet`

  エラーメッセージと警告メッセージのみを出力します。他のすべての出力は抑制されます。

- `--bare`

  ベアリポジトリを作成します。`GIT_DIR` 環境が設定されていない場合は、現在の作業ディレクトリに設定されます。

- `--object-format=<format>`

  リポジトリのオブジェクトフォーマット（ハッシュアルゴリズム）を指定します。有効な値は _sha1_ と（有効な場合）_sha256_ です。_sha1_ がデフォルトです。

  このオプションは実験的なものです！SHA-256 のサポートは実験的なもので、まだ初期段階にあります。SHA-256 リポジトリは、一般に、「通常の」SHA-1 リポジトリと作業を共有することができません。たとえば、SHA-256 リポジトリに関連する Git 内部のファイルフォーマットは、後方互換性のない方法で変更される可能性があることを想定しておく必要があります。`--object-format=sha256` はテスト目的でのみ使用してください。

- `--template=<template_directory>`

  テンプレートが使用されるディレクトリを指定します。(後述の「TEMPLATE DIRECTORY」セクションを参照してください。)

- `--separate-git-dir=<git dir>`

  リポジトリを `$GIT_DIR` または `./.git/` のいずれかのディレクトリとして初期化する代わりに、実際のリポジトリへのパスを含むテキストファイルをそこに作成します。このファイルは、リポジトリへのファイルシステムに依存しない Git シンボリックリンクとして機能します。

- `-b <branch-name>`, `--initial-branch=<branch-name>`

  新しく作成されたリポジトリの最初のブランチには、指定された名前を使用します。指定しない場合は、デフォルト名にフォールバックします（現在は `master` ですが、将来変更される可能性があります。名前は `init.defaultBranch` 構成変数を使用してカスタマイズできます）。

- `--shared[=(false|true|umask|group|all|world|everybody|0xxx)]`

  Git リポジトリを複数のユーザーで共有することを指定します。これにより、同じグループに属するユーザーがそのリポジトリにプッシュできるようになります。指定すると、設定変数 `core.sharedRepository` が設定され、`$GIT_DIR` 以下のファイルやディレクトリが要求されたパーミッションで作成されるようになります。指定しない場合、Git は umask(2) によって報告されたパーミッションを使用します。

  このオプションには次のような値を指定できます。値が指定されていない場合は `group` がデフォルトとなります。

  - `umask`|`false`

    umask(2) によって報告されたアクセス許可を使用します。`--shared` が指定されていない場合のデフォルト。

  - `group`|`true`

    リポジトリをグループ書き込み可能にします (git グループがすべてのユーザーのプライマリグループではない場合があるので、g+sx も)。これは、安全な umask(2) の値のパーミッションを緩めるために使われます。ただし、umask は他のパーミッションビットにも適用されることに注意しましょう (たとえば `umask` が `0022` の場合、`group` を使っても他の (group ではない) ユーザーから読み取り権限を奪うことはできません)。リポジトリのパーミッションを正確に指定する方法については、0xxx を参照してください。

  - `all`|`world`|`everybody`

    `group` と同じですが、すべてのユーザーがリポジトリを読み取り可能にします。

  - `0xxx`

    `0xxx` は 8進数で、各ファイルのモードは `0xxx` になります。`0xxx` は、ユーザーの umask(2) の値を上書きします（`group` と `all` のようにパーミッションが緩くなるだけではありません）。`0640` は、グループ読み取り可能なリポジトリを作成しますが、グループ書き込み可能ではなく、他の人がアクセスできるわけでもありません。`0660` は、現在のユーザーとグループに対しては読み取りと書き込みが可能ですが、他のユーザーからはアクセスできないリポジトリを作成します。

  デフォルトでは、共有リポジトリでは `receive.denyNonFastForwards` という設定フラグが有効になっており、高速転送ではないプッシュを強制的に行うことができません。

  `directory` を指定した場合、コマンドはその中で実行されます。このディレクトリが存在しない場合は、作成されます。

### TEMPLATE DIRECTORY

名前がドットで始まらないテンプレートディレクトリ内のファイルとディレクトリは、作成後に `$GIT_DIR` にコピーされます。

テンプレートディレクトリは、次のいずれかになります（順番に）：

- `--template` オプションで指定された引数。
- `$GIT_TEMPLATE_DIR` 環境変数の内容。
- `init.templateDir` 構成変数。また、
- デフォルトのテンプレートディレクトリ：`/usr/share/git-core/templates`。

デフォルトのテンプレートディレクトリには、いくつかのディレクトリ構造、推奨される「除外パターン」（[gitignore[5]](https://git-scm.com/docs/gitignore) を参照）、およびサンプルフックファイルが含まれています。

サンプルフックはデフォルトですべて無効になっています。サンプルフックの1つを有効にするには、`.sample` サフィックスを削除して名前を変更します。

フックの実行に関するより一般的な情報については、[githooks[5]](https://git-scm.com/docs/githooks) を参照してください。

### EXAMPLES

既存のコードベースの新しいGitリポジトリを開始します

```bash
$ cd /path/to/my/codebase
$ git init      (1)
$ git add .     (2)
$ git commit    (3)
```

1. `/path/to/my/codebase/.git` ディレクトリを作成します。
2. 既存のすべてのファイルをインデックスに追加します。
3. 履歴の最初のコミットとして、元の状態を記録します。

## `add`

### NAME

git-add — ファイルの内容をインデックスに追加する

### SYNOPSIS

```
git add [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p]
          [--edit | -e] [--[no-]all | --[no-]ignore-removal | [--update | -u]]
          [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing] [--renormalize]
          [--chmod=(+|-)x] [--pathspec-from-file=<file> [--pathspec-file-nul]]
          [--] [<pathspec>...]
```

### DESCRIPTION

このコマンドは、作業ツリーで見つかった現在のコンテンツを使用してインデックスを更新し、次のコミットのためにステージングされたコンテンツを準備します。通常、既存のパスの現在のコンテンツを全体として追加しますが、一部のオプションでは、作業ツリーファイルに加えられた変更の一部のみを適用してコンテンツを追加したり、作業ツリーに存在しないパスを削除したりすることもできます。

「index」は作業ツリーのコンテンツのスナップショットを保持し、次のコミットのコンテンツとして取得されるのはこのスナップショットです。したがって、作業ツリーに変更を加えた後、commit コマンドを実行する前に、`add` コマンドを使用して、新しいファイルまたは変更されたファイルをインデックスに追加する必要があります。

このコマンドは、コミットする前に複数回実行できます。add コマンドの実行時に、指定されたファイルのコンテンツのみが追加されます。次のコミットに後続の変更を含める場合は、`git add` を再度実行して、新しいコンテンツをインデックスに追加する必要があります。

`git status` コマンドを使用して、次のコミットのためにステージングされる変更が含まれているファイルの概要を取得できます。

`git add` コマンドは、デフォルトでは無視されたファイルを追加しません。無視されたファイルがコマンドラインで明示的に指定された場合、gitadd は無視されたファイルのリストとともに失敗します。Git によって実行された再帰的ディレクトリまたはファイル名グロブによって到達した無視されたファイルは、暗黙的に無視されます。`git add` コマンドを使用して、`-f`（force）オプションを指定して無視されたファイルを追加できます。

コミットにコンテンツを追加する別の方法については、[git-commit[1]](https://git-scm.com/docs/git-commit) を参照してください。


### OPTIONS

- `<pathspec>...`

  コンテンツを追加するファイルを指定します。ファイルグローブ（例：`*.c`）を指定すると、マッチするすべてのファイルを追加することができます。また、先頭にディレクトリ名（例：`dir` で `dir/file1` と `dir/file2` を追加）を指定すると、ディレクトリ全体の現在の状態に合わせてインデックスを更新することができます（例：`dir` を指定すると、作業ツリーで変更されたファイル `dir/file1`、作業ツリーに追加されたファイル `dir/file2` だけでなく、作業ツリーから削除されたファイル `dir/file3` も記録されます）。古いバージョンの Git では、削除されたファイルを無視していたことに注意してください。変更されたファイルや新しいファイルを追加し、削除されたファイルを無視したい場合は、`--no-all` オプションを使用してください。

  `<pathspec>` 構文の詳細については、[gitglossary[7]](https://git-scm.com/docs/gitglossary) の pathspec エントリを参照ください。

- `-n`, `--dry-run`

  実際にファイルを追加するのではなく、ファイルが存在するかどうか、あるいは無視されるかどうかを表示します。

- `-v`, `--verbose`

  冗長に表示します。

- `-f`, `--force`

  無視されているファイルを追加します。

- `-i`, `--interactive`

  作業ツリーで変更されたコンテンツをインタラクティブにインデックスに追加します。オプションのパス引数を指定すると、作業ツリーのサブセットに操作を限定することができます。詳細は、「Interactive mode」を参照してください。

- `-p`, `--patch`

  インデックスと作業ツリーの間にあるパッチの塊を対話的に選び、インデックスに追加します。これにより、変更されたコンテンツをインデックスに追加する前に、ユーザが差分を確認する機会が与えられます。

  これは効果的に `add --interactive` を実行しますが、最初のコマンドメニューをバイパスして `patch` サブコマンドに直接ジャンプします。詳細は「nteractive mode」を参照してください。

- `-e`, `--edit`

  diff 対 index をエディタで開き、ユーザに編集させます。エディタを閉じた後、ハンクヘッダを調整し、インデックスにパッチを適用します。

  このオプションの意図は、パッチを適用する行を選んだり、ステージングする行の内容を修正することにあります。この方法は、インタラクティブなハンクセレクターを使用するよりも早く、柔軟性があります。しかし、自分自身を混乱させ、インデックスに適用されないパッチを作成することは簡単です。以下の「EDITING PATCHES」を参照してください。

- `-u`, `--update`

  `<pathspec>` にマッチするエントリがすでにある場合に、インデックスを更新します。これは、作業ツリーに合わせてインデックス・エントリを削除したり変更したりしますが、新しいファイルは追加しません。

  `-u` オプションの使用時に `<pathspec>` が与えられていない場合は、作業ツリー全体のすべての追跡ファイルが更新されます（Git の古いバージョンでは、更新の対象を現在のディレクトリとそのサブディレクトリに限定していました）。

- `-A`, `--all`, `--no-ignore-removal`

  作業ツリーに `<pathspec>` に一致するファイルがある場合だけでなく、インデックスにすでにエントリがある場合にもインデックスを更新します。作業ツリーに合わせて、インデックスのエントリを追加、修正、削除します。

  `-A` オプションを使用する際に `<pathspec>` が与えられていない場合、作業ツリー全体のすべてのファイルが更新されます（Git の古いバージョンでは、更新対象を現在のディレクトリとそのサブディレクトリに限定していました）。

- `--no-all`, `--ignore-removal`

  インデックスに知られていない新しいファイルや作業ツリーで変更されたファイルを追加してインデックスを更新しますが、作業ツリーから削除されたファイルは無視します。このオプションは、`<pathspec>` が使われていない場合には、no-opとなります。

  このオプションは主に、古いバージョンの Git に慣れているユーザーを助けるためのものです。「`git add <pathspec>...`」は「`git add --no-all <pathspec>...`」と同義語で、つまり削除されたファイルを無視していました。

- `-N`, `--intent-to-add`

  そのパスが後で追加されるという事実だけを記録します。そのパスに対応するエントリが、何も書かれていない状態でインデックスに置かれます。これは、このようなファイルのステージングされていない内容を `git diff` で表示したり `git commit -a` でコミットしたりするときなどに便利です。

- `--refresh`

  ファイルを追加せず、インデックスの stat() 情報だけを更新します。

- `--ignore-errors`

  ファイルのインデックス化にエラーがあって追加できなかった場合、操作を中断せずに他のファイルの追加を続行します。この場合でも、コマンドは非ゼロのステータスで終了する。構成変数 `add.ignoreErrors` を true に設定すると、この動作がデフォルトになります。

- `--ignore-missing`

  このオプションは `--dry-run` と一緒にのみ使用できます。このオプションを使用すると、指定されたファイルが作業ツリーにすでに存在しているかどうかにかかわらず、無視されるかどうかを確認することができます。

- `--no-warn-embedded-repo`

  デフォルトでは、`git add` は埋め込みリポジトリをインデックスに追加する際に、`git submodule add` を使わずに `.gitmodules` にエントリを作成すると警告を出します。このオプションを指定すると、この警告を抑制することができます (例: サブモジュールに対する操作を手動で行っている場合)。

- `--renormalize`

  追跡されたすべてのファイルに「clean」プロセスを新たに適用し、それらを強制的にインデックスに再追加します。これは、`core.autocrlf` の設定や `text` 属性を変更した後に、間違った CRLF/LF の改行コードで追加されたファイルを修正するのに便利です。このオプションは `-u` を意味します。

- `--chmod=(+|-)x`

  追加されたファイルの実行可能ビットを上書きします。実行可能ビットはインデックスでのみ変更され、ディスク上のファイルは変更されません。

- `--pathspec-from-file=<file>`

  パススペックをコマンドラインの引数ではなく `<file>` で渡します。`<file>` が正確に `-` であれば、標準入力が使用されます。Pathspec の要素は、LF または CR/LF で区切られます。設定変数 `core.quotePath`（[git-config[1]](https://git-scm.com/docs/git-config) 参照）の説明に従って、pathspec の要素を引用することができます。`--pathspec-file-nul` およびグローバルな `--literal-pathspecs` も参照してください。

- `--pathspec-file-nul`

  `--pathspec-from-file` との組み合わせでのみ意味を持ちます。Pathspec の要素は NUL 文字で区切られ、その他の文字はすべて文字通りに解釈されます（改行や引用符も含む）。

- `--`

  このオプションは、コマンドラインオプションとファイルのリストを分離するために使用できます（ファイル名がコマンドラインオプションと間違えられる可能性がある場合に便利です）。

### EXAMPLES

- `Documentation` ディレクトリとそのサブディレクトリの下にあるすべての `* .txt` ファイルからコンテンツを追加します：

  ```bash
  $ git add Documentation/\*.txt
  ```

  この例では、アスタリスク `*` がシェルから引用されていることに注意してください。これにより、コマンドに `Documentation/` ディレクトリのサブディレクトリからのファイルを含めることができます。

- すべての `git-*.sh` スクリプトからコンテンツを追加することを検討します：

  ```bash
  $ git add git-*.sh
  ```

  この例では、シェルがアスタリスクを展開できるため（つまり、ファイルを明示的にリストしている）、`subdir/git-foo.sh` は考慮されません。

### INTERACTIVE MODE

コマンドが対話型モードに入ると、`status` サブコマンドの出力が表示され、対話型コマンドループに入ります。

コマンドループは、使用可能なサブコマンドのリストを表示し、「`Whatnow>`」というプロンプトを表示します。一般に、プロンプトが単一の `>` で終了する場合、次のように、指定された選択肢の1つだけを選択し、_return_ と入力できます：

```
*** Commands ***
  1: status       2: update       3: revert       4: add untracked
  5: patch        6: diff         7: quit         8: help
What now> 1
```

選択が一意である限り、上記の`s`、`sta`、または `status` と言うこともできます。

メインのコマンドループには6つのサブコマンド（`help` と `quit` に加えて）があります。

- `status`

  これは、それぞれのパスについて、HEAD と index (つまり `git commit` した場合にコミットされるもの)、index と working tree ファイル (つまり `git add` して `git commit` する前にさらにステージングできるもの) の間の変化を示します。出力例は次のようになります：

  ```
           staged     unstaged path
  1:       binary      nothing foo.png
  2:     +403/-35        +1/-1 git-add--interactive.perl
  ```

  これを見ると、`foo.png` には HEAD との違いがあり (ただしバイナリなので行数は表示されません)、索引付きのコピーと作業用ツリーのバージョンには違いがありません (作業用ツリーのバージョンにも違いがあれば、何も表示されない代わりにバイナリが表示されるはずです)。もうひとつのファイル `git-add--interactive.perl` は、インデックスにあるものをコミットすると 403行が追加され35行が削除されますが、作業ツリーのファイルにはさらに修正が加えられています (追加が1つ、削除が1つ)。

- `update`

  これにより、ステータス情報が表示され、「`Update>>`」というプロンプトが表示されます。プロンプトが二重の `>>` で終わっている場合は、複数の選択が可能で、空白やカンマで連結されます。また、範囲を指定することもできます。例：「`2-5 7,9`」で 2,3,4,5,7,9 をリストから選択します。範囲内の2番目の数字が省略された場合、残りのすべてのパッチが選択されます。例：「`7-`」で 7,8,9 をリストから選ぶ。すべてを選択するには、`*` と言うこともできます。

  選んだものは、以下のように `*` でハイライトされます。

  ```
             staged     unstaged path
    1:       binary      nothing foo.png
  * 2:     +403/-35        +1/-1 git-add--interactive.perl
  ```

  選択を削除するには、次のように入力の前に `-` を付けます：

  ```
  Update>> -2
  ```

  選択を行った後、空の行で応答して、インデックス内の選択されたパスの作業ツリーファイルの内容をステージングします。

- `revert`

  これは `update` とよく似た UI で、選択されたパスの staged 情報が HEAD バージョンのものに戻されます。新しいパスを元に戻すと、そのパスはトラックされなくなります。

- `add untracked`

  これは、`update` や `revert` と非常によく似た UI を持ち、追跡されていないパスをインデックスに追加することができます。

- `patch`

  これにより、`status` のような選択の中から一つのパスを選ぶことができます。パスを選択した後、インデックスと作業ツリーファイルの差分を提示し、各ハンクの変更をステージングするかどうかを尋ねます。以下のオプションのいずれかを選択し、_return_ と入力します：

  ```
  y - このハンクをステージングする
  n - このハンクをステージングしない
  q - quit; このハンクや残りのハンクをステージングしない
  a - このハンクとファイル内のすべての後続ハンクをステージングする
  d - このハンクをステージングせず、ファイル内の後続のハンクもステージングしない
  g - 移動するハンクを選択する
  / - 指定された正規表現に一致するハンクを検索する
  j - このハンクを未決定にして、次の未決定ハンクを参照する
  J - このハンクを未決定にして、次のハンクを参照する
  k - このハンクを未決定にして、前の未決定のハンクを見る
  K - このハンクを未決定のままにして、前のハンクを参照する
  s - 現在のハンクをより小さなハンクに分割する
  e - 現在のハンクを手動で編集
  ? - ヘルプを表示する
  ```

  すべてのハンクの運命を決定した後、もし選択されたハンクがあれば、選択されたハンクでインデックスが更新されます。

  設定変数 `interactive.singleKey` を true に設定することで、ここで _return_ を入力する必要がなくなります。

- `diff`

 コミットされる内容 (つまり HEAD と index の間の内容) を確認することができます。

### EDITING PATCHES

`git add -e` を実行したり対話型の hunk セレクタで `e` を選択したりすると、パッチがエディタで開かれ、エディタが終了するとその結果がインデックスに適用されます。パッチには自由に変更を加えることができますが、中には混乱を招くような変更があったり、パッチを適用できない結果になったりすることもあるので注意が必要です。もし、この操作を完全に中止したい（つまり、インデックスに何も新しいものを入れないようにしたい）場合には、単純にパッチのすべての行を削除してください。以下のリストは、パッチの中でよく見られるものと、それに対してどのような編集操作が意味を持つかを説明しています。

- 追加されたコンテンツ

  追加されたコンテンツは、「`+`」で始まる行で表されます。追加行を削除することで、追加行のステージングを防ぐことができます。

- 削除されたコンテンツ

  削除されたコンテンツは、「`-`」で始まる行で表されます。この「`-`」を「` `」（スペース）に変換することで、削除されたコンテンツの演出を防ぐことができます。

- 修正されたコンテンツ

  修正されたコンテンツは、「`-`」で始まる行（古いコンテンツの削除）と「`+`」で始まる行（新しいコンテンツの追加）で表されます。「`-`」行を「` `」に変換し、「`+`」行を削除することで、修正内容の演出を防ぐことができます。ペアの半分だけを修正すると、インデックスに紛らわしい変化が生じる可能性が高いので注意が必要です。

また、より複雑な操作を行うこともできます。しかし、パッチはインデックスにのみ適用され、作業ツリーには適用されないため、作業ツリーではインデックスの変更を「undo」したように見えることに注意してください。たとえば、HEAD にも作業ツリーにもない新しい行をインデックスに導入すると、コミットのために新しい行がステージされますが、作業ツリーではその行は元に戻されたように見えます。

このような仕組みを使わないようにするか、細心の注意を払ってください。

- 手つかずのコンテンツの削除

  インデックスと作業ツリーの間に違いのないコンテンツは、「` `」（スペース）で始まるコンテクストラインに表示することができます。スペースを「`-`」に変換することで、コンテクストラインをステージングして削除することができます。その結果、作業ツリーファイルにコンテンツが再追加されます。

- 既存のコンテンツの修正

  コンテキストラインを削除するためにステージングして（「` `」を「`-`」に変換して）、新しいコンテンツを含む「`+`」ラインを追加することで、コンテキストラインを修正することもできます。同様に、既存の追加や修正のために「`+`」行を修正することもできます。いずれの場合も、作業ツリーでは新しい修正が元に戻されて表示されます。

- 新規コンテンツ

  パッチ内に存在しない新しいコンテンツを追加することもできます。単純に、それぞれが「`+`」で始まる新しい行を追加してください。追加された内容は、作業ツリーでは元に戻されたように表示されます。

パッチを適用できなくなるため、完全に回避する必要のある操作もいくつかあります：

- コンテキスト（「` `」）または削除（「`-`」）行の追加する
- コンテキストまたは削除行の削除する
- コンテキストまたは削除行の内容を変更する

### SEE ALSO

[git-status[1]](https://git-scm.com/docs/git-status), [git-rm[1]](https://git-scm.com/docs/git-rm), [git-reset[1]](https://git-scm.com/docs/git-reset), [git-mv[1]](https://git-scm.com/docs/git-mv), [git-commit[1]](https://git-scm.com/docs/git-commit), [git-update-index[1]](https://git-scm.com/docs/git-update-index)

## `mv`


### NAME

git-mv — ファイル、ディレクトリ、またはシンボリックリンクを移動または名前変更する

### SYNOPSIS
```
git mv <options>... <args>...
```

### DESCRIPTION

ファイル、ディレクトリ、またはシンボリックリンクを移動または名前変更します。

```
git mv [-v] [-f] [-n] [-k] <source> <destination>
git mv [-v] [-f] [-n] [-k] <source> ... <destination directory>
```
       
最初の形式では、ファイル、シンボリックリンク、またはディレクトリのいずれかである必要がある `<source>` の名前を `<destination>` に変更します。2番目の形式では、最後の引数は既存のディレクトリである必要があります。指定されたソースはこのディレクトリに移動されます。
       
インデックスは正常に完了すると更新されますが、変更はコミットする必要があります。

### OPTIONS

- `-f`, `--force`

  ターゲットが存在する場合でも、ファイルの名前変更または移動を強制します。

- `-k`

  エラー状態につながる移動または名前変更アクションをスキップします。ソースが存在せず、Git によって制御されていない場合、または `-f` が指定されていない限り、ソースが既存のファイルを上書きする場合、エラーが発生します。

- `-n`, `--dry-run`

  何もしません；何が起こるかを示すだけです。

- `-v`, `--verbose`

  移動するファイルの名前を報告します。

### SUBMODULES

gitfile を使用してサブモジュールを移動すると（つまり、Gitバージョン1.7.8以降で複製された）、gitfile と `core.worktree` の設定が更新され、サブモジュールが新しい場所で機能するようになります。また、[gitmodules[5]](https://git-scm.com/docs/gitmodules) ファイルの submodule。`<name>.path` 設定を更新し、そのファイルをステージングしようとします（`-n` が使用されている場合を除く）。

### BUGS

スーパープロジェクトの更新により、入力されたサブモジュールが移動されるたびに（たとえば、移動の前後でコミットを切り替える場合）、古いサブモジュールのチェックアウトは古い場所に残り、空のディレクトリが新しい場所に表示されます。新しい場所にサブモジュールを再度入力するには、ユーザーは後で「`git submodule update`」を実行する必要があります。古いディレクトリの削除は、gitfile を使用している場合にのみ安全です。そうしないと、サブモジュールの履歴も削除されます。再帰的なサブモジュールの更新が実装されている場合、両方の手順は廃止されます。

## `restore`

### NAME

git-restore — 作業ツリーファイルを復元する

### SYNOPSIS

```
git restore [<options>] [--source=<tree>] [--staged] [--worktree] [--] <pathspec>...
git restore [<options>] [--source=<tree>] [--staged] [--worktree] --pathspec-from-file=<file> [--pathspec-file-nul]
git restore (-p|--patch) [<options>] [--source=<tree>] [--staged] [--worktree] [--] [<pathspec>...]
```

### DESCRIPTION

復元ソースからのコンテンツを使用して、作業ツリー内の指定されたパスを復元します。パスが追跡されているが、復元ソースに存在しない場合、ソースと一致するように削除されます。
       
このコマンドを使用して、`--staged` を使用してインデックスのコンテンツを復元したり、`--staged--worktree` を使用して作業ツリーとインデックスの両方を復元したりすることもできます。
       
デフォルトでは、`--staged` が指定されている場合、コンテンツは HEAD から復元され、それ以外の場合はインデックスから復元されます。別のコミットから復元するには、`--source` を使用します。
 
3つのコマンドの違いについては、[git[1]](https://git-scm.com/docs/git) の「Reset, restore and revert」を参照してください。

このコマンドは実験的なものです。 動作が変わる可能性があります。

### OPTIONS

- `-s <tree>`, `--source=<tree>`

  指定されたツリーの内容で作業ツリーのファイルを復元します。ソース ツリーを指定するには、そのツリーに関連するコミット、ブランチ、タグの名前を指定するのが一般的です。

  指定しない場合、`--staged` が指定されていれば `HEAD` から、そうでなければインデックスからコンテンツが復元されます。

  特殊なケースとして、マージベースが1つだけの場合、`A` と `B` のマージベースのショートカットとして「`A...B`」を使用することができます。`A` と `B` のうち、最大でも1つを省略することができ、その場合はデフォルトで `HEAD` になります。

- `-p`, `--patch`

  リストア元とリストア先の差分のハンクをインタラクティブに選択します。[git-add[1]](https://git-scm.com/docs/git-add) の「Interactive Mode」の項で `--patch` モードの操作方法を説明しています。

  なお、`--patch` は pathspec を受け付けず、変更されたすべてのパスをリストアするかどうかを尋ねてきます。

- `-W`, `--worktree`, `-S`, `--staged`

  リストアする場所を指定します。どちらのオプションも指定されていない場合、デフォルトでは作業ツリーがリストアされます。`--staged` を指定すると、インデックスのみがリストアされます。bothを指定すると、両方がリストアされます。

- `-q`, `--quiet`

  静かで、フィードバックメッセージを抑制します。`--no-progress` を意味します。

- `--progress`, `--no-progress`

  `--quiet` が指定されていない場合、ターミナルに接続されているときは、デフォルトで進行状況が標準エラーストリームに報告されます。このフラグは、`--quiet` の指定にかかわらず、端末に接続されていない場合でも進行状況の報告を有効にします。

- `--ours`, `--theirs`

  作業ツリーのファイルをインデックスから復元する際に、マージされていないパスに対してステージ #2 (ours) あるいは #3 (theirs) を使用します。

  ただし、`git rebase` や `git pull --rebase` の際には _ours_ と _theirs_ が入れ替わっているように見えることがあります。詳細は [git-checkout[1]](https://git-scm.com/docs/git-checkout) の同じオプションの説明を参照ください。

- `-m`, `--merge`

  作業ツリー上のファイルをインデックスから復元する場合は、マージされていないパスで競合するマージを再作成します。

- `--conflict=<style>`

  上記の `--merge` オプションと同じですが、コンフリクトするハンクの表示方法を変更し、`merge.conflictStyle` 構成変数を上書きします。設定可能な値は「`merge`」（デフォルト）と「`diff3`」（「`merge`」スタイルで表示される内容に加えて、オリジナルの内容も表示）です。

- `--ignore-unmerged`

  作業ツリー上のファイルをインデックスからリストアする際に、マージされていないエントリがあり、`--ours`、`--theirs`、`--merge`、`--conflict` のいずれも指定されていない場合、操作を中断しません。作業ツリー上のマージされていないパスはそのまま残されます。

- `--ignore-skip-worktree-bits`

  スパース・チェックアウト・モードでは、デフォルトでは `<pathspec>` と `$GIT_DIR/info/sparse-checkout` のスパース・パターンにマッチするエントリのみを更新します。このオプションは、スパース・パターンを無視して、`<pathspec>` にあるすべてのファイルを無条件にリストアします。

- `--recurse-submodules`, `--no-recurse-submodules`

  `<pathspec>` にアクティブなサブモジュールの名前があり、復元場所に作業ツリーが含まれている場合、このオプションが与えられたときにのみサブモジュールが更新されます。その場合、作業ツリーはスーパープロジェクトに記録されたコミットに復元され、ローカルの変更はすべて上書きされます。何もしない (あるいは `--no-recurse-submodules`) の場合は、サブモジュールの作業ツリーは更新されません。[git-checkout[1]](https://git-scm.com/docs/git-checkout) と同様に、サブモジュールの `HEAD` を切り離します。

- `--overlay`, `--no-overlay`

  オーバーレイモードでは、コマンドは復元の際にファイルを削除しません。no-overlay モードでは、`--source` ツリーに現れていない追跡ファイルが削除され、`<tree>` と完全に一致するようになります。デフォルトは no-overlay モードです。

- `--pathspec-from-file=<file>`

  パススペックをコマンドラインの引数の代わりに `<file>` で渡します。`<file>` が正確に `-` であれば、標準入力が使用されます。Pathspec の要素は LF または CR/LF で区切られます。設定変数 `core.quotePath`（[git-config[1]](https://git-scm.com/docs/git-config) 参照）の説明に従って、pathspec の要素を引用することができます。`--pathspec-file-nul` およびグローバルな `--literal-pathspecs` も参照してください。

- `--pathspec-file-nul`

  `--pathspec-from-file` との組み合わせでのみ意味を持ちます。Pathspec の要素は NUL 文字で区切られ、その他の文字はすべて文字通りに解釈されます（改行や引用符も含む）。

- `--`

  これ以上の引数をオプションとして解釈しません。

- `<pathspec>...`

  操作の影響を受けるパスを制限します。

  詳細については、[gitglossary[7]](https://git-scm.com/docs/gitglossary) の pathspec エントリを参照してください。

### EXAMPLES

次の手順では、`master` ブランチに切り替え、`Makefile` を2つ前のリビジョンに戻し、誤って hello.c を削除し、それをインデックスから取り戻します。

```bash
$ git switch main
$ git restore --source main~2 Makefile  (1)
$ rm -f hello.c
$ git restore hello.c                   (2)
```

1. take a file out of another commit
2. restore hello.c from the index

インデックス内のバージョンと一致するようにすべての C ソースファイルを復元する場合は、次のように言うことができます。

```bash
$ git restore '*.c'
```

`*.c` の前後の引用符に注意してください。ファイル `hello.c` は、作業ツリーに存在しなくなった場合でも復元されます。これは、ファイルグロブがインデックス内のエントリを照合するために使用されるためです（シェルによる作業ツリー内ではありません）。

現在のディレクトリ内のすべてのファイルを復元するには

```bash
$ git restore .
```

または、_最上位_の pathspec マジックを使用してすべての作業ツリーファイルを復元します（[gitglossary [7]](https://git-scm.com/docs/gitglossary) を参照）。

```bash
$ git restore :/
```

`HEAD` のバージョンと一致するようにインデックス内のファイルを復元するには（これは [git-reset[1]](https://git-scm.com/docs/git-reset) を使用するのと同じです）

```bash
$ git restore --staged hello.c
```

または、インデックスと作業ツリーの両方を復元できます（これは [git-checkout [1]](https://git-scm.com/docs/git-checkout) を使用するのと同じです）

```bash
$ git restore --source=HEAD --staged --worktree hello.c
```

または、より実用的で読みにくい短い形式：

```bash
$ git restore -s@ -SW hello.c
```

### SEE ALSO

[git-checkout[1]](https://git-scm.com/docs/git-checkout), [git-reset[1]](https://git-scm.com/docs/git-reset)

## `rm`

### NAME

git-rm — 作業ツリーとインデックスからファイルを削除する

### SYNOPSIS

```
git rm [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch]
          [--quiet] [--pathspec-from-file=<file> [--pathspec-file-nul]]
          [--] [<pathspec>...]
```

### DESCRIPTION

pathspec に一致するファイルをインデックスから、あるいは作業ツリーとインデックスから削除します。(作業ツリーからのみファイルを削除してインデックスには残すというオプションはありません。そうしたい場合は `/bin/rm` を使います)。削除されるファイルは、ブランチの先端と同一でなければならず、その内容の更新をインデックスにステージングすることはできませんが、このデフォルトの動作は、`-f` オプションで上書きすることができます。`--cached` が指定された場合、ステージングされたコンテンツは、ブランチの先端かディスク上のファイルのどちらかと一致しなければならず、そのファイルはインデックスだけから削除することができます。sparse-checkout を使用している場合 ([git-sparse-checkout[1]](https://git-scm.com/docs/git-sparse-checkout) を参照)、`git rm` は sparse-checkout パターン内のパスのみを削除します。

### OPTIONS
 
- `<pathspec>...`

  削除するファイル。先頭のディレクトリ名（例：`dir` で `dir/file1` と `dir/file2` を削除）を指定すると、そのディレクトリ内のすべてのファイルと、すべてのサブディレクトリを再帰的に削除することができますが、その場合は `-r` オプションを明示的に指定する必要があります。

  このコマンドは、Git に知られているパスのみを削除します。

  ファイル・グロブは、ディレクトリの境界を越えてマッチします。つまり、2つのディレクトリ `d` と `d2` があったときに `git rm 'd*'` を使うのと `git rm 'd/*'` を使うのとでは違いがあります。

  詳細は [gitglossary[7]](https://git-scm.com/docs/gitglossary) の _pathspec_ エントリを参照してください。

- `-f`, `--force`

  最新のチェックを上書きします。

- `-n`, `--dry-run`

  実際にファイルを削除しないでください。代わりに、それらがインデックスに存在するかどうかを表示し、そうでない場合はコマンドによって削除されます。

- `-r`

  先頭のディレクトリ名が指定されている場合は、再帰的な削除を許可します。

- `--`

  このオプションは、コマンドラインオプションをファイルのリストから分離するために使用できます（ファイル名がコマンドラインオプションと間違えられる可能性がある場合に便利です）。

- `--cached`

  このオプションを使用して、パスをステージング解除し、インデックスからのみ削除します。作業ツリーファイルは、変更されているかどうかに関係なく、そのままになります。

- `--ignore-unmatch`

  一致するファイルがない場合でも、ステータスがゼロで終了します。

- `-q`, `--quiet`

  `git rm` は通常、削除されたファイルごとに1行（ `rm` コマンドの形式で）を出力します。このオプションは、その出力を抑制します。

- `--pathspec-from-file=<file>`

  Pathspec は、コマンドラインの引数の代わりに `<file>` で渡されます。 `<file>` が正確に `-` の場合、標準入力が使用されます。Pathspec の要素は LF または CR/LF で区切られます。設定変数 `core.quotePath`（[git-config[1]](https://git-scm.com/docs/git-config) 参照）の説明に従って、pathspec の要素を引用することができます。`--pathspec-file-nul` やグローバルな `--literal-pathspecs` も参照してください。

- `--pathspec-file-nul`

  `--pathspec-from-file` でのみ意味があります。 Pathspec 要素は NUL 文字で区切られ、他のすべての文字は文字通りに解釈されます（改行と引用符を含む）。

### REMOVING FILES THAT HAVE DISAPPEARED FROM THE FILESYSTEM

`git rm` には、ファイルシステムから消えてしまったパスだけをインデックスから削除するオプションはありません。しかし、ユースケースに応じていくつかの方法があります。

- 「`git commit-a`」の使用

  次のコミットで、追跡されたファイルのすべての変更を作業ツリーに記録し、作業ツリーから削除されたファイルのすべての削除を（`git rm` ではなく）`rm` で記録する場合は、`git commit -a` を使用します。すべての削除に自動的に気づき、記録します。`git add -u` を使用して、コミットせずに同様の効果を得ることができます。

- 「`git add -A`」の使用

  ベンダーブランチの新しいコードドロップを受け入れるときは、パスの削除と新しいパスの追加、および既存のパスの変更の両方を記録することをお勧めします。

  通常、最初に次のコマンドを使用して、追跡されたすべてのファイルを作業ツリーから削除します：

  ```bash
  git ls-files -z | xargs -0 rm -f
  ```

  次に、作業ツリーで新しいコードを解凍します。または、変更を作業ツリーに _rsync_ することもできます。

  その後、作業ツリー内のすべての削除、追加、および変更を記録する最も簡単な方法は次のとおりです：

  ```bash
  git add -A
  ```

  [git-add[1]](https://git-scm.com/docs/git-add) を参照してください。

- 他の方法

  本当に実行したいのが、作業ツリーに存在しなくなったファイルをインデックスから削除することだけである場合（おそらく、作業ツリーがダーティで `git commit -a` を使用できないため）、次のコマンドを使用します：

  ```bash
  git diff --name-only --diff-filter=D -z | xargs -0 git rm --cached
  ```

### SUBMODULES

gitfile を使っているサブモジュール (つまり、Git バージョン 1.7.8 以降でクローンされたもの) だけが作業ツリーから削除されます。サブモジュールのリポジトリはスーパープロジェクトの `.git` ディレクトリ内にあるからです。サブモジュール (あるいはその中に入れ子になっているもの) がまだ `.git` ディレクトリを使っている場合は、`git rm` でサブモジュールの git ディレクトリをスーパープロジェクトの git ディレクトリに移動させ、サブモジュールの歴史を保護します。サブモジュールが存在する場合は、[gitmodules[5]](https://git-scm.com/docs/gitmodules) ファイルの `submodule.<name>` セクションも削除され、そのファイルはステージングされます (`--cached` や `-n` が使われていない場合)。

サブモジュールは、HEAD がインデックスに記録されているものと同じで、追跡されているファイルが変更されておらず、無視されていないファイルがサブモジュールの作業ツリーに存在していないときに、最新の状態であるとみなされます。無視されたファイルは消耗品とみなされ、サブモジュールのワークツリーが削除されるのを止めることはできません。

サブモジュールのローカルチェックアウトを作業ツリーから削除したいだけで、削除をコミットしたくない場合は、代わりに [git-submodule[1]](https://git-scm.com/docs/git-submodule) `deinit` を使います。サブモジュールの削除についての詳細は [gitsubmodules[7]](https://git-scm.com/docs/gitsubmodules) も参照ください。

### EXAMPLES

- `git rm Documentation/\*.txt`

  ドキュメント・ディレクトリとそのサブディレクトリの下にあるすべての `*.txt` ファイルをインデックスから削除します。

  この例では、アスタリスク*がシェルから引用されていることに注意してください。これは、シェルではなく Git に、`Documentation/` ディレクトリ以下のファイルやサブディレクトリのパス名を展開させるためです。

- `git rm -f git-*.sh`

  この例ではシェルがアスタリスクを展開するため（つまり、ファイルを明示的にリストアップしている）、`subdir/git-foo.sh` は削除されません。

### BUGS

スーパープロジェクトの更新で人口の多いサブモジュールが削除されるたびに (削除の前後でコミットを切り替えたときなど)、古いサブモジュールのチェックアウトが古い場所に残ってしまいます。古いディレクトリを削除しても安全なのは gitfile を使っている場合だけで、そうでなければサブモジュールの履歴も削除されてしまいます。この手順は、サブモジュールの再帰的な更新が実装された時点で廃止されます。

### SEE ALSO

[git-add[1]](https://git-scm.com/docs/git-add)

## `bisect`

### NAME

git-bisect — バイナリ検索を使用して、バグを引き起こしたコミットを見つける

### SYNOPSIS

```
git bisect <subcommand> <options>
```

### DESCRIPTION

このコマンドは、さまざまなサブコマンドと、サブコマンドに応じて異なるオプションを取ります：

```
git bisect start [--term-{new,bad}=<term> --term-{old,good}=<term>]
          [--no-checkout] [--first-parent] [<bad> [<good>...]] [--] [<paths>...]
git bisect (bad|new|<term-new>) [<rev>]
git bisect (good|old|<term-old>) [<rev>...]
git bisect terms [--term-good | --term-bad]
git bisect skip [(<rev>|<range>)...]
git bisect reset [<commit>]
git bisect (visualize|view)
git bisect replay <logfile>
git bisect log
git bisect run <cmd>...
git bisect help
```

このコマンドは、バイナリ検索アルゴリズムを使用して、プロジェクトの履歴でバグが発生したコミットを見つけます。最初に、バグが含まれていることがわかっている「bad」コミットと、バグが発生する前にあることがわかっている「good」コミットを伝えることで使用します。次に、`git bisect` は、これら2つのエンドポイント間のコミットを選択し、選択したコミットが「good」か「bad」かを尋ねます。変更を導入した正確なコミットが見つかるまで、範囲を絞り込み続けます。
       
実際、`git bisect` を使用して、プロジェクトのプロパティを変更したコミットを見つけることができます；例：バグを修正したコミット、またはベンチマークのパフォーマンスを向上させたコミット。このより一般的な使用法をサポートするために、「good」と「bad」の代わりに「古い」と「new」という用語を使用することも、独自の用語を選択することもできます。詳細については、以下の「Alternate terms」のセクションを参照してください。

#### Basic bisect commands: start, bad, good

例として、プロジェクトのバージョン `v2.6.13-rc2` で機能することがわかっている機能を壊したコミットを見つけようとしているとします。次のようにバイセクトセッションを開始します：

```bash
$ git bisect start
$ git bisect bad                 # Current version is bad
$ git bisect good v2.6.13-rc2    # v2.6.13-rc2 is known to be good
```

少なくとも1つの悪いコミットと1つの良いコミットを指定すると、`git bisect` はその履歴範囲の中央でコミットを選択し、それをチェックアウトして、次のようなものを出力します：

```
Bisecting: 675 revisions left to test after this (roughly 10 steps)
```

チェックアウトしたバージョンをコンパイルしてテストする必要があります。そのバージョンが正しく機能する場合は、次のように入力します

```bash
$ git bisect good
```

そのバージョンが壊れている場合は、次のように入力します

```bash
$ git bisect bad
```

次に、`git bisect` は次のように応答します

```
Bisecting: 337 revisions left to test after this (roughly 9 steps)
```

プロセスを繰り返し続けます。ツリーをコンパイルしてテストし、それが良いか悪いかに応じて、`git bisect good` または `git bisect bad` を実行して、テストが必要な次のコミットを要求します。

最終的には、検査するリビジョンがなくなるため、コマンドは最初の不正なコミットの説明を出力します。参照 `refs/bisect/bad` は、そのコミットをポイントしたままになります。

#### Bisect reset

二等分セッションの後、二等分状態をクリーンアップして元の HEAD に戻すには、次のコマンドを発行します：

```bash
$ git bisect reset
```

デフォルトでは、これにより、`git bisect` が開始する前にチェックアウトされたコミットにツリーが戻ります。（新しい`git bisect start` も、古い二分状態をクリーンアップするため、これを実行します。）

オプションの引数を使用すると、代わりに別のコミットに戻ることができます：

```bash
$ git bisect reset <commit>
```

たとえば、`git bisect reset bisect/bad` は最初の不良リビジョンをチェックアウトしますが、`git bisect reset HEAD` は現在の二等分コミットのままにし、コミットの切り替えをまったく回避します。

#### Alternate terms

時には、破損をもたらしたコミットを探すのではなく、他の「古い」状態と「new」状態の間に変化をもたらしたコミットを探すこともあります。たとえば、特定の修正を導入したコミットを探している場合があります。あるいは、ソースコードのファイル名が最終的にあなたの会社の命名基準に合わせて変換された最初のコミットを探しているのかもしれません。などなど。

このような場合、「変更前の状態」と「変更後の状態」を表すのに「good」と「bad」という言葉を使うのは非常に混乱を招く恐れがあります。そこで、「good」と「bad」の代わりに、それぞれ「old」と「new」という言葉を使うことができます。(ただし、「good」と「bad」と「old」と「new」を混ぜて使うことはできませんので、ご注意ください）。)

より一般的な使い方としては、あるプロパティを持つ「new」コミットと、そのプロパティを持たない「古い」コミットを `git bisect` に渡します。`git bisect` があるコミットをチェックアウトするたびに、そのコミットがそのプロパティを持っているかどうかをテストします。もしプロパティを持っていれば、そのコミットを「new」とマークし、そうでなければ「old」とマークします。バイセクショ ンが完了すると、`git bisect` はどのコミットがそのプロパティを導入したのかを報告します。

「good」と「bad」の代わりに「old」と「new」を使うには、引数としてコミットを指定せずに `git bisect start` を実行し、その後に以下のコマンドを実行してコミットを追加しなければなりません。

```bash
git bisect old [<rev>]
```

コミットが求められた変更の前であったことを示すため、または

```bash
git bisect new [<rev>...]
```

それが後だったことを示すために。

現在使用されている用語を思い出させるには、

```bash
git bisect terms
```

古い（それぞれ新しい）用語は、`git bisect terms --term-old` または `git bisect terms --term-good` で取得できます。

「bad」/「good」または「new」/「old」の代わりに独自の用語を使用する場合は、（`reset`、`start`、…などの既存の二等分サブコマンドを除く）を開始して任意の名前を選択できます。二等分線を使用して

```bash
git bisect start --term-old <term-old> --term-new <term-new>
```

たとえば、パフォーマンスの低下をもたらすコミットを探している場合は、次を使用できます

```bash
git bisect start --term-old fast --term-new slow
```

または、バグを修正したコミットを探している場合は、

```bash
git bisect start --term-new fixed --term-old broken
```

次に、コミットをマークするために、`git bisect good` と `git bisect bad` の代わりに `git bisect <term-old>` と `git bisect <term-new>` を使用します。

#### Bisect visualize/view

_gitk_ に現在残っている容疑者を確認するには、二等分プロセス中に次のコマンドを発行します（`visualize` の代わりにサブコマンド `view` を使用できます）：

```bash
$ git bisect visualize
```

`DISPLAY` 環境変数が設定されていない場合は、代わりに `git log` が使用されます。`-p` や `--stat` などのコマンドラインオプションを指定することもできます。

```bash
$ git bisect visualize --stat
```

#### Bisect log and bisect replay

リビジョンを良好または不良としてマークした後、次のコマンドを発行して、これまでに行われたことを示します：

```bash
$ git bisect log
```
リビジョンのステータスの指定を間違えた場合は、このコマンドの出力をファイルに保存し、編集して誤ったエントリを削除してから、次のコマンドを発行して修正された状態に戻すことができます：

```bash
$ git bisect reset
$ git bisect replay that-file
```

#### Avoiding testing a commit

バイセクトセッションの途中で、提案されたリビジョンがテストに適していないことがわかっている場合（たとえば、ビルドに失敗し、失敗が追跡しているバグとは何の関係もないことがわかっている場合）、近くのコミットを手動で選択し、代わりにそれをテストできます。

例えば：

```bash
$ git bisect good/bad                   # previous round was good or bad.
Bisecting: 337 revisions left to test after this (roughly 9 steps)
$ git bisect visualize                  # oops, that is uninteresting.
$ git reset --hard HEAD~3               # try 3 revisions before what
                                        # was suggested
```

次に、選択したリビジョンをコンパイルしてテストし、その後、通常の方法でリビジョンを良好または不良としてマークします。

#### Bisect skip

自分で近くのコミットを選択する代わりに、次のコマンドを発行して、Git にそれを実行するように依頼できます：

```bash
$ git bisect skip                 # Current version cannot be tested
```

ただし、探しているコミットに隣接するコミットをスキップすると、Git はそれらのコミットのどれが最初の悪いコミットであったかを正確に知ることができなくなります。

範囲表記を使用して、1つのコミットだけでなく、範囲のコミットをスキップすることもできます。例えば：

```bash
$ git bisect skip v2.5..v2.6
```

これは、`v2.5` 以降、`v2.6` までのコミットをテストしてはならないことを二分法プロセスに伝えます。

範囲の最初のコミットもスキップする場合は、次のコマンドを発行することに注意してください：

```bash
$ git bisect skip v2.5 v2.5..v2.6
```

これは、`v2.5` と `v2.6`（両端を含む）の間のコミットをスキップする必要があることをバイセクトプロセスに通知します。

#### Cutting down bisection by giving more parameters to bisect start

追跡している問題にツリーのどの部分が関係しているかがわかっている場合は、`bisect start` コマンドを発行するときにパスパラメーターを指定することで、試行回数をさらに減らすことができます：

```bash
$ git bisect start -- arch/i386 include/asm-i386
```

事前に複数の適切なコミットがわかっている場合は、bisect startコマンドを発行するときに、不正なコミットの直後にすべての適切なコミットを指定することで、2等分スペースを絞り込むことができます：

```bash
$ git bisect start v2.6.20-rc6 v2.6.20-rc4 v2.6.20-rc1 --
                   # v2.6.20-rc6 is bad
                   # v2.6.20-rc4 and v2.6.20-rc1 are good
```

#### Bisect run

現在のソースコードが良いか悪いかを判断できるスクリプトがある場合は、次のコマンドを発行して二分することができます：

```bash
$ git bisect run my_script arguments
```

スクリプト（上記の例では `my_script`）は、現在のソースコードが良い/古い場合はコード0で終了し、現在のソースコードが悪い/新しい場合は125を除く1〜127（含む）のコードで終了する必要があることに注意してください。

その他の終了コードは、二分法プロセスを中止します。 exit(-1) を介して終了するプログラムは、$? = 255 が残ることに注意してください（exit(3) のマニュアルページを参照）、値は `＆ 0377` で切り刻まれます。

特別な終了コード 125 は、現在のソースコードをテストできない場合に使用します。このコードでスクリプトが終了すると、現在のリビジョンはスキップされます (上記の `git bisect skip` を参照)。125 はこの目的のために使う最も妥当な値として選ばれました。なぜなら、126 と 127 は POSIX シェルで特定のエラー状態を知らせるために使われているからです (127 は「コマンドが見つからない」、126 は「コマンドは見つかったが実行できない」という意味ですが、`bisect run` にとってはスクリプトの通常のエラーなので、これらの詳細は重要ではありません)。

バイセクトセッション中に、一時的な修正（ヘッダファイルの `s/#define DEBUG 0/#define DEBUG 1/` や、「このコミットを持たないリビジョンでは、このバイセクトが関心を持たない別の問題を回避するために、このパッチを適用する必要がある」など）をテスト中のリビジョンに適用したいことがよくあるでしょう。

このような状況に対処するために、内部の `git bisect` がテストする次のリビジョンを見つけた後、スクリプトはコンパイル前にパッチを適用し、実際のテストを実行し、その後そのリビジョン (おそらく必要なパッチを適用したもの) がテストに合格したかどうかを判断し、ツリーを元の状態に巻き戻すことができます。最後に、スクリプトは実際のテストの結果を表示して終了し、`git bisect run` コマンドループが bisect セッションの最終的な結果を決定します。

### OPTIONS

- `--no-checkout`

  バイセクションプロセスの各反復において、新しい作業ツリーをチェックアウトしません。代わりに、`BISECT_HEAD` という特別な参照を更新して、テストすべきコミットを指すようにします。

  このオプションは、各ステップで実行するテストがチェックアウトしたツリーを必要としない場合に便利です。

  リポジトリが裸の場合、`--no-checkout` が想定されます。

- `--first-parent`

  マージコミットを見たときに、最初の親コミットだけをフォローします。

  ブランチのマージによって発生したリグレッションを検出する際に、マージコミットがバグの発生源として認識され、その先祖は無視されます。

  このオプションは、マージされたブランチに壊れたコミットやビルドできないコミットが含まれていたが、マージ自体には問題がなかった場合に、誤検出を避けるために特に有効です。

### EXAMPLES

- v1.2 と HEAD の間で壊れたビルドを自動的に二分します：

  ```bash
  $ git bisect start HEAD v1.2 --      # HEAD is bad, v1.2 is good
  $ git bisect run make                # "make" builds the app
  $ git bisect reset                   # quit the bisect session
  ```

- origin と HEAD の間のテストの失敗を自動的に二分します：

  ```bash
  $ git bisect start HEAD origin --    # HEAD is bad, origin is good
  $ git bisect run make test           # "make test" builds and tests
  $ git bisect reset                   # quit the bisect session
  ```

- 壊れたテストケースを自動的に二分します：

  ```bash
  $ cat ~/test.sh
  #!/bin/sh
  make || exit 125                     # this skips broken builds
  ~/check_test_case.sh                 # does the test case pass?
  $ git bisect start HEAD HEAD~10 --   # culprit is among the last 10
  $ git bisect run ~/test.sh
  $ git bisect reset                   # quit the bisect session
  ```

  ここでは、`test.sh` というカスタムスクリプトを使用します。このスクリプトでは、`make` が失敗した場合、現在のコミットをスキップします。`check_test_case.sh` は、テストケースが成功した場合は `exit 0` を、そうでない場合は `exit 1` で終了します。

  bisect、make、test の各プロセスとスクリプトの相互作用を防ぐために、`test.sh` と `check_test_case.sh` の両方がリポジトリの外にある方が安全です。

- 一時的な変更で自動的に二分します（ホットフィックス）：

  ```bash
  $ cat ~/test.sh
  #!/bin/sh
  
  # tweak the working tree by merging the hot-fix branch
  # and then attempt a build
  if      git merge --no-commit --no-ff hot-fix &&
          make
  then
          # run project specific test and report its status
          ~/check_test_case.sh
          status=$?
  else
          # tell the caller this is untestable
          status=125
  fi
  
  # undo the tweak to allow clean flipping to the next commit
  git reset --hard
  
  # return control
  exit $status
  ```

  ここれにより、各テスト実行の前にホットフィックスブランチからの変更が適用されます。ビルドまたはテスト環境が変更されたために、古いリビジョンで新しいリビジョンにすでに修正が必要な場合があります。 （ホットフィックスブランチが、二等分しているすべてのリビジョンに含まれているコミットに基づいていることを確認して、マージがあまり引き込まれないようにするか、`git merge` の代わりに `git cherry-pick` を使用してください。）

- 壊れたテストケースを自動的に二分します：

  ```bash
  $ git bisect start HEAD HEAD~10 --   # culprit is among the last 10
  $ git bisect run sh -c "make || exit 125; ~/check_test_case.sh"
  $ git bisect reset                   # quit the bisect session
  ```

  これは、テストを1行で記述した場合、実行スクリプトなしで実行できることを示しています。

- 破損したリポジトリでオブジェクトグラフの適切な領域を見つけます

  ```bash
  $ git bisect start HEAD <known-good-commit> [ <boundary-commit> ... ] --no-checkout
  $ git bisect run sh -c '
          GOOD=$(git for-each-ref "--format=%(objectname)" refs/bisect/good-*) &&
          git rev-list --objects BISECT_HEAD --not $GOOD >tmp.$$ &&
          git pack-objects --stdout >/dev/null <tmp.$$
          rc=$?
          rm -f tmp.$$
          test $rc = 0'
  
  $ git bisect reset                   # quit the bisect session
  ```

  この場合、`git bisect run` が終了すると、bisect/bad は、到達可能なグラフが _git pack objects_ に必要な意味で完全にトラバース可能な少なくとも1つの親を持つコミットを参照します。

- コードのリグレッションではなく、修正を探します

  ```bash
  $ git bisect start
  $ git bisect new HEAD    # current commit is marked as new
  $ git bisect old HEAD~10 # the tenth commit from now is marked as old
  ````

  または：

```bash
$ git bisect start --term-old broken --term-new fixed
$ git bisect fixed
$ git bisect broken HEAD~10
```

#### Getting help

`git bisect` を使用して短い使用法の説明を取得し、`git bisect help` または `gitcbisect -h` を使用して長い使用法の説明を取得します。

### SEE ALSO

[Fighting regressions with git bisect](https://git-scm.com/docs/git-bisect-lk2009), [git-blame[1]](https://git-scm.com/docs/git-blame)

## `diff`

### NAME

git-diff — コミット、コミットと作業ツリーなどの間の変更を表示する

### SYNOPSIS

```bash
git diff [<options>] [<commit>] [--] [<path>...]
git diff [<options>] --cached [--merge-base] [<commit>] [--] [<path>...]
git diff [<options>] [--merge-base] <commit> [<commit>...] <commit> [--] [<path>...]
git diff [<options>] <commit>...<commit> [--] [<path>...]
git diff [<options>] <blob> <blob>
git diff [<options>] --no-index [--] <path> <path>
```

### DESCRIPTION

作業ツリーとインデックスまたはツリー間の変更、インデックスとツリー間の変更、2つのツリー間の変更、マージによる変更、2つのブロブオブジェクト間の変更、またはディスク上の2つのファイル間の変更を表示します。

- `git diff [<options>] [--] [<path>...]`

  このフォームは、あなたが行った変更をインデックス (次のコミットのためのステージングエリア) に対して相対的に表示します。言い換えれば、違いは Git にインデックスにさらに追加するように指示できるものですが、まだ追加していません。これらの変更をステージングするには [git-add[1]](https://git-scm.com/docs/git-add) を使います。

- `git diff [<options>] --no-index [--] <path> <path>`

  この形式は、ファイルシステム上の与えられた二つのパスを比較するものです。Git が管理している作業ツリーの中でこのコマンドを実行していて、少なくともどちらかのパスが作業ツリーの外を指している場合や、Git が管理している作業ツリーの外でこのコマンドを実行している場合には `--no-index` オプションを省略することができます。この形式は `--exit-code` を意味します。

- `git diff [<options>] --cached [--merge-base] [<commit>] [--] [<path>...]`

  このフォームは、次のコミットのためにステージした変更点を、指定した `<commit>` との相対的な関係で表示します。一般的には、最新のコミットとの比較が必要となるため、`<commit>` を指定しない場合は、デフォルトで HEAD となります。HEAD が存在せず(例：生まれていないブランチ)、`<commit>` が与えられていない場合は、ステージされたすべての変更を表示します。`--staged` は `--cached` の同義語です。

  `git diff --cached --merge-base A` は `git diff --cached $(git merge-base A HEAD)` と同じです。

- `git diff [<options>] <commit> [--] [<path>...]`

  この形式は、作業ツリーにある変更点のうち、指定した `<commit>` に対する相対的なものを表示します。HEAD を使って最新のコミットと比較したり、ブランチ名を使って別のブランチの先端と比較したりすることができます。

  `--merge-base` を指定すると、`<commit>` を使う代わりに `<commit>` と HEAD のマージベースを使います。 `git diff --merge-base A` は `git diff $(git merge-base A HEAD)` と同じです。

- `git diff [<options>] [--merge-base] <commit> <commit> [--] [<path>...]`

  任意の二つの `<commit>` 間の変更点を表示します。

  `git diff --merge-base A B` は `git diff $(git merge-base A B) B` と同じです。

- `git diff [<options>] <commit> <commit>... <commit> [--] [<path>...]`

  マージコミットの結果を見るための形式です。最初に表示される `<commit>` はマージそのものでなければならず、残りの2つ以上のコミットはその親でなければなりません。目的のリビジョン群を生成する便利な方法は、`^@` という接尾辞を使うことです。たとえば、`master` がマージコミットの名前であった場合、`git diff master master^@` は `git show master` と同じ複合的な diff を出力します。

- `git diff [<options>] <commit>..<commit> [--] [<path>...]`

  これは、任意の2つの `<commit>` 間の変更点を表示する以前の形式（`..` を除いたもの）と同義です。片方の `<commit>` が省略された場合は、代わりに HEAD を使ったのと同じ効果が得られます。

- `git diff [<options>] <commit>...<commit> [--] [<path>...]`

  この形式では、両方の `<commit>` の共通の祖先を起点として、そのブランチを含む2番目の `<commit>` までの変更点を表示します。`git diff A...B` は `git diff $(git merge-base A B) B` と同じです。 `<commit>` のいずれかを省略すると、代わりに HEAD を使ったのと同じ効果が得られます。

念のために言っておくと、上の説明に出てくる `<commit>` は `--merge-base` の場合と最後の2つの `..` 表記を使った形式を除いて、どの `<tree>` でも構わないということです。

`<commit>` の綴りのより完全なリストは、[gitrevisions[7]](https://git-scm.com/docs/gitrevisions) の「SPECIFYING REVISIONS」セクションを参照してください。しかし、「diff」は2つの終点を比較するものであって範囲を比較するものではありません。範囲を表す表記（`<commit>...<commit>` や `<commit>...<commit>`）は、[gitrevisions[7]](https://git-scm.com/docs/gitrevisions) の「SPECIFYING RANGES」セクションで定義されているような範囲を意味するものではありません。

- `git diff [<options>] <blob> <blob>`

  このフォームは、2つのブロブオブジェクトの生のコンテンツの違いを見るためのものです。

### OPTIONS

- `-p`, `-u`, `--patch`

  パッチを生成します（パッチの生成に関するセクションを参照）。これがデフォルトです。

- `-s`, `--no-patch`

  差分出力を抑制します。デフォルトでパッチを表示する `git show` のようなコマンド、または `--patch` の効果をキャンセルする場合に便利です。

- `-U<n>`, `--unified=<n>`

  通常の3行ではなく、`<n>` 行のコンテキストで差分を生成します。`--patch` を意味します。

- `--output=<file>`

  stdout ではなく特定のファイルに出力します。

- `--output-indicator-new=<char>`, `--output-indicator-old=<char>`, `--output-indicator-context=<char>`

  生成されたパッチの新しい行、古い行、またはコンテキスト行を示すために使用される文字を指定します。通常、それらはそれぞれ `+`、`-`、および `''` です。

- `--raw`

  生の形式で差分を生成します。

- `--patch-with-raw`

  `-p --raw` の同義語。

- `--indent-heuristic`

  差分ハンクの境界をシフトするヒューリスティックを有効にして、パッチを読みやすくします。これがデフォルトです。

- `--no-indent-heuristic`

  インデントヒューリスティックを無効にします。

- `--minimal`

  可能な限り最小の差分が生成されるように、余分な時間を費やしてください。

- `--patience`

  「patiencediff」アルゴリズムを使用して diff を生成します。

- `--histogram`

  「histogram diff」アルゴリズムを使用して diff を生成します。

- `--anchored=<text>`

  「anchored diff」アルゴリズムを使用してdiffを生成します。

  このオプションは複数回指定できます。

  行がソースと宛先の両方に存在し、1回だけ存在し、このテキストで始まる場合、このアルゴリズムは、その行が出力に削除または追加として表示されないようにします。内部で「patience diff」アルゴリズムを使用します。

- `--diff-algorithm={patience|minimal|histogram|myers}`

  差分アルゴリズムを選択します。バリアントは次のとおりです。

  - `default`, `myers`

    基本的な貪欲な差分アルゴリズム。現在、これがデフォルトです。

  - `minimal`

    可能な限り最小の差分が生成されるように、余分な時間を費やしてください。

  - `patience`

    パッチを生成するときは、「patience diff」アルゴリズムを使用してください。

  - `histogram`

    このアルゴリズムは、忍耐アルゴリズムを拡張して、「発生率の低い共通要素をサポート」します。

  たとえば、`diff.algorithm` 変数をデフォルト以外の値に構成し、デフォルト値を使用する場合は、`-diff-algorithm=default` オプションを使用する必要があります。

- `--stat[=<width>[,<name-width>[,<count>]]]`

  `diffstat` を生成します。デフォルトでは、ファイル名の部分に必要なだけのスペースが使われ、残りはグラフの部分に使われます。最大幅のデフォルトは端末の幅、または端末に接続されていない場合は80列で、`<width>` でオーバーライドできます。ファイル名部分の幅は、コンマの後に別の幅 `<name-width>` を与えることで制限できます。グラフ部分の幅を制限するには `--stat-graph-width=<width>` (stat グラフを生成するすべてのコマンドに影響します)、または `diff.statGraphWidth=<width>` (`git format-patch` には影響しません)と設定します。3番目のパラメータ `<count>` を指定すると、出力を最初の `<count>` 行に限定し、それ以上の行がある場合は `...` を続けます。

  これらのパラメータは `--stat-width=<width>`, `--stat-name-width=<name-width>`, `--stat-count=<count>` で個別に設定することもできます。

- `--compact-summary`

  ファイルの作成または削除（「new」または「gone」、オプションでシンボリックリンクの場合は「+l」）およびモード変更（追加または削除の場合は「+x」または「-x」）などの拡張ヘッダー情報の要約を出力します。 diffstat の実行可能ビット）。情報はファイル名部分とグラフ部分の間に置かれます。`--stat` を意味します。

- `--numstat`

  `--stat` に似ていますが、マシンフレンドリーにするために、追加および削除された行数を10進表記とパス名で省略形なしで表示します。バイナリファイルの場合、`0 0` と言う代わりに2つの `-` を出力します。

- `--shortstat`

  変更されたファイルの総数と、追加および削除された行の数を含む `--stat` 形式の最後の行のみを出力します。

- `-X[<param1,param2,...>]`, `--dirstat[=<param1,param2,...>]`

  各サブディレクトリの相対的な変更量の分布を出力します。`--dirstat` の動作は、パラメーターのコンマ区切りリストを渡すことでカスタマイズできます。デフォルトは、`diff.dirstat` 構成変数によって制御されます（[git-config[1]](https://git-scm.com/docs/git-config) を参照）。次のパラメータを使用できます：

  - `changes`

    ソースから削除された、または宛先に追加された行をカウントして、dirstat 番号を計算します。これは、ファイル内の純粋なコード移動の量を無視します。つまり、ファイル内の行の再配置は、他の変更ほどカウントされません。これは、パラメーターが指定されていない場合のデフォルトの動作です。

  - `lines`

    通常の行ベースのdiff分析を実行し、削除/追加された行数を合計して、dirstat番号を計算します。（バイナリファイルの場合、バイナリファイルには行の自然な概念がないため、代わりに64バイトのチャンクをカウントします）。これは、 `changes` 動作よりもコストのかかる `--dirstat` 動作ですが、ファイル内の再配置された行を他の変更と同じようにカウントします。結果の出力は、他の `-*stat` オプションから得られるものと一致しています。

  - `files`

    変更されたファイルの数を数えて、dirstat の数を計算します。変更された各ファイルは、dirstat 分析で等しくカウントされます。これは、ファイルの内容をまったく調べる必要がないため、計算上最も安価な `--dirstat` の動作です。

  - `cumulative`

    親ディレクトリの子ディレクトリの変更もカウントします。`cumulative` を使用すると、報告されるパーセンテージの合計が100％を超えることがありますのでご注意ください。デフォルト（非累積）の動作は、`noncumulative` パラメータで指定できます。

  - `<limit>`

    整数パラメーターは、カットオフパーセント（デフォルトでは 3％）を指定します。変更のこの割合より少ない貢献をしているディレクトリは、出力に表示されません。

  例：以下は、変更されたファイルの総数の10％未満のディレクトリを無視し、親ディレクトリに子ディレクトリの数を累積しながら、変更されたファイルをカウントします：`--dirstat=files,10,cumulative`。

- `--cumulative`

  `--dirstat=cumulative` の同義語

- `--dirstat-by-file[=<param1,param2>...]`

  `--dirstat=files,param1,param2…` の同義語

- `--summary`

  作成、名前変更、モード変更などの拡張ヘッダー情報の要約を出力します。

- `--patch-with-stat`

  `-p --stat` の同義語。

- `-z`

  `--raw`、`--numstat`、`--name-only`、または `--name-status` が指定されている場合は、パス名を変更せず、出力フィールドターミネータとして NUL を使用してください。

  このオプションがないと、構成変数 `core.quotePath` で説明されているように、「unusual」文字を含むパス名が引用符で囲まれます（[git-config [1]](https://git-scm.com/docs/git-config) を参照）。

- `--name-only`

  変更されたファイルの名前のみを表示します。多くの場合、ファイル名はUTF-8でエンコードされます。詳細については、[git-log[1]](https://git-scm.com/docs/git-log) のマニュアルページのエンコーディングに関する説明を参照してください。

- `--name-status`

  変更されたファイルの名前とステータスのみを表示します。ステータス文字の意味については、`--diff-filter` オプションの説明を参照してください。`--name-only` と同じように、ファイル名のみが UTF-8 でエンコードされることがよくあります。

- `--submodule[=<format>]`

  サブモジュールの違いをどのように表示するかを指定します。`--submodule=short` を指定すると、_short_ 形式が使用されます。この形式は、範囲の最初と最後にコミットの名前を表示するだけです。`--submodule` または `--submodule=log` を指定すると、_log_ 形式が使用されます。この形式では、[git-submodule[1]](https://git-scm.com/docs/git-submodule) の `summary` と同様に範囲内のコミットが一覧表示されます。`--submodule=diff` を指定すると、_diff_ 形式が使用されます。この形式は、コミット範囲間のサブモジュールの内容の変更のインライン差分を示します。config オプションが設定されていない場合、デフォルトは `diff.submodule` または _short_ 形式です。

- `--color[=<when>]`

  色付きの差分を表示します。`--color`（つまり、`=<when>` なし）は `--color=always` と同じです。`<when>` は、`always`、`never`、または `auto` のいずれかになります。これは、`color.ui` および `color.diff` の構成設定によって変更できます。

- `--no-color`

  色付きの差分をオフにします。これは、構成設定を上書きするために使用できます。`--color=never` と同じです。

- `--color-moved[=<mode>]`

  移動したコード行の色は異なります。これは、`diff.colorMoved` 構成設定によって変更できます。`<mode>` は、オプションが指定されていない場合はデフォルトで `no` になり、モードが指定されていない場合は `zebra` になります。モードは次のいずれかである必要があります：

  - `no`

    移動した線は強調表示されません。

  - `default`

    `zebra` の同義語です。これは、将来、より賢明なモードに変更される可能性があります。

  - `plain`

    ある場所で追加され、別の場所で削除された行は、`color.diff.newMoved` で色付けされます。同様に、`color.diff.oldMoved` は、`diff` の別の場所に追加された削除された行に使用されます。このモードは移動された行をピックアップしますが、コードのブロックが順列なしで移動されたかどうかを判断することはレビューではあまり役に立ちません。

  - `blocks`

    少なくとも20文字の英数字の移動テキストのブロックが貪欲に検出されます。検出されたブロックは、`color.diff.{old、new}Moved` 色のいずれかを使用してペイントされます。隣接するブロックを区別することはできません。

  - `zebra`

    移動されたテキストのブロックは、`blocks` モードの場合と同様に検出されます。ブロックは、`color.diff.{old、new}Moved` 色または 1color.diff.{old、new}MovedAlternative` のいずれかを使用してペイントされます。2つの色の間の変化は、新しいブロックが検出されたことを示します。

  - `dimmed-zebra`

    `zebra` に似ていますが、移動されたコードの重要でない部分の追加の調光が実行されます。隣接する2つのブロックの境界線は興味深いと見なされ、残りは興味深いものではありません。`dimmed_zebra` は非推奨の同義語です。

- `--no-color-moved`

  移動検出をオフにします。これは、構成設定を上書きするために使用できます。`--color-moved=no` と同じです。

- `--color-moved-ws=<modes>`

  これは、`--color-moved` の移動検出を実行するときに空白を無視する方法を構成します。これは、`diff.colorMovedWS` 構成設定によって設定できます。これらのモードは、コンマ区切りのリストとして指定できます：

  - `no`

    移動検出を実行するときは、空白を無視しないでください。

  - `ignore-space-at-eol`

    EOL で空白の変更を無視します。

  - `ignore-space-change`

    空白の量の変更は無視してください。これは、行末の空白を無視し、1つ以上の空白文字の他のすべてのシーケンスを同等と見なします。

  - `ignore-all-space`

    線を比較するときは空白を無視します。これにより、一方の行に空白があり、もう一方の行に空白がない場合でも、違いは無視されます。

  - `allow-indentation-change`

    最初に移動検出で空白を無視し、空白の変更が行ごとに同じである場合にのみ、移動されたコードブロックをブロックにグループ化します。これは他のモードと互換性がありません。

- `--no-color-moved-ws`

  移動検出を実行するときは、空白を無視しないでください。これは、構成設定を上書きするために使用できます。`--color-moved-ws=no` と同じです。

- `--word-diff[=<mode>]`

  `<mode>` を使用して変更された単語を区切ることにより、単語の差分を表示します。デフォルトでは、単語は空白で区切られます。以下の `--word-diff-regex` を参照してください。`<mode>` のデフォルトは _plain_ であり、次のいずれかである必要があります。

  - `color`

    色のみを使用して変更された単語を強調表示します。`--color` を意味します。

  - `plain`

    単語を `[-removed-]` および `{+ added +}` として表示します。区切り文字が入力に表示されている場合、区切り文字をエスケープしようとしないため、出力があいまいになる可能性があります。

  - `porcelain`

    スクリプトの使用を目的とした特別な行ベースの形式を使用します。追加/削除/変更されていないランは、通常の統一された差分形式で印刷され、行の先頭が `+`/`-` / ` ` 文字で始まり、行の終わりまで続きます。入力の改行は、それ自体の行のチルダ〜で表されます。

  - `none`

    単語の差分を再度無効にします。

  最初のモードの名前にもかかわらず、有効になっている場合、すべてのモードで変更された部分を強調するために色が使用されることに注意してください。

- `--word-diff-regex=<regex>`

  非空白の実行を単語と見なす代わりに、`<regex>` を使用して単語が何であるかを決定します。また、すでに有効になっていない限り、`--word-diff` を意味します。

  `<regex>` の重複しない一致はすべて、単語と見なされます。これらの一致の間のすべては空白と見なされ、違いを見つけるために無視されます（！）。正規表現に `|[^[:space:]]` を追加して、空白以外のすべての文字と一致することを確認することをお勧めします。改行を含む一致は、改行でサイレントに切り捨てられます（！）。

  たとえば、`--word-diff-regex=.` は各文字を単語として扱い、それに応じて、文字ごとの違いを示します。

  正規表現は、diffドライバーまたは構成オプションを介して設定することもできます。[gitattributes[5]](https://git-scm.com/docs/gitattributes) または [git-config[1]](https://git-scm.com/docs/git-config) を参照してください。これを指定すると、diffドライバーまたは構成設定が明示的にオーバーライドされます。差分ドライバーは構成設定を上書きします。

- `--color-words[=<regex>]`

  `--word-diff=color` に加えて (regex が指定されていた場合) `--word-diff-regex=<regex>` に相当します。

- `--no-renames`

  構成ファイルにデフォルトで指定されている場合でも、名前変更の検出をオフにします。

- `--[no-]rename-empty`

  名前変更ソースとして空のブロブを使用するかどうか。

- `--check`

  変更によって競合マーカーまたは空白エラーが発生した場合に警告します。空白エラーと見なされるものは、`core.whitespace` 構成によって制御されます。デフォルトでは、末尾の空白（空白のみで構成される行を含む）と、行の最初のインデント内で直後にタブ文字が続くスペース文字は、空白エラーと見なされます。問題が見つかった場合は、ゼロ以外のステータスで終了します。`--exit-code` とは互換性がありません。

- `--ws-error-highlight=<kind>`

  コンテキスト内の空白エラー、差分の古い行または新しい行を強調表示します。複数の値はコンマで区切られ、`none` は前の値をリセットし、デフォルトはリストを `new` にリセットし、`all` は `old`、`new`、`context` の省略形です。このオプションが指定されておらず、構成変数 `diff.wsErrorHighlight` が設定されていない場合、新しい行の空白エラーのみが強調表示されます。空白エラーは `color.diff.whitespace` で色分けされています。

- `--full-index`

  パッチ形式の出力を生成するときは、最初の一握りの文字の代わりに、「index」行にイメージ前およびイメージ後の完全なブロブオブジェクト名を表示します。

- `--binary`

  `--full-index` に加えて、`git-apply` で適用できるバイナリ差分を出力します。`--patch` を意味します。

- `--abbrev[=<n>]`

  完全な40バイトの16進オブジェクト名を `diff-raw` 形式の出力と `diff-tree` ヘッダー行に表示する代わりに、オブジェクトを一意に参照する、少なくとも `<n>` 16進数の長さの最短のプレフィックスを表示します。`diff-patch` 出力形式では、`--full-index` が優先されます。つまり、`--full-index` が指定されている場合、`--abbrev` に関係なく完全なblob名が表示されます。デフォルト以外の桁数は、`--abbrev=<n>` で指定できます。

- `-B[<n>][/<m>]`, `--break-rewrites[=[<n>][/<m>]]`

  完全な書き換えの変更を削除と作成のペアに分割します。これには2つの目的があります：

  これは、ファイルの完全な書き換えに相当する変更が、コンテキストとしてテキストで一致する非常に少数の行と混合された一連の削除と挿入としてではなく、古いものすべての単一の削除とそれに続くすべての新しいものを1回挿入し、数値 `m` は `-B` オプションのこの側面を制御します（デフォルトは60％）。`-B/70％` は、Git がそれを完全な書き換えと見なすために、元の30％未満が結果に残る必要があることを指定します（つまり、結果のパッチは、コンテキスト行と混合された一連の削除と挿入になります）。

  `-M` とともに使用すると、完全に書き換えられたファイルも名前変更のソースと見なされ（通常、`-M` は、消えたファイルのみを名前変更のソースと見なします）、番号 `n` は `-B` オプションのこの側面を制御します。（デフォルトは50％）。 `-B20％` は、ファイルのサイズの20％以上と比較して、追加および削除を伴う変更が、別のファイルへの名前変更の可能なソースとして取得される資格があることを指定します。

- `-M[<n>]`, `--find-renames[=<n>]`

  名前の変更を検出します。`n` が指定されている場合、それは類似性インデックスのしきい値です（つまり、ファイルのサイズと比較した追加/削除の量）。たとえば、`-M90％` は、ファイルの90％以上が変更されていない場合、Git が削除と追加のペアを名前変更と見なす必要があることを意味します。`％` 記号がない場合、数値は小数として読み取られ、その前に小数点が付きます。つまり、`-M5` は 0.5 になるため、`-M50％` と同じになります。同様に、`-M05` は `-M5％` と同じです。検出を正確な名前変更に制限するには、`-M100％` を使用します。デフォルトの類似性インデックスは50％です。

- `-C[<n>]`, `--find-copies[=<n>]`

  コピーと名前の変更を検出します。`--find-copies-harder` も参照してください。`n` を指定すると、`-M<n>` と同じ意味になります。

- `--find-copies-harder`

  パフォーマンス上の理由から、デフォルトでは、`-C` オプションは、コピーの元のファイルが同じチェンジセットで変更された場合にのみコピーを検索します。このフラグにより、コマンドは変更されていないファイルをコピー元の候補として検査します。これは大規模なプロジェクトでは非常にコストのかかる操作であるため、注意して使用してください。複数の `-C` オプションを指定しても、同じ効果があります。

- `-D`, `--irreversible-delete`

  削除するプレイメージを省略します。つまり、ヘッダーのみを出力し、プレイメージと `/dev/null` の差分は出力しません。結果のパッチは、`patch` または `git apply` で適用されることを意図したものではありません。これは、変更後にテキストを確認することに集中したい人のためだけのものです。さらに、出力には明らかに、そのようなパッチを手動でも逆に適用するのに十分な情報が不足しているため、オプションの名前が付けられています。

  `-B` と併用する場合は、削除/作成ペアの削除部分のプリイメージも省略してください。

- `-l<num>`

  `-M` および `-C` オプションには、名前変更/コピーのサブセットを安価に検出できるいくつかの準備手順が含まれ、その後に、残りのすべてのペアになっていない宛先をすべての関連ソースと比較する徹底的なフォールバック部分が続きます。 （名前変更の場合、残りのペアになっていないソースのみが関係します。コピーの場合、すべての元のソースが関係します。）N個のソースと宛先の場合、この徹底的なチェックは O(N^2) です。このオプションは、関係するソース/宛先ファイルの数が指定された数を超えた場合に、名前変更/コピー検出の完全な部分が実行されないようにします。デフォルトは `diff.renameLimit` です。値0は無制限として扱われることに注意してください。

- `--diff-filter=[(A|C|D|M|R|T|U|X|B)...[*]]`

  追加された（`A`）、コピーされた（`C`）、削除された（`D`）、変更された（`M`）、名前が変更された（`R`）、タイプ（つまり、通常のファイル、シンボリックリンク、サブモジュールなど）が変更されたファイルのみを選択します（`T`）、マージされていない（`U`）、不明である（`X`）、またはペアリングが壊れている（`B`）。フィルタ文字の任意の組み合わせ（なしを含む）を使用できます。`*`（All-or-none）が組み合わせに追加されると、比較で他の基準に一致するファイルがある場合、すべてのパスが選択されます。他の基準に一致するファイルがない場合、何も選択されません。

  また、これらの大文字は小文字で除外することができます。例えば。`--diff-filter=ad` は、追加および削除されたパスを除外します。

  すべての差分がすべてのタイプを特徴とするわけではないことに注意してください。たとえば、インデックスから作業ツリーへの差分にエントリを追加することはできません（差分に含まれるパスのセットは、インデックスの内容によって制限されるため）。同様に、これらのタイプの検出が無効になっている場合、コピーおよび名前変更されたエントリは表示されません。

- `-S<string>`

  ファイル内の指定された文字列の出現回数（つまり、追加/削除）を変更する違いを探します。スクリプト作成者が使用することを目的としています。

  コードの正確なブロック（構造体など）を探していて、そのブロックが最初に作成されてからの履歴を知りたい場合に便利です。この機能を繰り返し使用して、プリイメージ内の興味深いブロックをにフィードバックします。`-S`、そしてブロックの最初のバージョンを取得するまで続けます。

  バイナリファイルも検索されます。

- `-G<regex>`

  パッチテキストに `<regex>` に一致する追加/削除された行が含まれている違いを探します。

  `-S<regex> --pickaxe-regex` と `-G<regex>` の違いを説明するために、同じファイル内で次のdiffを使用してコミットすることを検討してください。

  ```
  +    return frotz(nitfol, two->ptr, 1, 0);
  ...
  -    hit = frotz(nitfol, mf2.ptr, 1, 0);
  ```

  `git log -G "frotz\nitfol"` はこのコミットを表示しますが、`git log -S "frotz\nitfol" --pickaxe-regex` は表示しません（その文字列の出現回数が変更されていないため）。

  `--text` が提供されていない限り、textconvフィルターのないバイナリファイルのパッチは無視されます。


  詳細については、[gitdiffcore[7]](https://git-scm.com/docs/gitdiffcore) の _pickaxe_ エントリを参照してください。

- `--find-object=<object-id>`

  指定されたオブジェクトの出現回数を変化させる差分を検索します。`-S` と似ていますが、引数が異なるだけで、特定の文字列ではなく、特定のオブジェクト ID を検索します。

  オブジェクトにはブロブやサブモジュールのコミットを指定できます。これは、`git-log` の `-t` オプションがツリーも検索することを意味します。

- `--pickaxe-all`

  `-S` または `-G` が変更を検出したら、`<string>` の変更を含むファイルだけでなく、その変更セット内のすべての変更を表示します。

- `--pickaxe-regex`

  `-S` に指定された `<string>` を、一致する拡張 POSIX 正規表現として扱います。

- `-O<orderfile>`

  ファイルが出力に表示される順序を制御します。これは、`diff.orderFile` 構成変数をオーバーライドします（[git-config[1]](https://git-scm.com/docs/git-config) を参照）。`diff.orderFile` をキャンセルするには、`-O/dev/null` を使用します。

  出力順序は、`<orderfile>` 内のグロブパターンの順序によって決定されます。最初のパターンに一致するパス名を持つすべてのファイルが最初に出力され、2番目のパターンに一致する（ただし最初のパターンには一致しない）パス名を持つすべてのファイルが次に出力されます。パス名がどのパターンとも一致しないすべてのファイルは、ファイルの最後に暗黙のすべて一致パターンがあるかのように、最後に出力されます。複数のパス名のランクが同じである場合（同じパターンに一致するが、以前のパターンには一致しない）、相互の出力順序は通常の順序です。

  `<orderfile>` は次のように解析されます：

  - 空白行は無視されるため、読みやすくするための区切り文字として使用できます。
  - ハッシュ（「`＃`」）で始まる行は無視されるため、コメントに使用できます。パターンがハッシュで始まる場合は、パターンの先頭に円記号（「`\`」）を追加します。
  - 他の各行には、単一のパターンが含まれています。

  パターンは、`FNM_PATHNAME` フラグなしで fnmatch(3) に使用されるパターンと同じ構文とセマンティクスを持ちますが、最終的なパス名コンポーネントをいくつでも削除するとパターンと一致する場合、パス名もパターンと一致する点が異なります。たとえば、パターン「`foo*bar`」は、「`fooasdfbar`」および「`foo/bar/baz/asdf`」と一致しますが、「`foobarx`」とは一致しません。

- `--skip-to=<file>`, `--rotate-to=<file>`

  名前付き `<file>` の前のファイルを出力から破棄するか（つまり、_skip to_）、出力の最後に移動します（つまり、_rotate to_）。これらは主に `git difftool` コマンドを使用するために考案されたものであり、それ以外の場合はあまり役に立たない可能性があります。

- `-R`

  2つの入力を交換します。つまり、インデックスまたはディスク上のファイルとツリーの内容の違いを示します。

- `--relative[=<path>]`, `--no-relative`

  プロジェクトのサブディレクトリから実行する場合、このオプションを使用して、ディレクトリ外の変更を除外し、それに関連するパス名を表示するように指示できます。サブディレクトリ（ベアリポジトリなど）にいない場合は、引数として `<path>` を指定することで、出力を作成するサブディレクトリに名前を付けることができます。`--no-relative` を使用して、`diff.relative` 構成オプションと以前の `--relative` の両方を無効にすることができます。

- `-a`, `--text`

  すべてのファイルをテキストとして扱います。

- `--ignore-cr-at-eol`

  比較を行うときは、行末のキャリッジリターンを無視します。

- `--ignore-space-at-eol`

  EOL で空白の変更を無視します。

- `-b`, `--ignore-space-change`

  空白の量の変更は無視してください。これは、行末の空白を無視し、1つ以上の空白文字の他のすべてのシーケンスを同等と見なします。

- `-w`, `--ignore-all-space`

  線を比較するときは空白を無視します。これにより、一方の行に空白があり、もう一方の行に空白がない場合でも、違いは無視されます。

- `--ignore-blank-lines`

  行がすべて空白の変更は無視してください。

- `-I<regex>`, `--ignore-matching-lines=<regex>`

  すべての行が `<regex>` に一致する変更を無視します。このオプションは複数回指定できます。

- `--inter-hunk-context=<lines>`

  指定された行数までの差分ハンク間のコンテキストを表示し、それによって互いに近いハンクを融合します。デフォルトは `diff.interHunkContext` で、`config` オプションが設定されていない場合は0です。

- `-W`, `--function-context`

  関数全体を各変更のコンテキスト行として表示します。関数名は、`git diff` がパッチハンクヘッダーを処理するのと同じ方法で決定されます（[gitattributes[5]](https://git-scm.com/docs/gitattributes) での _Defining a custom hunk-header_ を参照）。

- `--exit-code`

  diff(1) と同様のコードでプログラムを終了させます。つまり、違いがあった場合は1で終了し、0 は違いがないことを意味します。

- `--quiet`

  プログラムのすべての出力を無効にします。`--exit-code` を意味します。

- `--ext-diff`

  外部差分ヘルパーの実行を許可します。[gitattributes[5]](https://git-scm.com/docs/gitattributes) を使用して外部diffドライバーを設定する場合は、このオプションを [git-log[1]](https://git-scm.com/docs/git-log) およびその仲間と一緒に使用する必要があります。

- `--no-ext-diff`

  外部差分ドライバーを禁止します。

- `--textconv`, `--no-textconv`

  バイナリファイルを比較するときに、外部テキスト変換フィルターの実行を許可（または禁止）します。詳細については、[gitattributes[5]](https://git-scm.com/docs/gitattributes) を参照してください。textconv フィルターは通常、一方向の変換であるため、結果のdiffは人間の消費に適していますが、適用することはできません。このため、textconvフィルターは、デフォルトで [git-diff[1]](https://git-scm.com/docs/git-diff) および [git-log[1]](https://git-scm.com/docs/git-log) に対してのみ有効になり、[git-format-patch[1]](https://git-scm.com/docs/git-format-patch) または diff 配管コマンドに対しては有効になりません。

- `--ignore-submodules[=<when>]`

  diff 生成のサブモジュールへの変更を無視します。`<when>` は、「`none`」、「`untracked`」、「`dirty`」、または「`all`」のいずれかになります。これがデフォルトです。 「`none`」を使用すると、追跡されていないファイルまたは変更されたファイルが含まれている場合、またはそのHEADがスーパープロジェクトに記録されているコミットと異なる場合にサブモジュールが変更されたと見なされ、[git-config[1]](https://git-scm.com/docs/git-config) または [gitmodules[5]](https://git-scm.com/docs/gitmodules) の _ignore_ オプションの設定を上書きできます。「`untracked`」が使用されている場合、サブモジュールには追跡されていないコンテンツのみが含まれている場合、サブモジュールはダーティとは見なされません（ただし、変更されたコンテンツはスキャンされます）。 「`dirty`」を使用すると、サブモジュールの作業ツリーへのすべての変更が無視され、スーパープロジェクトに格納されているコミットへの変更のみが表示されます（これは1.7.0までの動作でした）。「`all`」を使用すると、サブモジュールへのすべての変更が非表示になります。

- `--src-prefix=<prefix>`

  「`a/`」の代わりに、指定されたソースプレフィックスを表示します。

- `--dst-prefix=<prefix>`

  「`b/`」の代わりに、指定された宛先プレフィックスを表示します。

- `--no-prefix`

  送信元または宛先のプレフィックスを表示しません。

- `--line-prefix=<prefix>`

  出力のすべての行に追加のプレフィックスを付加します。

- `--ita-invisible-in-index`

  デフォルトでは、「`git add -N`」によって追加されたエントリは、「`git diff`」に既存の空のファイルとして表示され、「`git diff --cached`」に新しいファイルとして表示されます。このオプションを使用すると、エントリは「`git diff`」では新しいファイルとして表示され、「`git diff --cached`」では存在しません。このオプションは、`--ita-visible-in-index` で元に戻すことができます。どちらのオプションも実験的なものであり、将来削除される可能性があります。

これらの一般的なオプションの詳細については、[gitdiffcore[7]](https://git-scm.com/docs/gitdiffcore) も参照してください。

- `-1 --base`, `-2 --ours`, `-3 --theirs`

  作業ツリーを「ベース」バージョン（ステージ＃1）、「私たちのブランチ」（ステージ＃2）、または「それらのブランチ」（ステージ＃3）と比較します。インデックスには、マージされていないエントリの場合、つまり競合を解決している場合にのみ、これらのステージが含まれます。詳細については、[git-read-tree[1]](https://git-scm.com/docs/git-read-tree) セクションの「3方向マージ」を参照してください。

- `-0`

  マージされていないエントリのdiff出力を省略し、「Unmerged」と表示します。作業ツリーをインデックスと比較する場合にのみ使用できます。

- `<path>...`

  `<paths>` パラメーターを指定すると、diff を名前付きパスに制限するために使用されます（ディレクトリ名を指定して、その下にあるすべてのファイルの diff を取得できます）。

```
### RAW OUTPUT FORMAT
       The raw output format from "git-diff-index", "git-diff-tree",
       "git-diff-files" and "git diff --raw" are very similar.

       These commands all compare two sets of things; what is compared
       differs:

       git-diff-index <tree-ish>
           compares the <tree-ish> and the files on the filesystem.

       git-diff-index --cached <tree-ish>
           compares the <tree-ish> and the index.

       git-diff-tree [-r] <tree-ish-1> <tree-ish-2> [<pattern>...]
           compares the trees named by the two arguments.

       git-diff-files [<pattern>...]
           compares the index and the files on the filesystem.

       The "git-diff-tree" command begins its output by printing the hash of
       what is being compared. After that, all the commands print one output
       line per changed file.

       An output line is formatted this way:

           in-place edit  :100644 100644 bcd1234 0123456 M file0
           copy-edit      :100644 100644 abcd123 1234567 C68 file1 file2
           rename-edit    :100644 100644 abcd123 1234567 R86 file1 file3
           create         :000000 100644 0000000 1234567 A file4
           delete         :100644 000000 1234567 0000000 D file5
           unmerged       :000000 000000 0000000 0000000 U file6


       That is, from the left to the right:

        1. a colon.

        2. mode for "src"; 000000 if creation or unmerged.

        3. a space.

        4. mode for "dst"; 000000 if deletion or unmerged.

        5. a space.

        6. sha1 for "src"; 0{40} if creation or unmerged.

        7. a space.

        8. sha1 for "dst"; 0{40} if creation, unmerged or "look at work tree".

        9. a space.

       10. status, followed by optional "score" number.

       11. a tab or a NUL when -z option is used.

       12. path for "src"

       13. a tab or a NUL when -z option is used; only exists for C or R.

       14. path for "dst"; only exists for C or R.

       15. an LF or a NUL when -z option is used, to terminate the record.

       Possible status letters are:

       o   A: addition of a file

       o   C: copy of a file into a new one

       o   D: deletion of a file

       o   M: modification of the contents or mode of a file

       o   R: renaming of a file

       o   T: change in the type of the file

       o   U: file is unmerged (you must complete the merge before it can be
           committed)

       o   X: "unknown" change type (most probably a bug, please report it)

       Status letters C and R are always followed by a score (denoting the
       percentage of similarity between the source and target of the move or
       copy). Status letter M may be followed by a score (denoting the
       percentage of dissimilarity) for file rewrites.

       <sha1> is shown as all 0's if a file is new on the filesystem and it is
       out of sync with the index.

       Example:

           :100644 100644 5be4a4a 0000000 M file.c


       Without the -z option, pathnames with "unusual" characters are quoted
       as explained for the configuration variable core.quotePath (see git-
       config(1)). Using -z the filename is output verbatim and the line is
       terminated by a NUL byte.

### DIFF FORMAT FOR MERGES
       "git-diff-tree", "git-diff-files" and "git-diff --raw" can take -c or
       --cc option to generate diff output also for merge commits. The output
       differs from the format described above in the following way:

        1. there is a colon for each parent

        2. there are more "src" modes and "src" sha1

        3. status is concatenated status characters for each parent

        4. no optional "score" number

        5. tab-separated pathname(s) of the file

       For -c and --cc, only the destination or final path is shown even if
       the file was renamed on any side of history. With --combined-all-paths,
       the name of the path in each parent is shown followed by the name of
       the path in the merge commit.

       Examples for -c and --cc without --combined-all-paths:

           ::100644 100644 100644 fabadb8 cc95eb0 4866510 MM       desc.c
           ::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM       bar.sh
           ::100644 100644 100644 e07d6c5 9042e82 ee91881 RR       phooey.c


       Examples when --combined-all-paths added to either -c or --cc:

           ::100644 100644 100644 fabadb8 cc95eb0 4866510 MM       desc.c  desc.c  desc.c
           ::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM       foo.sh  bar.sh  bar.sh
           ::100644 100644 100644 e07d6c5 9042e82 ee91881 RR       fooey.c fuey.c  phooey.c


       Note that combined diff lists only files which were modified from all
       parents.

### GENERATING PATCH TEXT WITH -P
       Running git-diff(1), git-log(1), git-show(1), git-diff-index(1), git-
       diff-tree(1), or git-diff-files(1) with the -p option produces patch
       text. You can customize the creation of patch text via the
       GIT_EXTERNAL_DIFF and the GIT_DIFF_OPTS environment variables (see
       git(1)).

       What the -p option produces is slightly different from the traditional
       diff format:

        1. It is preceded with a "git diff" header that looks like this:

               diff --git a/file1 b/file2

           The a/ and b/ filenames are the same unless rename/copy is
           involved. Especially, even for a creation or a deletion, /dev/null
           is not used in place of the a/ or b/ filenames.

           When rename/copy is involved, file1 and file2 show the name of the
           source file of the rename/copy and the name of the file that
           rename/copy produces, respectively.

        2. It is followed by one or more extended header lines:

               old mode <mode>
               new mode <mode>
               deleted file mode <mode>
               new file mode <mode>
               copy from <path>
               copy to <path>
               rename from <path>
               rename to <path>
               similarity index <number>
               dissimilarity index <number>
               index <hash>..<hash> <mode>

           File modes are printed as 6-digit octal numbers including the file
           type and file permission bits.

           Path names in extended headers do not include the a/ and b/
           prefixes.

           The similarity index is the percentage of unchanged lines, and the
           dissimilarity index is the percentage of changed lines. It is a
           rounded down integer, followed by a percent sign. The similarity
           index value of 100% is thus reserved for two equal files, while
           100% dissimilarity means that no line from the old file made it
           into the new one.

           The index line includes the blob object names before and after the
           change. The <mode> is included if the file mode does not change;
           otherwise, separate lines indicate the old and the new mode.

        3. Pathnames with "unusual" characters are quoted as explained for the
           configuration variable core.quotePath (see git-config(1)).

        4. All the file1 files in the output refer to files before the commit,
           and all the file2 files refer to files after the commit. It is
           incorrect to apply each change to each file sequentially. For
           example, this patch will swap a and b:

               diff --git a/a b/b
               rename from a
               rename to b
               diff --git a/b b/a
               rename from b
               rename to a

### COMBINED DIFF FORMAT
       Any diff-generating command can take the -c or --cc option to produce a
       combined diff when showing a merge. This is the default format when
       showing merges with git-diff(1) or git-show(1). Note also that you can
       give suitable --diff-merges option to any of these commands to force
       generation of diffs in specific format.

       A "combined diff" format looks like this:

           diff --combined describe.c
           index fabadb8,cc95eb0..4866510
           --- a/describe.c
           +++ b/describe.c
           @@@ -98,20 -98,12 +98,20 @@@
                   return (a_date > b_date) ? -1 : (a_date == b_date) ? 0 : 1;
             }

           - static void describe(char *arg)
            -static void describe(struct commit *cmit, int last_one)
           ++static void describe(char *arg, int last_one)
             {
            +      unsigned char sha1[20];
            +      struct commit *cmit;
                   struct commit_list *list;
                   static int initialized = 0;
                   struct commit_name *n;

            +      if (get_sha1(arg, sha1) < 0)
            +              usage(describe_usage);
            +      cmit = lookup_commit_reference(sha1);
            +      if (!cmit)
            +              usage(describe_usage);
            +
                   if (!initialized) {
                           initialized = 1;
                           for_each_ref(get_name);



        1. It is preceded with a "git diff" header, that looks like this (when
           the -c option is used):

               diff --combined file

           or like this (when the --cc option is used):

               diff --cc file

        2. It is followed by one or more extended header lines (this example
           shows a merge with two parents):

               index <hash>,<hash>..<hash>
               mode <mode>,<mode>..<mode>
               new file mode <mode>
               deleted file mode <mode>,<mode>

           The mode <mode>,<mode>..<mode> line appears only if at least one of
           the <mode> is different from the rest. Extended headers with
           information about detected contents movement (renames and copying
           detection) are designed to work with diff of two <tree-ish> and are
           not used by combined diff format.

        3. It is followed by two-line from-file/to-file header

               --- a/file
               +++ b/file

           Similar to two-line header for traditional unified diff format,
           /dev/null is used to signal created or deleted files.

           However, if the --combined-all-paths option is provided, instead of
           a two-line from-file/to-file you get a N+1 line from-file/to-file
           header, where N is the number of parents in the merge commit

               --- a/file
               --- a/file
               --- a/file
               +++ b/file

           This extended format can be useful if rename or copy detection is
           active, to allow you to see the original name of the file in
           different parents.

        4. Chunk header format is modified to prevent people from accidentally
           feeding it to patch -p1. Combined diff format was created for
           review of merge commit changes, and was not meant to be applied.
           The change is similar to the change in the extended index header:

               @@@ <from-file-range> <from-file-range> <to-file-range> @@@

           There are (number of parents + 1) @ characters in the chunk header
           for combined diff format.

       Unlike the traditional unified diff format, which shows two files A and
       B with a single column that has - (minus -- appears in A but removed in
       B), + (plus -- missing in A but added to B), or " " (space --
       unchanged) prefix, this format compares two or more files file1,
       file2,... with one file X, and shows how X differs from each of fileN.
       One column for each of fileN is prepended to the output line to note
       how X's line is different from it.

       A - character in the column N means that the line appears in fileN but
       it does not appear in the result. A + character in the column N means
       that the line appears in the result, and fileN does not have that line
       (in other words, the line was added, from the point of view of that
       parent).

       In the above example output, the function signature was changed from
       both files (hence two - removals from both file1 and file2, plus ++ to
       mean one line that was added does not appear in either file1 or file2).
       Also eight other lines are the same from file1 but do not appear in
       file2 (hence prefixed with +).

       When shown by git diff-tree -c, it compares the parents of a merge
       commit with the merge result (i.e. file1..fileN are the parents). When
       shown by git diff-files -c, it compares the two unresolved merge
       parents with the working tree file (i.e. file1 is stage 2 aka "our
       version", file2 is stage 3 aka "their version").

### OTHER DIFF FORMATS
       The --summary option describes newly added, deleted, renamed and copied
       files. The --stat option adds diffstat(1) graph to the output. These
       options can be combined with other options, such as -p, and are meant
       for human consumption.

       When showing a change that involves a rename or a copy, --stat output
       formats the pathnames compactly by combining common prefix and suffix
       of the pathnames. For example, a change that moves arch/i386/Makefile
       to arch/x86/Makefile while modifying 4 lines will be shown like this:

           arch/{i386 => x86}/Makefile    |   4 +--


       The --numstat option gives the diffstat(1) information but is designed
       for easier machine consumption. An entry in --numstat output looks like
       this:

           1       2       README
           3       1       arch/{i386 => x86}/Makefile


       That is, from left to right:

        1. the number of added lines;

        2. a tab;

        3. the number of deleted lines;

        4. a tab;

        5. pathname (possibly with rename/copy information);

        6. a newline.

       When -z output option is in effect, the output is formatted this way:

           1       2       README NUL
           3       1       NUL arch/i386/Makefile NUL arch/x86/Makefile NUL


       That is:

        1. the number of added lines;

        2. a tab;

        3. the number of deleted lines;

        4. a tab;

        5. a NUL (only exists if renamed/copied);

        6. pathname in preimage;

        7. a NUL (only exists if renamed/copied);

        8. pathname in postimage (only exists if renamed/copied);

        9. a NUL.

       The extra NUL before the preimage path in renamed case is to allow
       scripts that read the output to tell if the current record being read
       is a single-path record or a rename/copy record without reading ahead.
       After reading added and deleted lines, reading up to NUL would yield
       the pathname, but if that is NUL, the record will show two paths.

### EXAMPLES
       Various ways to check your working tree

               $ git diff            (1)
               $ git diff --cached   (2)
               $ git diff HEAD       (3)

           1. Changes in the working tree not yet staged for the next commit.
           2. Changes between the index and your last commit; what you would
           be committing if you run git commit without -a option.
           3. Changes in the working tree since your last commit; what you
           would be committing if you run git commit -a

       Comparing with arbitrary commits

               $ git diff test            (1)
               $ git diff HEAD -- ./test  (2)
               $ git diff HEAD^ HEAD      (3)

           1. Instead of using the tip of the current branch, compare with the
           tip of "test" branch.
           2. Instead of comparing with the tip of "test" branch, compare with
           the tip of the current branch, but limit the comparison to the file
           "test".
           3. Compare the version before the last commit and the last commit.

       Comparing branches

               $ git diff topic main    (1)
               $ git diff topic..main   (2)
               $ git diff topic...main  (3)

           1. Changes between the tips of the topic and the main branches.
           2. Same as above.
           3. Changes that occurred on the main branch since when the topic
           branch was started off it.

       Limiting the diff output

               $ git diff --diff-filter=MRC            (1)
               $ git diff --name-status                (2)
               $ git diff arch/i386 include/asm-i386   (3)

           1. Show only modification, rename, and copy, but not addition or
           deletion.
           2. Show only names and the nature of change, but not actual diff
           output.
           3. Limit diff output to named subtrees.

       Munging the diff output

               $ git diff --find-copies-harder -B -C  (1)
               $ git diff -R                          (2)

           1. Spend extra cycles to find renames, copies and complete rewrites
           (very expensive).
           2. Output diff in reverse.

### SEE ALSO
       diff(1), git-difftool(1), git-log(1), gitdiffcore(7), git-format-
       patch(1), git-apply(1), git-show(1)
```



## `grep`




```
GIT-GREP(1)                       Git Manual                       GIT-GREP(1)



NAME
       git-grep - パターンに一致する行を表示する

SYNOPSIS
       git grep [-a | --text] [-I] [--textconv] [-i | --ignore-case] [-w | --word-regexp]
                  [-v | --invert-match] [-h|-H] [--full-name]
                  [-E | --extended-regexp] [-G | --basic-regexp]
                  [-P | --perl-regexp]
                  [-F | --fixed-strings] [-n | --line-number] [--column]
                  [-l | --files-with-matches] [-L | --files-without-match]
                  [(-O | --open-files-in-pager) [<pager>]]
                  [-z | --null]
                  [ -o | --only-matching ] [-c | --count] [--all-match] [-q | --quiet]
                  [--max-depth <depth>] [--[no-]recursive]
                  [--color[=<when>] | --no-color]
                  [--break] [--heading] [-p | --show-function]
                  [-A <post-context>] [-B <pre-context>] [-C <context>]
                  [-W | --function-context]
                  [--threads <num>]
                  [-f <file>] [-e] <pattern>
                  [--and|--or|--not|(|)|-e <pattern>...]
                  [--recurse-submodules] [--parent-basename <basename>]
                  [ [--[no-]exclude-standard] [--cached | --no-index | --untracked] | <tree>...]
                  [--] [<pathspec>...]


DESCRIPTION
       作業ツリーの追跡ファイル、インデックスファイルに登録されているブロブ、
       または指定されたツリーオブジェクトのブロブで指定されたパターンを探します。
       パターンは、改行文字で区切られた1つ以上の検索式のリストです。
       検索式としての空の文字列は、すべての行に一致します。

CONFIGURATION
       grep.lineNumber
           If set to true, enable -n option by default.

       grep.column
           If set to true, enable the --column option by default.

       grep.patternType
           Set the default matching behavior. Using a value of basic,
           extended, fixed, or perl will enable the --basic-regexp,
           --extended-regexp, --fixed-strings, or --perl-regexp option
           accordingly, while the value default will return to the default
           matching behavior.

       grep.extendedRegexp
           If set to true, enable --extended-regexp option by default. This
           option is ignored when the grep.patternType option is set to a
           value other than default.

       grep.threads
           Number of grep worker threads to use. If unset (or set to 0), Git
           will use as many threads as the number of logical cores available.

       grep.fullName
           If set to true, enable --full-name option by default.

       grep.fallbackToNoIndex
           If set to true, fall back to git grep --no-index if git grep is
           executed outside of a git repository. Defaults to false.

OPTIONS
       --cached
           Instead of searching tracked files in the working tree, search
           blobs registered in the index file.

       --no-index
           Search files in the current directory that is not managed by Git.

       --untracked
           In addition to searching in the tracked files in the working tree,
           search also in untracked files.

       --no-exclude-standard
           Also search in ignored files by not honoring the .gitignore
           mechanism. Only useful with --untracked.

       --exclude-standard
           Do not pay attention to ignored files specified via the .gitignore
           mechanism. Only useful when searching files in the current
           directory with --no-index.

       --recurse-submodules
           Recursively search in each submodule that is active and checked out
           in the repository. When used in combination with the <tree> option
           the prefix of all submodule output will be the name of the parent
           project's <tree> object. This option has no effect if --no-index is
           given.

       -a, --text
           Process binary files as if they were text.

       --textconv
           Honor textconv filter settings.

       --no-textconv
           Do not honor textconv filter settings. This is the default.

       -i, --ignore-case
           Ignore case differences between the patterns and the files.

       -I
           Don't match the pattern in binary files.

       --max-depth <depth>
           For each <pathspec> given on command line, descend at most <depth>
           levels of directories. A value of -1 means no limit. This option is
           ignored if <pathspec> contains active wildcards. In other words if
           "a*" matches a directory named "a*", "*" is matched literally so
           --max-depth is still effective.

       -r, --recursive
           Same as --max-depth=-1; this is the default.

       --no-recursive
           Same as --max-depth=0.

       -w, --word-regexp
           Match the pattern only at word boundary (either begin at the
           beginning of a line, or preceded by a non-word character; end at
           the end of a line or followed by a non-word character).

       -v, --invert-match
           Select non-matching lines.

       -h, -H
           By default, the command shows the filename for each match.  -h
           option is used to suppress this output.  -H is there for
           completeness and does not do anything except it overrides -h given
           earlier on the command line.

       --full-name
           When run from a subdirectory, the command usually outputs paths
           relative to the current directory. This option forces paths to be
           output relative to the project top directory.

       -E, --extended-regexp, -G, --basic-regexp
           Use POSIX extended/basic regexp for patterns. Default is to use
           basic regexp.

       -P, --perl-regexp
           Use Perl-compatible regular expressions for patterns.

           Support for these types of regular expressions is an optional
           compile-time dependency. If Git wasn't compiled with support for
           them providing this option will cause it to die.

       -F, --fixed-strings
           Use fixed strings for patterns (don't interpret pattern as a
           regex).

       -n, --line-number
           Prefix the line number to matching lines.

       --column
           Prefix the 1-indexed byte-offset of the first match from the start
           of the matching line.

       -l, --files-with-matches, --name-only, -L, --files-without-match
           Instead of showing every matched line, show only the names of files
           that contain (or do not contain) matches. For better compatibility
           with git diff, --name-only is a synonym for --files-with-matches.

       -O[<pager>], --open-files-in-pager[=<pager>]
           Open the matching files in the pager (not the output of grep). If
           the pager happens to be "less" or "vi", and the user specified only
           one pattern, the first file is positioned at the first match
           automatically. The pager argument is optional; if specified, it
           must be stuck to the option without a space. If pager is
           unspecified, the default pager will be used (see core.pager in git-
           config(1)).

       -z, --null
           Use \0 as the delimiter for pathnames in the output, and print them
           verbatim. Without this option, pathnames with "unusual" characters
           are quoted as explained for the configuration variable
           core.quotePath (see git-config(1)).

       -o, --only-matching
           Print only the matched (non-empty) parts of a matching line, with
           each such part on a separate output line.

       -c, --count
           Instead of showing every matched line, show the number of lines
           that match.

       --color[=<when>]
           Show colored matches. The value must be always (the default),
           never, or auto.

       --no-color
           Turn off match highlighting, even when the configuration file gives
           the default to color output. Same as --color=never.

       --break
           Print an empty line between matches from different files.

       --heading
           Show the filename above the matches in that file instead of at the
           start of each shown line.

       -p, --show-function
           Show the preceding line that contains the function name of the
           match, unless the matching line is a function name itself. The name
           is determined in the same way as git diff works out patch hunk
           headers (see Defining a custom hunk-header in gitattributes(5)).

       -<num>, -C <num>, --context <num>
           Show <num> leading and trailing lines, and place a line containing
           -- between contiguous groups of matches.

       -A <num>, --after-context <num>
           Show <num> trailing lines, and place a line containing -- between
           contiguous groups of matches.

       -B <num>, --before-context <num>
           Show <num> leading lines, and place a line containing -- between
           contiguous groups of matches.

       -W, --function-context
           Show the surrounding text from the previous line containing a
           function name up to the one before the next function name,
           effectively showing the whole function in which the match was
           found. The function names are determined in the same way as git
           diff works out patch hunk headers (see Defining a custom
           hunk-header in gitattributes(5)).

       --threads <num>
           Number of grep worker threads to use. See grep.threads in
           CONFIGURATION for more information.

       -f <file>
           Read patterns from <file>, one per line.

           Passing the pattern via <file> allows for providing a search
           pattern containing a \0.

           Not all pattern types support patterns containing \0. Git will
           error out if a given pattern type can't support such a pattern. The
           --perl-regexp pattern type when compiled against the PCRE v2
           backend has the widest support for these types of patterns.

           In versions of Git before 2.23.0 patterns containing \0 would be
           silently considered fixed. This was never documented, there were
           also odd and undocumented interactions between e.g. non-ASCII
           patterns containing \0 and --ignore-case.

           In future versions we may learn to support patterns containing \0
           for more search backends, until then we'll die when the pattern
           type in question doesn't support them.

       -e
           The next parameter is the pattern. This option has to be used for
           patterns starting with - and should be used in scripts passing user
           input to grep. Multiple patterns are combined by or.

       --and, --or, --not, ( ... )
           Specify how multiple patterns are combined using Boolean
           expressions.  --or is the default operator.  --and has higher
           precedence than --or.  -e has to be used for all patterns.

       --all-match
           When giving multiple pattern expressions combined with --or, this
           flag is specified to limit the match to files that have lines to
           match all of them.

       -q, --quiet
           Do not output matched lines; instead, exit with status 0 when there
           is a match and with non-zero status when there isn't.

       <tree>...
           Instead of searching tracked files in the working tree, search
           blobs in the given trees.

       --
           Signals the end of options; the rest of the parameters are
           <pathspec> limiters.

       <pathspec>...
           If given, limit the search to paths matching at least one pattern.
           Both leading paths match and glob(7) patterns are supported.

           For more details about the <pathspec> syntax, see the pathspec
           entry in gitglossary(7).

EXAMPLES
       git grep 'time_t' -- '*.[ch]'
           Looks for time_t in all tracked .c and .h files in the working
           directory and its subdirectories.

       git grep -e '#define' --and \( -e MAX_PATH -e PATH_MAX \)
           Looks for a line that has #define and either MAX_PATH or PATH_MAX.

       git grep --all-match -e NODE -e Unexpected
           Looks for a line that has NODE or Unexpected in files that have
           lines that match both.

       git grep solution -- :^Documentation
           Looks for solution, excluding files in Documentation.

NOTES ON THREADS
       The --threads option (and the grep.threads configuration) will be
       ignored when --open-files-in-pager is used, forcing a single-threaded
       execution.

       When grepping the object store (with --cached or giving tree objects),
       running with multiple threads might perform slower than single threaded
       if --textconv is given and there're too many text conversions. So if
       you experience low performance in this case, it might be desirable to
       use --threads=1.

GIT
       Part of the git(1) suite



Git 2.30.1.378.g1d4f23            02/08/2021                       GIT-GREP(1)
```



## `log`




```
GIT-LOG(1)                        Git Manual                        GIT-LOG(1)



NAME
       git-log - コミットログを表示する

SYNOPSIS
       git log [<options>] [<revision range>] [[--] <path>...]


DESCRIPTION
       コミットログを表示します。
       
       指定されたコミットから親リンクをたどることによって到達可能なコミットをリストしますが、
       前に ^ が付いたコミットから到達可能なコミットは除外します。
       デフォルトでは、出力は時系列の逆順で表示されます。
       
       これは集合演算と考えることができます。
       コマンドラインで指定されたコミットのいずれかから到達可能なコミットがセットを形成し、
       ^ が前に付いたコミットのいずれかから到達可能なコミットがそのセットから差し引かれます。
       残りのコミットは、コマンドの出力に出力されるものです。
       他のさまざまなオプションとパスパラメータを使用して、結果をさらに制限できます。

       したがって、次のコマンド：

           $ git log foo bar ^baz

       
       は「foo または bar からは到達可能であるが、baz からは到達できないすべてのコミットをリストする」
       という意味です。
       
       「^ <commit1> <commit2>」の省略形として、特別な表記
       「<commit1> .. <commit2>」を使用できます。
       たとえば、次のいずれかを同じ意味で使用できます：

           $ git log origin..HEAD
           $ git log HEAD ^origin


       もう1つの特別な表記法は、マージに役立つ「<commit1>…<commit2>」です。
       結果として得られるコミットのセットは、2つのオペランド間の対称差です。
       次の2つのコマンドは同等です：

           $ git log A B --not $(git merge-base --all A B)
           $ git log A...B


       このコマンドは、git-rev-list(1) コマンドに適用可能なオプションを使用して、表示内容と方法を制御し、
       git-diff(1) コマンドに適用可能なオプションを使用して、
       各コミットによって導入される変更の表示方法を制御します。

OPTIONS
       --follow
           Continue listing the history of a file beyond renames (works only
           for a single file).

       --no-decorate, --decorate[=short|full|auto|no]
           Print out the ref names of any commits that are shown. If short is
           specified, the ref name prefixes refs/heads/, refs/tags/ and
           refs/remotes/ will not be printed. If full is specified, the full
           ref name (including prefix) will be printed. If auto is specified,
           then if the output is going to a terminal, the ref names are shown
           as if short were given, otherwise no ref names are shown. The
           default option is short.

       --decorate-refs=<pattern>, --decorate-refs-exclude=<pattern>
           If no --decorate-refs is given, pretend as if all refs were
           included. For each candidate, do not use it for decoration if it
           matches any patterns given to --decorate-refs-exclude or if it
           doesn't match any of the patterns given to --decorate-refs. The
           log.excludeDecoration config option allows excluding refs from the
           decorations, but an explicit --decorate-refs pattern will override
           a match in log.excludeDecoration.

       --source
           Print out the ref name given on the command line by which each
           commit was reached.

       --[no-]mailmap, --[no-]use-mailmap
           Use mailmap file to map author and committer names and email
           addresses to canonical real names and email addresses. See git-
           shortlog(1).

       --full-diff
           Without this flag, git log -p <path>...  shows commits that touch
           the specified paths, and diffs about the same specified paths. With
           this, the full diff is shown for commits that touch the specified
           paths; this means that "<path>..." limits only commits, and doesn't
           limit diff for those commits.

           Note that this affects all diff-based output types, e.g. those
           produced by --stat, etc.

       --log-size
           Include a line "log size <number>" in the output for each commit,
           where <number> is the length of that commit's message in bytes.
           Intended to speed up tools that read log messages from git log
           output by allowing them to allocate space in advance.

       -L<start>,<end>:<file>, -L:<funcname>:<file>
           Trace the evolution of the line range given by <start>,<end>, or by
           the function name regex <funcname>, within the <file>. You may not
           give any pathspec limiters. This is currently limited to a walk
           starting from a single revision, i.e., you may only give zero or
           one positive revision arguments, and <start> and <end> (or
           <funcname>) must exist in the starting revision. You can specify
           this option more than once. Implies --patch. Patch output can be
           suppressed using --no-patch, but other diff formats (namely --raw,
           --numstat, --shortstat, --dirstat, --summary, --name-only,
           --name-status, --check) are not currently implemented.

           <start> and <end> can take one of these forms:

           o   number

               If <start> or <end> is a number, it specifies an absolute line
               number (lines count from 1).

           o   /regex/

               This form will use the first line matching the given POSIX
               regex. If <start> is a regex, it will search from the end of
               the previous -L range, if any, otherwise from the start of
               file. If <start> is ^/regex/, it will search from the start of
               file. If <end> is a regex, it will search starting at the line
               given by <start>.

           o   +offset or -offset

               This is only valid for <end> and will specify a number of lines
               before or after the line given by <start>.

           If :<funcname> is given in place of <start> and <end>, it is a
           regular expression that denotes the range from the first funcname
           line that matches <funcname>, up to the next funcname line.
           :<funcname> searches from the end of the previous -L range, if any,
           otherwise from the start of file.  ^:<funcname> searches from the
           start of file. The function names are determined in the same way as
           git diff works out patch hunk headers (see Defining a custom
           hunk-header in gitattributes(5)).

       <revision range>
           Show only commits in the specified revision range. When no
           <revision range> is specified, it defaults to HEAD (i.e. the whole
           history leading to the current commit).  origin..HEAD specifies all
           the commits reachable from the current commit (i.e.  HEAD), but not
           from origin. For a complete list of ways to spell <revision range>,
           see the Specifying Ranges section of gitrevisions(7).

       [--] <path>...
           Show only commits that are enough to explain how the files that
           match the specified paths came to be. See History Simplification
           below for details and other simplification modes.

           Paths may need to be prefixed with -- to separate them from options
           or the revision range, when confusion arises.

   Commit Limiting
       Besides specifying a range of commits that should be listed using the
       special notations explained in the description, additional commit
       limiting may be applied.

       Using more options generally further limits the output (e.g.
       --since=<date1> limits to commits newer than <date1>, and using it with
       --grep=<pattern> further limits to commits whose log message has a line
       that matches <pattern>), unless otherwise noted.

       Note that these are applied before commit ordering and formatting
       options, such as --reverse.

       -<number>, -n <number>, --max-count=<number>
           Limit the number of commits to output.

       --skip=<number>
           Skip number commits before starting to show the commit output.

       --since=<date>, --after=<date>
           Show commits more recent than a specific date.

       --until=<date>, --before=<date>
           Show commits older than a specific date.

       --author=<pattern>, --committer=<pattern>
           Limit the commits output to ones with author/committer header lines
           that match the specified pattern (regular expression). With more
           than one --author=<pattern>, commits whose author matches any of
           the given patterns are chosen (similarly for multiple
           --committer=<pattern>).

       --grep-reflog=<pattern>
           Limit the commits output to ones with reflog entries that match the
           specified pattern (regular expression). With more than one
           --grep-reflog, commits whose reflog message matches any of the
           given patterns are chosen. It is an error to use this option unless
           --walk-reflogs is in use.

       --grep=<pattern>
           Limit the commits output to ones with log message that matches the
           specified pattern (regular expression). With more than one
           --grep=<pattern>, commits whose message matches any of the given
           patterns are chosen (but see --all-match).

           When --notes is in effect, the message from the notes is matched as
           if it were part of the log message.

       --all-match
           Limit the commits output to ones that match all given --grep,
           instead of ones that match at least one.

       --invert-grep
           Limit the commits output to ones with log message that do not match
           the pattern specified with --grep=<pattern>.

       -i, --regexp-ignore-case
           Match the regular expression limiting patterns without regard to
           letter case.

       --basic-regexp
           Consider the limiting patterns to be basic regular expressions;
           this is the default.

       -E, --extended-regexp
           Consider the limiting patterns to be extended regular expressions
           instead of the default basic regular expressions.

       -F, --fixed-strings
           Consider the limiting patterns to be fixed strings (don't interpret
           pattern as a regular expression).

       -P, --perl-regexp
           Consider the limiting patterns to be Perl-compatible regular
           expressions.

           Support for these types of regular expressions is an optional
           compile-time dependency. If Git wasn't compiled with support for
           them providing this option will cause it to die.

       --remove-empty
           Stop when a given path disappears from the tree.

       --merges
           Print only merge commits. This is exactly the same as
           --min-parents=2.

       --no-merges
           Do not print commits with more than one parent. This is exactly the
           same as --max-parents=1.

       --min-parents=<number>, --max-parents=<number>, --no-min-parents,
       --no-max-parents
           Show only commits which have at least (or at most) that many parent
           commits. In particular, --max-parents=1 is the same as --no-merges,
           --min-parents=2 is the same as --merges.  --max-parents=0 gives all
           root commits and --min-parents=3 all octopus merges.

           --no-min-parents and --no-max-parents reset these limits (to no
           limit) again. Equivalent forms are --min-parents=0 (any commit has
           0 or more parents) and --max-parents=-1 (negative numbers denote no
           upper limit).

       --first-parent
           Follow only the first parent commit upon seeing a merge commit.
           This option can give a better overview when viewing the evolution
           of a particular topic branch, because merges into a topic branch
           tend to be only about adjusting to updated upstream from time to
           time, and this option allows you to ignore the individual commits
           brought in to your history by such a merge.

               This option also changes default diff format for merge commits
               to `first-parent`, see `--diff-merges=first-parent` for details.

       --not
           Reverses the meaning of the ^ prefix (or lack thereof) for all
           following revision specifiers, up to the next --not.

       --all
           Pretend as if all the refs in refs/, along with HEAD, are listed on
           the command line as <commit>.

       --branches[=<pattern>]
           Pretend as if all the refs in refs/heads are listed on the command
           line as <commit>. If <pattern> is given, limit branches to ones
           matching given shell glob. If pattern lacks ?, *, or [, /* at the
           end is implied.

       --tags[=<pattern>]
           Pretend as if all the refs in refs/tags are listed on the command
           line as <commit>. If <pattern> is given, limit tags to ones
           matching given shell glob. If pattern lacks ?, *, or [, /* at the
           end is implied.

       --remotes[=<pattern>]
           Pretend as if all the refs in refs/remotes are listed on the
           command line as <commit>. If <pattern> is given, limit
           remote-tracking branches to ones matching given shell glob. If
           pattern lacks ?, *, or [, /* at the end is implied.

       --glob=<glob-pattern>
           Pretend as if all the refs matching shell glob <glob-pattern> are
           listed on the command line as <commit>. Leading refs/, is
           automatically prepended if missing. If pattern lacks ?, *, or [, /*
           at the end is implied.

       --exclude=<glob-pattern>
           Do not include refs matching <glob-pattern> that the next --all,
           --branches, --tags, --remotes, or --glob would otherwise consider.
           Repetitions of this option accumulate exclusion patterns up to the
           next --all, --branches, --tags, --remotes, or --glob option (other
           options or arguments do not clear accumulated patterns).

           The patterns given should not begin with refs/heads, refs/tags, or
           refs/remotes when applied to --branches, --tags, or --remotes,
           respectively, and they must begin with refs/ when applied to --glob
           or --all. If a trailing /* is intended, it must be given
           explicitly.

       --reflog
           Pretend as if all objects mentioned by reflogs are listed on the
           command line as <commit>.

       --alternate-refs
           Pretend as if all objects mentioned as ref tips of alternate
           repositories were listed on the command line. An alternate
           repository is any repository whose object directory is specified in
           objects/info/alternates. The set of included objects may be
           modified by core.alternateRefsCommand, etc. See git-config(1).

       --single-worktree
           By default, all working trees will be examined by the following
           options when there are more than one (see git-worktree(1)): --all,
           --reflog and --indexed-objects. This option forces them to examine
           the current working tree only.

       --ignore-missing
           Upon seeing an invalid object name in the input, pretend as if the
           bad input was not given.

       --bisect
           Pretend as if the bad bisection ref refs/bisect/bad was listed and
           as if it was followed by --not and the good bisection refs
           refs/bisect/good-* on the command line.

       --stdin
           In addition to the <commit> listed on the command line, read them
           from the standard input. If a -- separator is seen, stop reading
           commits and start reading paths to limit the result.

       --cherry-mark
           Like --cherry-pick (see below) but mark equivalent commits with =
           rather than omitting them, and inequivalent ones with +.

       --cherry-pick
           Omit any commit that introduces the same change as another commit
           on the "other side" when the set of commits are limited with
           symmetric difference.

           For example, if you have two branches, A and B, a usual way to list
           all commits on only one side of them is with --left-right (see the
           example below in the description of the --left-right option).
           However, it shows the commits that were cherry-picked from the
           other branch (for example, "3rd on b" may be cherry-picked from
           branch A). With this option, such pairs of commits are excluded
           from the output.

       --left-only, --right-only
           List only commits on the respective side of a symmetric difference,
           i.e. only those which would be marked < resp.  > by --left-right.

           For example, --cherry-pick --right-only A...B omits those commits
           from B which are in A or are patch-equivalent to a commit in A. In
           other words, this lists the + commits from git cherry A B. More
           precisely, --cherry-pick --right-only --no-merges gives the exact
           list.

       --cherry
           A synonym for --right-only --cherry-mark --no-merges; useful to
           limit the output to the commits on our side and mark those that
           have been applied to the other side of a forked history with git
           log --cherry upstream...mybranch, similar to git cherry upstream
           mybranch.

       -g, --walk-reflogs
           Instead of walking the commit ancestry chain, walk reflog entries
           from the most recent one to older ones. When this option is used
           you cannot specify commits to exclude (that is, ^commit,
           commit1..commit2, and commit1...commit2 notations cannot be used).

           With --pretty format other than oneline and reference (for obvious
           reasons), this causes the output to have two extra lines of
           information taken from the reflog. The reflog designator in the
           output may be shown as ref@{Nth} (where Nth is the
           reverse-chronological index in the reflog) or as ref@{timestamp}
           (with the timestamp for that entry), depending on a few rules:

            1. If the starting point is specified as ref@{Nth}, show the index
               format.

            2. If the starting point was specified as ref@{now}, show the
               timestamp format.

            3. If neither was used, but --date was given on the command line,
               show the timestamp in the format requested by --date.

            4. Otherwise, show the index format.

           Under --pretty=oneline, the commit message is prefixed with this
           information on the same line. This option cannot be combined with
           --reverse. See also git-reflog(1).

           Under --pretty=reference, this information will not be shown at
           all.

       --merge
           After a failed merge, show refs that touch files having a conflict
           and don't exist on all heads to merge.

       --boundary
           Output excluded boundary commits. Boundary commits are prefixed
           with -.

   History Simplification
       Sometimes you are only interested in parts of the history, for example
       the commits modifying a particular <path>. But there are two parts of
       History Simplification, one part is selecting the commits and the other
       is how to do it, as there are various strategies to simplify the
       history.

       The following options select the commits to be shown:

       <paths>
           Commits modifying the given <paths> are selected.

       --simplify-by-decoration
           Commits that are referred by some branch or tag are selected.

       Note that extra commits can be shown to give a meaningful history.

       The following options affect the way the simplification is performed:

       Default mode
           Simplifies the history to the simplest history explaining the final
           state of the tree. Simplest because it prunes some side branches if
           the end result is the same (i.e. merging branches with the same
           content)

       --show-pulls
           Include all commits from the default mode, but also any merge
           commits that are not TREESAME to the first parent but are TREESAME
           to a later parent. This mode is helpful for showing the merge
           commits that "first introduced" a change to a branch.

       --full-history
           Same as the default mode, but does not prune some history.

       --dense
           Only the selected commits are shown, plus some to have a meaningful
           history.

       --sparse
           All commits in the simplified history are shown.

       --simplify-merges
           Additional option to --full-history to remove some needless merges
           from the resulting history, as there are no selected commits
           contributing to this merge.

       --ancestry-path
           When given a range of commits to display (e.g.  commit1..commit2 or
           commit2 ^commit1), only display commits that exist directly on the
           ancestry chain between the commit1 and commit2, i.e. commits that
           are both descendants of commit1, and ancestors of commit2.

       A more detailed explanation follows.

       Suppose you specified foo as the <paths>. We shall call commits that
       modify foo !TREESAME, and the rest TREESAME. (In a diff filtered for
       foo, they look different and equal, respectively.)

       In the following, we will always refer to the same example history to
       illustrate the differences between simplification settings. We assume
       that you are filtering for a file foo in this commit graph:

                     .-A---M---N---O---P---Q
                    /     /   /   /   /   /
                   I     B   C   D   E   Y
                    \   /   /   /   /   /
                     `-------------'   X


       The horizontal line of history A---Q is taken to be the first parent of
       each merge. The commits are:

       o   I is the initial commit, in which foo exists with contents "asdf",
           and a file quux exists with contents "quux". Initial commits are
           compared to an empty tree, so I is !TREESAME.

       o   In A, foo contains just "foo".

       o   B contains the same change as A. Its merge M is trivial and hence
           TREESAME to all parents.

       o   C does not change foo, but its merge N changes it to "foobar", so
           it is not TREESAME to any parent.

       o   D sets foo to "baz". Its merge O combines the strings from N and D
           to "foobarbaz"; i.e., it is not TREESAME to any parent.

       o   E changes quux to "xyzzy", and its merge P combines the strings to
           "quux xyzzy".  P is TREESAME to O, but not to E.

       o   X is an independent root commit that added a new file side, and Y
           modified it.  Y is TREESAME to X. Its merge Q added side to P, and
           Q is TREESAME to P, but not to Y.

       rev-list walks backwards through history, including or excluding
       commits based on whether --full-history and/or parent rewriting (via
       --parents or --children) are used. The following settings are
       available.

       Default mode
           Commits are included if they are not TREESAME to any parent (though
           this can be changed, see --sparse below). If the commit was a
           merge, and it was TREESAME to one parent, follow only that parent.
           (Even if there are several TREESAME parents, follow only one of
           them.) Otherwise, follow all parents.

           This results in:

                         .-A---N---O
                        /     /   /
                       I---------D

           Note how the rule to only follow the TREESAME parent, if one is
           available, removed B from consideration entirely.  C was considered
           via N, but is TREESAME. Root commits are compared to an empty tree,
           so I is !TREESAME.

           Parent/child relations are only visible with --parents, but that
           does not affect the commits selected in default mode, so we have
           shown the parent lines.

       --full-history without parent rewriting
           This mode differs from the default in one point: always follow all
           parents of a merge, even if it is TREESAME to one of them. Even if
           more than one side of the merge has commits that are included, this
           does not imply that the merge itself is! In the example, we get

                       I  A  B  N  D  O  P  Q

           M was excluded because it is TREESAME to both parents.  E, C and B
           were all walked, but only B was !TREESAME, so the others do not
           appear.

           Note that without parent rewriting, it is not really possible to
           talk about the parent/child relationships between the commits, so
           we show them disconnected.

       --full-history with parent rewriting
           Ordinary commits are only included if they are !TREESAME (though
           this can be changed, see --sparse below).

           Merges are always included. However, their parent list is
           rewritten: Along each parent, prune away commits that are not
           included themselves. This results in

                         .-A---M---N---O---P---Q
                        /     /   /   /   /
                       I     B   /   D   /
                        \   /   /   /   /
                         `-------------'

           Compare to --full-history without rewriting above. Note that E was
           pruned away because it is TREESAME, but the parent list of P was
           rewritten to contain E's parent I. The same happened for C and N,
           and X, Y and Q.

       In addition to the above settings, you can change whether TREESAME
       affects inclusion:

       --dense
           Commits that are walked are included if they are not TREESAME to
           any parent.

       --sparse
           All commits that are walked are included.

           Note that without --full-history, this still simplifies merges: if
           one of the parents is TREESAME, we follow only that one, so the
           other sides of the merge are never walked.

       --simplify-merges
           First, build a history graph in the same way that --full-history
           with parent rewriting does (see above).

           Then simplify each commit C to its replacement C' in the final
           history according to the following rules:

           o   Set C' to C.

           o   Replace each parent P of C' with its simplification P'. In the
               process, drop parents that are ancestors of other parents or
               that are root commits TREESAME to an empty tree, and remove
               duplicates, but take care to never drop all parents that we are
               TREESAME to.

           o   If after this parent rewriting, C' is a root or merge commit
               (has zero or >1 parents), a boundary commit, or !TREESAME, it
               remains. Otherwise, it is replaced with its only parent.

           The effect of this is best shown by way of comparing to
           --full-history with parent rewriting. The example turns into:

                         .-A---M---N---O
                        /     /       /
                       I     B       D
                        \   /       /
                         `---------'

           Note the major differences in N, P, and Q over --full-history:

           o   N's parent list had I removed, because it is an ancestor of the
               other parent M. Still, N remained because it is !TREESAME.

           o   P's parent list similarly had I removed.  P was then removed
               completely, because it had one parent and is TREESAME.

           o   Q's parent list had Y simplified to X.  X was then removed,
               because it was a TREESAME root.  Q was then removed completely,
               because it had one parent and is TREESAME.

       There is another simplification mode available:

       --ancestry-path
           Limit the displayed commits to those directly on the ancestry chain
           between the "from" and "to" commits in the given commit range. I.e.
           only display commits that are ancestor of the "to" commit and
           descendants of the "from" commit.

           As an example use case, consider the following commit history:

                           D---E-------F
                          /     \       \
                         B---C---G---H---I---J
                        /                     \
                       A-------K---------------L--M

           A regular D..M computes the set of commits that are ancestors of M,
           but excludes the ones that are ancestors of D. This is useful to
           see what happened to the history leading to M since D, in the sense
           that "what does M have that did not exist in D". The result in this
           example would be all the commits, except A and B (and D itself, of
           course).

           When we want to find out what commits in M are contaminated with
           the bug introduced by D and need fixing, however, we might want to
           view only the subset of D..M that are actually descendants of D,
           i.e. excluding C and K. This is exactly what the --ancestry-path
           option does. Applied to the D..M range, it results in:

                               E-------F
                                \       \
                                 G---H---I---J
                                              \
                                               L--M


       Before discussing another option, --show-pulls, we need to create a new
       example history.

       A common problem users face when looking at simplified history is that
       a commit they know changed a file somehow does not appear in the file's
       simplified history. Let's demonstrate a new example and show how
       options such as --full-history and --simplify-merges works in that
       case:

                     .-A---M-----C--N---O---P
                    /     / \  \  \/   /   /
                   I     B   \  R-'`-Z'   /
                    \   /     \/         /
                     \ /      /\        /
                      `---X--'  `---Y--'


       For this example, suppose I created file.txt which was modified by A,
       B, and X in different ways. The single-parent commits C, Z, and Y do
       not change file.txt. The merge commit M was created by resolving the
       merge conflict to include both changes from A and B and hence is not
       TREESAME to either. The merge commit R, however, was created by
       ignoring the contents of file.txt at M and taking only the contents of
       file.txt at X. Hence, R is TREESAME to X but not M. Finally, the
       natural merge resolution to create N is to take the contents of
       file.txt at R, so N is TREESAME to R but not C. The merge commits O and
       P are TREESAME to their first parents, but not to their second parents,
       Z and Y respectively.

       When using the default mode, N and R both have a TREESAME parent, so
       those edges are walked and the others are ignored. The resulting
       history graph is:

                   I---X


       When using --full-history, Git walks every edge. This will discover the
       commits A and B and the merge M, but also will reveal the merge commits
       O and P. With parent rewriting, the resulting graph is:

                     .-A---M--------N---O---P
                    /     / \  \  \/   /   /
                   I     B   \  R-'`--'   /
                    \   /     \/         /
                     \ /      /\        /
                      `---X--'  `------'


       Here, the merge commits O and P contribute extra noise, as they did not
       actually contribute a change to file.txt. They only merged a topic that
       was based on an older version of file.txt. This is a common issue in
       repositories using a workflow where many contributors work in parallel
       and merge their topic branches along a single trunk: manu unrelated
       merges appear in the --full-history results.

       When using the --simplify-merges option, the commits O and P disappear
       from the results. This is because the rewritten second parents of O and
       P are reachable from their first parents. Those edges are removed and
       then the commits look like single-parent commits that are TREESAME to
       their parent. This also happens to the commit N, resulting in a history
       view as follows:

                     .-A---M--.
                    /     /    \
                   I     B      R
                    \   /      /
                     \ /      /
                      `---X--'


       In this view, we see all of the important single-parent changes from A,
       B, and X. We also see the carefully-resolved merge M and the
       not-so-carefully-resolved merge R. This is usually enough information
       to determine why the commits A and B "disappeared" from history in the
       default view. However, there are a few issues with this approach.

       The first issue is performance. Unlike any previous option, the
       --simplify-merges option requires walking the entire commit history
       before returning a single result. This can make the option difficult to
       use for very large repositories.

       The second issue is one of auditing. When many contributors are working
       on the same repository, it is important which merge commits introduced
       a change into an important branch. The problematic merge R above is not
       likely to be the merge commit that was used to merge into an important
       branch. Instead, the merge N was used to merge R and X into the
       important branch. This commit may have information about why the change
       X came to override the changes from A and B in its commit message.

       --show-pulls
           In addition to the commits shown in the default history, show each
           merge commit that is not TREESAME to its first parent but is
           TREESAME to a later parent.

           When a merge commit is included by --show-pulls, the merge is
           treated as if it "pulled" the change from another branch. When
           using --show-pulls on this example (and no other options) the
           resulting graph is:

                       I---X---R---N

           Here, the merge commits R and N are included because they pulled
           the commits X and R into the base branch, respectively. These
           merges are the reason the commits A and B do not appear in the
           default history.

           When --show-pulls is paired with --simplify-merges, the graph
           includes all of the necessary information:

                         .-A---M--.   N
                        /     /    \ /
                       I     B      R
                        \   /      /
                         \ /      /
                          `---X--'

           Notice that since M is reachable from R, the edge from N to M was
           simplified away. However, N still appears in the history as an
           important commit because it "pulled" the change R into the main
           branch.

       The --simplify-by-decoration option allows you to view only the big
       picture of the topology of the history, by omitting commits that are
       not referenced by tags. Commits are marked as !TREESAME (in other
       words, kept after history simplification rules described above) if (1)
       they are referenced by tags, or (2) they change the contents of the
       paths given on the command line. All other commits are marked as
       TREESAME (subject to be simplified away).

   Commit Ordering
       By default, the commits are shown in reverse chronological order.

       --date-order
           Show no parents before all of its children are shown, but otherwise
           show commits in the commit timestamp order.

       --author-date-order
           Show no parents before all of its children are shown, but otherwise
           show commits in the author timestamp order.

       --topo-order
           Show no parents before all of its children are shown, and avoid
           showing commits on multiple lines of history intermixed.

           For example, in a commit history like this:

                   ---1----2----4----7
                       \              \
                        3----5----6----8---

           where the numbers denote the order of commit timestamps, git
           rev-list and friends with --date-order show the commits in the
           timestamp order: 8 7 6 5 4 3 2 1.

           With --topo-order, they would show 8 6 5 3 7 4 2 1 (or 8 7 4 2 6 5
           3 1); some older commits are shown before newer ones in order to
           avoid showing the commits from two parallel development track mixed
           together.

       --reverse
           Output the commits chosen to be shown (see Commit Limiting section
           above) in reverse order. Cannot be combined with --walk-reflogs.

   Object Traversal
       These options are mostly targeted for packing of Git repositories.

       --no-walk[=(sorted|unsorted)]
           Only show the given commits, but do not traverse their ancestors.
           This has no effect if a range is specified. If the argument
           unsorted is given, the commits are shown in the order they were
           given on the command line. Otherwise (if sorted or no argument was
           given), the commits are shown in reverse chronological order by
           commit time. Cannot be combined with --graph.

       --do-walk
           Overrides a previous --no-walk.

   Commit Formatting
       --pretty[=<format>], --format=<format>
           Pretty-print the contents of the commit logs in a given format,
           where <format> can be one of oneline, short, medium, full, fuller,
           reference, email, raw, format:<string> and tformat:<string>. When
           <format> is none of the above, and has %placeholder in it, it acts
           as if --pretty=tformat:<format> were given.

           See the "PRETTY FORMATS" section for some additional details for
           each format. When =<format> part is omitted, it defaults to medium.

           Note: you can specify the default pretty format in the repository
           configuration (see git-config(1)).

       --abbrev-commit
           Instead of showing the full 40-byte hexadecimal commit object name,
           show a prefix that names the object uniquely. "--abbrev=<n>" (which
           also modifies diff output, if it is displayed) option can be used
           to specify the minimum length of the prefix.

           This should make "--pretty=oneline" a whole lot more readable for
           people using 80-column terminals.

       --no-abbrev-commit
           Show the full 40-byte hexadecimal commit object name. This negates
           --abbrev-commit, either explicit or implied by other options such
           as "--oneline". It also overrides the log.abbrevCommit variable.

       --oneline
           This is a shorthand for "--pretty=oneline --abbrev-commit" used
           together.

       --encoding=<encoding>
           The commit objects record the encoding used for the log message in
           their encoding header; this option can be used to tell the command
           to re-code the commit log message in the encoding preferred by the
           user. For non plumbing commands this defaults to UTF-8. Note that
           if an object claims to be encoded in X and we are outputting in X,
           we will output the object verbatim; this means that invalid
           sequences in the original commit may be copied to the output.

       --expand-tabs=<n>, --expand-tabs, --no-expand-tabs
           Perform a tab expansion (replace each tab with enough spaces to
           fill to the next display column that is multiple of <n>) in the log
           message before showing it in the output.  --expand-tabs is a
           short-hand for --expand-tabs=8, and --no-expand-tabs is a
           short-hand for --expand-tabs=0, which disables tab expansion.

           By default, tabs are expanded in pretty formats that indent the log
           message by 4 spaces (i.e.  medium, which is the default, full, and
           fuller).

       --notes[=<ref>]
           Show the notes (see git-notes(1)) that annotate the commit, when
           showing the commit log message. This is the default for git log,
           git show and git whatchanged commands when there is no --pretty,
           --format, or --oneline option given on the command line.

           By default, the notes shown are from the notes refs listed in the
           core.notesRef and notes.displayRef variables (or corresponding
           environment overrides). See git-config(1) for more details.

           With an optional <ref> argument, use the ref to find the notes to
           display. The ref can specify the full refname when it begins with
           refs/notes/; when it begins with notes/, refs/ and otherwise
           refs/notes/ is prefixed to form a full name of the ref.

           Multiple --notes options can be combined to control which notes are
           being displayed. Examples: "--notes=foo" will show only notes from
           "refs/notes/foo"; "--notes=foo --notes" will show both notes from
           "refs/notes/foo" and from the default notes ref(s).

       --no-notes
           Do not show notes. This negates the above --notes option, by
           resetting the list of notes refs from which notes are shown.
           Options are parsed in the order given on the command line, so e.g.
           "--notes --notes=foo --no-notes --notes=bar" will only show notes
           from "refs/notes/bar".

       --show-notes[=<ref>], --[no-]standard-notes
           These options are deprecated. Use the above --notes/--no-notes
           options instead.

       --show-signature
           Check the validity of a signed commit object by passing the
           signature to gpg --verify and show the output.

       --relative-date
           Synonym for --date=relative.

       --date=<format>
           Only takes effect for dates shown in human-readable format, such as
           when using --pretty.  log.date config variable sets a default value
           for the log command's --date option. By default, dates are shown in
           the original time zone (either committer's or author's). If -local
           is appended to the format (e.g., iso-local), the user's local time
           zone is used instead.

           --date=relative shows dates relative to the current time, e.g. "2
           hours ago". The -local option has no effect for --date=relative.

           --date=local is an alias for --date=default-local.

           --date=iso (or --date=iso8601) shows timestamps in a ISO 8601-like
           format. The differences to the strict ISO 8601 format are:

           o   a space instead of the T date/time delimiter

           o   a space between time and time zone

           o   no colon between hours and minutes of the time zone

           --date=iso-strict (or --date=iso8601-strict) shows timestamps in
           strict ISO 8601 format.

           --date=rfc (or --date=rfc2822) shows timestamps in RFC 2822 format,
           often found in email messages.

           --date=short shows only the date, but not the time, in YYYY-MM-DD
           format.

           --date=raw shows the date as seconds since the epoch (1970-01-01
           00:00:00 UTC), followed by a space, and then the timezone as an
           offset from UTC (a + or - with four digits; the first two are
           hours, and the second two are minutes). I.e., as if the timestamp
           were formatted with strftime("%s %z")). Note that the -local option
           does not affect the seconds-since-epoch value (which is always
           measured in UTC), but does switch the accompanying timezone value.

           --date=human shows the timezone if the timezone does not match the
           current time-zone, and doesn't print the whole date if that matches
           (ie skip printing year for dates that are "this year", but also
           skip the whole date itself if it's in the last few days and we can
           just say what weekday it was). For older dates the hour and minute
           is also omitted.

           --date=unix shows the date as a Unix epoch timestamp (seconds since
           1970). As with --raw, this is always in UTC and therefore -local
           has no effect.

           --date=format:...  feeds the format ...  to your system strftime,
           except for %z and %Z, which are handled internally. Use
           --date=format:%c to show the date in your system locale's preferred
           format. See the strftime manual for a complete list of format
           placeholders. When using -local, the correct syntax is
           --date=format-local:....

           --date=default is the default format, and is similar to
           --date=rfc2822, with a few exceptions:

           o   there is no comma after the day-of-week

           o   the time zone is omitted when the local time zone is used

       --parents
           Print also the parents of the commit (in the form "commit
           parent..."). Also enables parent rewriting, see History
           Simplification above.

       --children
           Print also the children of the commit (in the form "commit
           child..."). Also enables parent rewriting, see History
           Simplification above.

       --left-right
           Mark which side of a symmetric difference a commit is reachable
           from. Commits from the left side are prefixed with < and those from
           the right with >. If combined with --boundary, those commits are
           prefixed with -.

           For example, if you have this topology:

                            y---b---b  branch B
                           / \ /
                          /   .
                         /   / \
                        o---x---a---a  branch A

           you would get an output like this:

                       $ git rev-list --left-right --boundary --pretty=oneline A...B

                       >bbbbbbb... 3rd on b
                       >bbbbbbb... 2nd on b
                       <aaaaaaa... 3rd on a
                       <aaaaaaa... 2nd on a
                       -yyyyyyy... 1st on b
                       -xxxxxxx... 1st on a


       --graph
           Draw a text-based graphical representation of the commit history on
           the left hand side of the output. This may cause extra lines to be
           printed in between commits, in order for the graph history to be
           drawn properly. Cannot be combined with --no-walk.

           This enables parent rewriting, see History Simplification above.

           This implies the --topo-order option by default, but the
           --date-order option may also be specified.

       --show-linear-break[=<barrier>]
           When --graph is not used, all history branches are flattened which
           can make it hard to see that the two consecutive commits do not
           belong to a linear branch. This option puts a barrier in between
           them in that case. If <barrier> is specified, it is the string that
           will be shown instead of the default one.

PRETTY FORMATS
       If the commit is a merge, and if the pretty-format is not oneline,
       email or raw, an additional line is inserted before the Author: line.
       This line begins with "Merge: " and the hashes of ancestral commits are
       printed, separated by spaces. Note that the listed commits may not
       necessarily be the list of the direct parent commits if you have
       limited your view of history: for example, if you are only interested
       in changes related to a certain directory or file.

       There are several built-in formats, and you can define additional
       formats by setting a pretty.<name> config option to either another
       format name, or a format: string, as described below (see git-
       config(1)). Here are the details of the built-in formats:

       o   oneline

               <hash> <title line>

           This is designed to be as compact as possible.

       o   short

               commit <hash>
               Author: <author>

               <title line>

       o   medium

               commit <hash>
               Author: <author>
               Date:   <author date>

               <title line>

               <full commit message>

       o   full

               commit <hash>
               Author: <author>
               Commit: <committer>

               <title line>

               <full commit message>

       o   fuller

               commit <hash>
               Author:     <author>
               AuthorDate: <author date>
               Commit:     <committer>
               CommitDate: <committer date>

               <title line>

               <full commit message>

       o   reference

               <abbrev hash> (<title line>, <short author date>)

           This format is used to refer to another commit in a commit message
           and is the same as --pretty='format:%C(auto)%h (%s, %ad)'. By
           default, the date is formatted with --date=short unless another
           --date option is explicitly specified. As with any format: with
           format placeholders, its output is not affected by other options
           like --decorate and --walk-reflogs.

       o   email

               From <hash> <date>
               From: <author>
               Date: <author date>
               Subject: [PATCH] <title line>

               <full commit message>

       o   mboxrd

           Like email, but lines in the commit message starting with "From "
           (preceded by zero or more ">") are quoted with ">" so they aren't
           confused as starting a new commit.

       o   raw

           The raw format shows the entire commit exactly as stored in the
           commit object. Notably, the hashes are displayed in full,
           regardless of whether --abbrev or --no-abbrev are used, and parents
           information show the true parent commits, without taking grafts or
           history simplification into account. Note that this format affects
           the way commits are displayed, but not the way the diff is shown
           e.g. with git log --raw. To get full object names in a raw diff
           format, use --no-abbrev.

       o   format:<string>

           The format:<string> format allows you to specify which information
           you want to show. It works a little bit like printf format, with
           the notable exception that you get a newline with %n instead of \n.

           E.g, format:"The author of %h was %an, %ar%nThe title was >>%s<<%n"
           would show something like this:

               The author of fe6e0ee was Junio C Hamano, 23 hours ago
               The title was >>t4119: test autocomputing -p<n> for traditional diff input.<<

           The placeholders are:

           o   Placeholders that expand to a single literal character:

               %n
                   newline

               %%
                   a raw %

               %x00
                   print a byte from a hex code

           o   Placeholders that affect formatting of later placeholders:

               %Cred
                   switch color to red

               %Cgreen
                   switch color to green

               %Cblue
                   switch color to blue

               %Creset
                   reset color

               %C(...)
                   color specification, as described under Values in the
                   "CONFIGURATION FILE" section of git-config(1). By default,
                   colors are shown only when enabled for log output (by
                   color.diff, color.ui, or --color, and respecting the auto
                   settings of the former if we are going to a terminal).
                   %C(auto,...)  is accepted as a historical synonym for the
                   default (e.g., %C(auto,red)). Specifying %C(always,...)
                   will show the colors even when color is not otherwise
                   enabled (though consider just using --color=always to
                   enable color for the whole output, including this format
                   and anything else git might color).  auto alone (i.e.
                   %C(auto)) will turn on auto coloring on the next
                   placeholders until the color is switched again.

               %m
                   left (<), right (>) or boundary (-) mark

               %w([<w>[,<i1>[,<i2>]]])
                   switch line wrapping, like the -w option of git-
                   shortlog(1).

               %<(<N>[,trunc|ltrunc|mtrunc])
                   make the next placeholder take at least N columns, padding
                   spaces on the right if necessary. Optionally truncate at
                   the beginning (ltrunc), the middle (mtrunc) or the end
                   (trunc) if the output is longer than N columns. Note that
                   truncating only works correctly with N >= 2.

               %<|(<N>)
                   make the next placeholder take at least until Nth columns,
                   padding spaces on the right if necessary

               %>(<N>), %>|(<N>)
                   similar to %<(<N>), %<|(<N>) respectively, but padding
                   spaces on the left

               %>>(<N>), %>>|(<N>)
                   similar to %>(<N>), %>|(<N>) respectively, except that if
                   the next placeholder takes more spaces than given and there
                   are spaces on its left, use those spaces

               %><(<N>), %><|(<N>)
                   similar to %<(<N>), %<|(<N>) respectively, but padding both
                   sides (i.e. the text is centered)

           o   Placeholders that expand to information extracted from the
               commit:

               %H
                   commit hash

               %h
                   abbreviated commit hash

               %T
                   tree hash

               %t
                   abbreviated tree hash

               %P
                   parent hashes

               %p
                   abbreviated parent hashes

               %an
                   author name

               %aN
                   author name (respecting .mailmap, see git-shortlog(1) or
                   git-blame(1))

               %ae
                   author email

               %aE
                   author email (respecting .mailmap, see git-shortlog(1) or
                   git-blame(1))

               %al
                   author email local-part (the part before the @ sign)

               %aL
                   author local-part (see %al) respecting .mailmap, see git-
                   shortlog(1) or git-blame(1))

               %ad
                   author date (format respects --date= option)

               %aD
                   author date, RFC2822 style

               %ar
                   author date, relative

               %at
                   author date, UNIX timestamp

               %ai
                   author date, ISO 8601-like format

               %aI
                   author date, strict ISO 8601 format

               %as
                   author date, short format (YYYY-MM-DD)

               %cn
                   committer name

               %cN
                   committer name (respecting .mailmap, see git-shortlog(1) or
                   git-blame(1))

               %ce
                   committer email

               %cE
                   committer email (respecting .mailmap, see git-shortlog(1)
                   or git-blame(1))

               %cl
                   committer email local-part (the part before the @ sign)

               %cL
                   committer local-part (see %cl) respecting .mailmap, see
                   git-shortlog(1) or git-blame(1))

               %cd
                   committer date (format respects --date= option)

               %cD
                   committer date, RFC2822 style

               %cr
                   committer date, relative

               %ct
                   committer date, UNIX timestamp

               %ci
                   committer date, ISO 8601-like format

               %cI
                   committer date, strict ISO 8601 format

               %cs
                   committer date, short format (YYYY-MM-DD)

               %d
                   ref names, like the --decorate option of git-log(1)

               %D
                   ref names without the " (", ")" wrapping.

               %S
                   ref name given on the command line by which the commit was
                   reached (like git log --source), only works with git log

               %e
                   encoding

               %s
                   subject

               %f
                   sanitized subject line, suitable for a filename

               %b
                   body

               %B
                   raw body (unwrapped subject and body)

               %N
                   commit notes

               %GG
                   raw verification message from GPG for a signed commit

               %G?
                   show "G" for a good (valid) signature, "B" for a bad
                   signature, "U" for a good signature with unknown validity,
                   "X" for a good signature that has expired, "Y" for a good
                   signature made by an expired key, "R" for a good signature
                   made by a revoked key, "E" if the signature cannot be
                   checked (e.g. missing key) and "N" for no signature

               %GS
                   show the name of the signer for a signed commit

               %GK
                   show the key used to sign a signed commit

               %GF
                   show the fingerprint of the key used to sign a signed
                   commit

               %GP
                   show the fingerprint of the primary key whose subkey was
                   used to sign a signed commit

               %GT
                   show the trust level for the key used to sign a signed
                   commit

               %gD
                   reflog selector, e.g., refs/stash@{1} or refs/stash@{2
                   minutes ago}; the format follows the rules described for
                   the -g option. The portion before the @ is the refname as
                   given on the command line (so git log -g refs/heads/main
                   would yield refs/heads/main@{0}).

               %gd
                   shortened reflog selector; same as %gD, but the refname
                   portion is shortened for human readability (so
                   refs/heads/main becomes just main).

               %gn
                   reflog identity name

               %gN
                   reflog identity name (respecting .mailmap, see git-
                   shortlog(1) or git-blame(1))

               %ge
                   reflog identity email

               %gE
                   reflog identity email (respecting .mailmap, see git-
                   shortlog(1) or git-blame(1))

               %gs
                   reflog subject

               %(trailers[:options])
                   display the trailers of the body as interpreted by git-
                   interpret-trailers(1). The trailers string may be followed
                   by a colon and zero or more comma-separated options. If any
                   option is provided multiple times the last occurance wins.

                   The boolean options accept an optional value [=<BOOL>]. The
                   values true, false, on, off etc. are all accepted. See the
                   "boolean" sub-section in "EXAMPLES" in git-config(1). If a
                   boolean option is given with no value, it's enabled.

                   o   key=<K>: only show trailers with specified key.
                       Matching is done case-insensitively and trailing colon
                       is optional. If option is given multiple times trailer
                       lines matching any of the keys are shown. This option
                       automatically enables the only option so that
                       non-trailer lines in the trailer block are hidden. If
                       that is not desired it can be disabled with only=false.
                       E.g., %(trailers:key=Reviewed-by) shows trailer lines
                       with key Reviewed-by.

                   o   only[=<BOOL>]: select whether non-trailer lines from
                       the trailer block should be included.

                   o   separator=<SEP>: specify a separator inserted between
                       trailer lines. When this option is not given each
                       trailer line is terminated with a line feed character.
                       The string SEP may contain the literal formatting codes
                       described above. To use comma as separator one must use
                       %x2C as it would otherwise be parsed as next option.
                       E.g., %(trailers:key=Ticket,separator=%x2C ) shows all
                       trailer lines whose key is "Ticket" separated by a
                       comma and a space.

                   o   unfold[=<BOOL>]: make it behave as if
                       interpret-trailer's --unfold option was given. E.g.,
                       %(trailers:only,unfold=true) unfolds and shows all
                       trailer lines.

                   o   keyonly[=<BOOL>]: only show the key part of the
                       trailer.

                   o   valueonly[=<BOOL>]: only show the value part of the
                       trailer.

                   o   key_value_separator=<SEP>: specify a separator inserted
                       between trailer lines. When this option is not given
                       each trailer key-value pair is separated by ": ".
                       Otherwise it shares the same semantics as
                       separator=<SEP> above.

           Note
           Some placeholders may depend on other options given to the revision
           traversal engine. For example, the %g* reflog options will insert
           an empty string unless we are traversing reflog entries (e.g., by
           git log -g). The %d and %D placeholders will use the "short"
           decoration format if --decorate was not already provided on the
           command line.

       If you add a + (plus sign) after % of a placeholder, a line-feed is
       inserted immediately before the expansion if and only if the
       placeholder expands to a non-empty string.

       If you add a - (minus sign) after % of a placeholder, all consecutive
       line-feeds immediately preceding the expansion are deleted if and only
       if the placeholder expands to an empty string.

       If you add a ` ` (space) after % of a placeholder, a space is inserted
       immediately before the expansion if and only if the placeholder expands
       to a non-empty string.

       o   tformat:

           The tformat: format works exactly like format:, except that it
           provides "terminator" semantics instead of "separator" semantics.
           In other words, each commit has the message terminator character
           (usually a newline) appended, rather than a separator placed
           between entries. This means that the final entry of a single-line
           format will be properly terminated with a new line, just as the
           "oneline" format does. For example:

               $ git log -2 --pretty=format:%h 4da45bef \
                 | perl -pe '$_ .= " -- NO NEWLINE\n" unless /\n/'
               4da45be
               7134973 -- NO NEWLINE

               $ git log -2 --pretty=tformat:%h 4da45bef \
                 | perl -pe '$_ .= " -- NO NEWLINE\n" unless /\n/'
               4da45be
               7134973

           In addition, any unrecognized string that has a % in it is
           interpreted as if it has tformat: in front of it. For example,
           these two are equivalent:

               $ git log -2 --pretty=tformat:%h 4da45bef
               $ git log -2 --pretty=%h 4da45bef


DIFF FORMATTING
       By default, git log does not generate any diff output. The options
       below can be used to show the changes made by each commit.

       Note that unless one of --diff-merges variants (including short -m, -c,
       and --cc options) is explicitly given, merge commits will not show a
       diff, even if a diff format like --patch is selected, nor will they
       match search options like -S. The exception is when --first-parent is
       in use, in which case first-parent is the default format.

       -p, -u, --patch
           Generate patch (see section on generating patches).

       -s, --no-patch
           Suppress diff output. Useful for commands like git show that show
           the patch by default, or to cancel the effect of --patch.

       --diff-merges=(off|none|first-parent|1|separate|m|combined|c|dense-combined|cc),
       --no-diff-merges
           Specify diff format to be used for merge commits. Default is off
           unless --first-parent is in use, in which case first-parent is the
           default.

           --diff-merges=(off|none), --no-diff-merges
               Disable output of diffs for merge commits. Useful to override
               implied value.

           --diff-merges=first-parent, --diff-merges=1
               This option makes merge commits show the full diff with respect
               to the first parent only.

           --diff-merges=separate, --diff-merges=m, -m
               This makes merge commits show the full diff with respect to
               each of the parents. Separate log entry and diff is generated
               for each parent.  -m doesn't produce any output without -p.

           --diff-merges=combined, --diff-merges=c, -c
               With this option, diff output for a merge commit shows the
               differences from each of the parents to the merge result
               simultaneously instead of showing pairwise diff between a
               parent and the result one at a time. Furthermore, it lists only
               files which were modified from all parents.  -c implies -p.

           --diff-merges=dense-combined, --diff-merges=cc, --cc
               With this option the output produced by --diff-merges=combined
               is further compressed by omitting uninteresting hunks whose
               contents in the parents have only two variants and the merge
               result picks one of them without modification.  --cc implies
               -p.

       --combined-all-paths
           This flag causes combined diffs (used for merge commits) to list
           the name of the file from all parents. It thus only has effect when
           --diff-merges=[dense-]combined is in use, and is likely only useful
           if filename changes are detected (i.e. when either rename or copy
           detection have been requested).

       -U<n>, --unified=<n>
           Generate diffs with <n> lines of context instead of the usual
           three. Implies --patch.

       --output=<file>
           Output to a specific file instead of stdout.

       --output-indicator-new=<char>, --output-indicator-old=<char>,
       --output-indicator-context=<char>
           Specify the character used to indicate new, old or context lines in
           the generated patch. Normally they are +, - and ' ' respectively.

       --raw
           For each commit, show a summary of changes using the raw diff
           format. See the "RAW OUTPUT FORMAT" section of git-diff(1). This is
           different from showing the log itself in raw format, which you can
           achieve with --format=raw.

       --patch-with-raw
           Synonym for -p --raw.

       -t
           Show the tree objects in the diff output.

       --indent-heuristic
           Enable the heuristic that shifts diff hunk boundaries to make
           patches easier to read. This is the default.

       --no-indent-heuristic
           Disable the indent heuristic.

       --minimal
           Spend extra time to make sure the smallest possible diff is
           produced.

       --patience
           Generate a diff using the "patience diff" algorithm.

       --histogram
           Generate a diff using the "histogram diff" algorithm.

       --anchored=<text>
           Generate a diff using the "anchored diff" algorithm.

           This option may be specified more than once.

           If a line exists in both the source and destination, exists only
           once, and starts with this text, this algorithm attempts to prevent
           it from appearing as a deletion or addition in the output. It uses
           the "patience diff" algorithm internally.

       --diff-algorithm={patience|minimal|histogram|myers}
           Choose a diff algorithm. The variants are as follows:

           default, myers
               The basic greedy diff algorithm. Currently, this is the
               default.

           minimal
               Spend extra time to make sure the smallest possible diff is
               produced.

           patience
               Use "patience diff" algorithm when generating patches.

           histogram
               This algorithm extends the patience algorithm to "support
               low-occurrence common elements".

           For instance, if you configured the diff.algorithm variable to a
           non-default value and want to use the default one, then you have to
           use --diff-algorithm=default option.

       --stat[=<width>[,<name-width>[,<count>]]]
           Generate a diffstat. By default, as much space as necessary will be
           used for the filename part, and the rest for the graph part.
           Maximum width defaults to terminal width, or 80 columns if not
           connected to a terminal, and can be overridden by <width>. The
           width of the filename part can be limited by giving another width
           <name-width> after a comma. The width of the graph part can be
           limited by using --stat-graph-width=<width> (affects all commands
           generating a stat graph) or by setting diff.statGraphWidth=<width>
           (does not affect git format-patch). By giving a third parameter
           <count>, you can limit the output to the first <count> lines,
           followed by ...  if there are more.

           These parameters can also be set individually with
           --stat-width=<width>, --stat-name-width=<name-width> and
           --stat-count=<count>.

       --compact-summary
           Output a condensed summary of extended header information such as
           file creations or deletions ("new" or "gone", optionally "+l" if
           it's a symlink) and mode changes ("+x" or "-x" for adding or
           removing executable bit respectively) in diffstat. The information
           is put between the filename part and the graph part. Implies
           --stat.

       --numstat
           Similar to --stat, but shows number of added and deleted lines in
           decimal notation and pathname without abbreviation, to make it more
           machine friendly. For binary files, outputs two - instead of saying
           0 0.

       --shortstat
           Output only the last line of the --stat format containing total
           number of modified files, as well as number of added and deleted
           lines.

       -X[<param1,param2,...>], --dirstat[=<param1,param2,...>]
           Output the distribution of relative amount of changes for each
           sub-directory. The behavior of --dirstat can be customized by
           passing it a comma separated list of parameters. The defaults are
           controlled by the diff.dirstat configuration variable (see git-
           config(1)). The following parameters are available:

           changes
               Compute the dirstat numbers by counting the lines that have
               been removed from the source, or added to the destination. This
               ignores the amount of pure code movements within a file. In
               other words, rearranging lines in a file is not counted as much
               as other changes. This is the default behavior when no
               parameter is given.

           lines
               Compute the dirstat numbers by doing the regular line-based
               diff analysis, and summing the removed/added line counts. (For
               binary files, count 64-byte chunks instead, since binary files
               have no natural concept of lines). This is a more expensive
               --dirstat behavior than the changes behavior, but it does count
               rearranged lines within a file as much as other changes. The
               resulting output is consistent with what you get from the other
               --*stat options.

           files
               Compute the dirstat numbers by counting the number of files
               changed. Each changed file counts equally in the dirstat
               analysis. This is the computationally cheapest --dirstat
               behavior, since it does not have to look at the file contents
               at all.

           cumulative
               Count changes in a child directory for the parent directory as
               well. Note that when using cumulative, the sum of the
               percentages reported may exceed 100%. The default
               (non-cumulative) behavior can be specified with the
               noncumulative parameter.

           <limit>
               An integer parameter specifies a cut-off percent (3% by
               default). Directories contributing less than this percentage of
               the changes are not shown in the output.

           Example: The following will count changed files, while ignoring
           directories with less than 10% of the total amount of changed
           files, and accumulating child directory counts in the parent
           directories: --dirstat=files,10,cumulative.

       --cumulative
           Synonym for --dirstat=cumulative

       --dirstat-by-file[=<param1,param2>...]
           Synonym for --dirstat=files,param1,param2...

       --summary
           Output a condensed summary of extended header information such as
           creations, renames and mode changes.

       --patch-with-stat
           Synonym for -p --stat.

       -z
           Separate the commits with NULs instead of with new newlines.

           Also, when --raw or --numstat has been given, do not munge
           pathnames and use NULs as output field terminators.

           Without this option, pathnames with "unusual" characters are quoted
           as explained for the configuration variable core.quotePath (see
           git-config(1)).

       --name-only
           Show only names of changed files.

       --name-status
           Show only names and status of changed files. See the description of
           the --diff-filter option on what the status letters mean.

       --submodule[=<format>]
           Specify how differences in submodules are shown. When specifying
           --submodule=short the short format is used. This format just shows
           the names of the commits at the beginning and end of the range.
           When --submodule or --submodule=log is specified, the log format is
           used. This format lists the commits in the range like git-
           submodule(1) summary does. When --submodule=diff is specified, the
           diff format is used. This format shows an inline diff of the
           changes in the submodule contents between the commit range.
           Defaults to diff.submodule or the short format if the config option
           is unset.

       --color[=<when>]
           Show colored diff.  --color (i.e. without =<when>) is the same as
           --color=always.  <when> can be one of always, never, or auto.

       --no-color
           Turn off colored diff. It is the same as --color=never.

       --color-moved[=<mode>]
           Moved lines of code are colored differently. The <mode> defaults to
           no if the option is not given and to zebra if the option with no
           mode is given. The mode must be one of:

           no
               Moved lines are not highlighted.

           default
               Is a synonym for zebra. This may change to a more sensible mode
               in the future.

           plain
               Any line that is added in one location and was removed in
               another location will be colored with color.diff.newMoved.
               Similarly color.diff.oldMoved will be used for removed lines
               that are added somewhere else in the diff. This mode picks up
               any moved line, but it is not very useful in a review to
               determine if a block of code was moved without permutation.

           blocks
               Blocks of moved text of at least 20 alphanumeric characters are
               detected greedily. The detected blocks are painted using either
               the color.diff.{old,new}Moved color. Adjacent blocks cannot be
               told apart.

           zebra
               Blocks of moved text are detected as in blocks mode. The blocks
               are painted using either the color.diff.{old,new}Moved color or
               color.diff.{old,new}MovedAlternative. The change between the
               two colors indicates that a new block was detected.

           dimmed-zebra
               Similar to zebra, but additional dimming of uninteresting parts
               of moved code is performed. The bordering lines of two adjacent
               blocks are considered interesting, the rest is uninteresting.
               dimmed_zebra is a deprecated synonym.

       --no-color-moved
           Turn off move detection. This can be used to override configuration
           settings. It is the same as --color-moved=no.

       --color-moved-ws=<modes>
           This configures how whitespace is ignored when performing the move
           detection for --color-moved. These modes can be given as a comma
           separated list:

           no
               Do not ignore whitespace when performing move detection.

           ignore-space-at-eol
               Ignore changes in whitespace at EOL.

           ignore-space-change
               Ignore changes in amount of whitespace. This ignores whitespace
               at line end, and considers all other sequences of one or more
               whitespace characters to be equivalent.

           ignore-all-space
               Ignore whitespace when comparing lines. This ignores
               differences even if one line has whitespace where the other
               line has none.

           allow-indentation-change
               Initially ignore any whitespace in the move detection, then
               group the moved code blocks only into a block if the change in
               whitespace is the same per line. This is incompatible with the
               other modes.

       --no-color-moved-ws
           Do not ignore whitespace when performing move detection. This can
           be used to override configuration settings. It is the same as
           --color-moved-ws=no.

       --word-diff[=<mode>]
           Show a word diff, using the <mode> to delimit changed words. By
           default, words are delimited by whitespace; see --word-diff-regex
           below. The <mode> defaults to plain, and must be one of:

           color
               Highlight changed words using only colors. Implies --color.

           plain
               Show words as [-removed-] and {+added+}. Makes no attempts to
               escape the delimiters if they appear in the input, so the
               output may be ambiguous.

           porcelain
               Use a special line-based format intended for script
               consumption. Added/removed/unchanged runs are printed in the
               usual unified diff format, starting with a +/-/` ` character at
               the beginning of the line and extending to the end of the line.
               Newlines in the input are represented by a tilde ~ on a line of
               its own.

           none
               Disable word diff again.

           Note that despite the name of the first mode, color is used to
           highlight the changed parts in all modes if enabled.

       --word-diff-regex=<regex>
           Use <regex> to decide what a word is, instead of considering runs
           of non-whitespace to be a word. Also implies --word-diff unless it
           was already enabled.

           Every non-overlapping match of the <regex> is considered a word.
           Anything between these matches is considered whitespace and
           ignored(!) for the purposes of finding differences. You may want to
           append |[^[:space:]] to your regular expression to make sure that
           it matches all non-whitespace characters. A match that contains a
           newline is silently truncated(!) at the newline.

           For example, --word-diff-regex=.  will treat each character as a
           word and, correspondingly, show differences character by character.

           The regex can also be set via a diff driver or configuration
           option, see gitattributes(5) or git-config(1). Giving it explicitly
           overrides any diff driver or configuration setting. Diff drivers
           override configuration settings.

       --color-words[=<regex>]
           Equivalent to --word-diff=color plus (if a regex was specified)
           --word-diff-regex=<regex>.

       --no-renames
           Turn off rename detection, even when the configuration file gives
           the default to do so.

       --[no-]rename-empty
           Whether to use empty blobs as rename source.

       --check
           Warn if changes introduce conflict markers or whitespace errors.
           What are considered whitespace errors is controlled by
           core.whitespace configuration. By default, trailing whitespaces
           (including lines that consist solely of whitespaces) and a space
           character that is immediately followed by a tab character inside
           the initial indent of the line are considered whitespace errors.
           Exits with non-zero status if problems are found. Not compatible
           with --exit-code.

       --ws-error-highlight=<kind>
           Highlight whitespace errors in the context, old or new lines of the
           diff. Multiple values are separated by comma, none resets previous
           values, default reset the list to new and all is a shorthand for
           old,new,context. When this option is not given, and the
           configuration variable diff.wsErrorHighlight is not set, only
           whitespace errors in new lines are highlighted. The whitespace
           errors are colored with color.diff.whitespace.

       --full-index
           Instead of the first handful of characters, show the full pre- and
           post-image blob object names on the "index" line when generating
           patch format output.

       --binary
           In addition to --full-index, output a binary diff that can be
           applied with git-apply. Implies --patch.

       --abbrev[=<n>]
           Instead of showing the full 40-byte hexadecimal object name in
           diff-raw format output and diff-tree header lines, show the
           shortest prefix that is at least <n> hexdigits long that uniquely
           refers the object. In diff-patch output format, --full-index takes
           higher precedence, i.e. if --full-index is specified, full blob
           names will be shown regardless of --abbrev. Non default number of
           digits can be specified with --abbrev=<n>.

       -B[<n>][/<m>], --break-rewrites[=[<n>][/<m>]]
           Break complete rewrite changes into pairs of delete and create.
           This serves two purposes:

           It affects the way a change that amounts to a total rewrite of a
           file not as a series of deletion and insertion mixed together with
           a very few lines that happen to match textually as the context, but
           as a single deletion of everything old followed by a single
           insertion of everything new, and the number m controls this aspect
           of the -B option (defaults to 60%).  -B/70% specifies that less
           than 30% of the original should remain in the result for Git to
           consider it a total rewrite (i.e. otherwise the resulting patch
           will be a series of deletion and insertion mixed together with
           context lines).

           When used with -M, a totally-rewritten file is also considered as
           the source of a rename (usually -M only considers a file that
           disappeared as the source of a rename), and the number n controls
           this aspect of the -B option (defaults to 50%).  -B20% specifies
           that a change with addition and deletion compared to 20% or more of
           the file's size are eligible for being picked up as a possible
           source of a rename to another file.

       -M[<n>], --find-renames[=<n>]
           If generating diffs, detect and report renames for each commit. For
           following files across renames while traversing history, see
           --follow. If n is specified, it is a threshold on the similarity
           index (i.e. amount of addition/deletions compared to the file's
           size). For example, -M90% means Git should consider a delete/add
           pair to be a rename if more than 90% of the file hasn't changed.
           Without a % sign, the number is to be read as a fraction, with a
           decimal point before it. I.e., -M5 becomes 0.5, and is thus the
           same as -M50%. Similarly, -M05 is the same as -M5%. To limit
           detection to exact renames, use -M100%. The default similarity
           index is 50%.

       -C[<n>], --find-copies[=<n>]
           Detect copies as well as renames. See also --find-copies-harder. If
           n is specified, it has the same meaning as for -M<n>.

       --find-copies-harder
           For performance reasons, by default, -C option finds copies only if
           the original file of the copy was modified in the same changeset.
           This flag makes the command inspect unmodified files as candidates
           for the source of copy. This is a very expensive operation for
           large projects, so use it with caution. Giving more than one -C
           option has the same effect.

       -D, --irreversible-delete
           Omit the preimage for deletes, i.e. print only the header but not
           the diff between the preimage and /dev/null. The resulting patch is
           not meant to be applied with patch or git apply; this is solely for
           people who want to just concentrate on reviewing the text after the
           change. In addition, the output obviously lacks enough information
           to apply such a patch in reverse, even manually, hence the name of
           the option.

           When used together with -B, omit also the preimage in the deletion
           part of a delete/create pair.

       -l<num>
           The -M and -C options require O(n^2) processing time where n is the
           number of potential rename/copy targets. This option prevents
           rename/copy detection from running if the number of rename/copy
           targets exceeds the specified number.

       --diff-filter=[(A|C|D|M|R|T|U|X|B)...[*]]
           Select only files that are Added (A), Copied (C), Deleted (D),
           Modified (M), Renamed (R), have their type (i.e. regular file,
           symlink, submodule, ...) changed (T), are Unmerged (U), are Unknown
           (X), or have had their pairing Broken (B). Any combination of the
           filter characters (including none) can be used. When *
           (All-or-none) is added to the combination, all paths are selected
           if there is any file that matches other criteria in the comparison;
           if there is no file that matches other criteria, nothing is
           selected.

           Also, these upper-case letters can be downcased to exclude. E.g.
           --diff-filter=ad excludes added and deleted paths.

           Note that not all diffs can feature all types. For instance, diffs
           from the index to the working tree can never have Added entries
           (because the set of paths included in the diff is limited by what
           is in the index). Similarly, copied and renamed entries cannot
           appear if detection for those types is disabled.

       -S<string>
           Look for differences that change the number of occurrences of the
           specified string (i.e. addition/deletion) in a file. Intended for
           the scripter's use.

           It is useful when you're looking for an exact block of code (like a
           struct), and want to know the history of that block since it first
           came into being: use the feature iteratively to feed the
           interesting block in the preimage back into -S, and keep going
           until you get the very first version of the block.

           Binary files are searched as well.

       -G<regex>
           Look for differences whose patch text contains added/removed lines
           that match <regex>.

           To illustrate the difference between -S<regex> --pickaxe-regex and
           -G<regex>, consider a commit with the following diff in the same
           file:

               +    return frotz(nitfol, two->ptr, 1, 0);
               ...
               -    hit = frotz(nitfol, mf2.ptr, 1, 0);

           While git log -G"frotz\(nitfol" will show this commit, git log
           -S"frotz\(nitfol" --pickaxe-regex will not (because the number of
           occurrences of that string did not change).

           Unless --text is supplied patches of binary files without a
           textconv filter will be ignored.

           See the pickaxe entry in gitdiffcore(7) for more information.

       --find-object=<object-id>
           Look for differences that change the number of occurrences of the
           specified object. Similar to -S, just the argument is different in
           that it doesn't search for a specific string but for a specific
           object id.

           The object can be a blob or a submodule commit. It implies the -t
           option in git-log to also find trees.

       --pickaxe-all
           When -S or -G finds a change, show all the changes in that
           changeset, not just the files that contain the change in <string>.

       --pickaxe-regex
           Treat the <string> given to -S as an extended POSIX regular
           expression to match.

       -O<orderfile>
           Control the order in which files appear in the output. This
           overrides the diff.orderFile configuration variable (see git-
           config(1)). To cancel diff.orderFile, use -O/dev/null.

           The output order is determined by the order of glob patterns in
           <orderfile>. All files with pathnames that match the first pattern
           are output first, all files with pathnames that match the second
           pattern (but not the first) are output next, and so on. All files
           with pathnames that do not match any pattern are output last, as if
           there was an implicit match-all pattern at the end of the file. If
           multiple pathnames have the same rank (they match the same pattern
           but no earlier patterns), their output order relative to each other
           is the normal order.

           <orderfile> is parsed as follows:

           o   Blank lines are ignored, so they can be used as separators for
               readability.

           o   Lines starting with a hash ("#") are ignored, so they can be
               used for comments. Add a backslash ("\") to the beginning of
               the pattern if it starts with a hash.

           o   Each other line contains a single pattern.

           Patterns have the same syntax and semantics as patterns used for
           fnmatch(3) without the FNM_PATHNAME flag, except a pathname also
           matches a pattern if removing any number of the final pathname
           components matches the pattern. For example, the pattern "foo*bar"
           matches "fooasdfbar" and "foo/bar/baz/asdf" but not "foobarx".

       -R
           Swap two inputs; that is, show differences from index or on-disk
           file to tree contents.

       --relative[=<path>], --no-relative
           When run from a subdirectory of the project, it can be told to
           exclude changes outside the directory and show pathnames relative
           to it with this option. When you are not in a subdirectory (e.g. in
           a bare repository), you can name which subdirectory to make the
           output relative to by giving a <path> as an argument.
           --no-relative can be used to countermand both diff.relative config
           option and previous --relative.

       -a, --text
           Treat all files as text.

       --ignore-cr-at-eol
           Ignore carriage-return at the end of line when doing a comparison.

       --ignore-space-at-eol
           Ignore changes in whitespace at EOL.

       -b, --ignore-space-change
           Ignore changes in amount of whitespace. This ignores whitespace at
           line end, and considers all other sequences of one or more
           whitespace characters to be equivalent.

       -w, --ignore-all-space
           Ignore whitespace when comparing lines. This ignores differences
           even if one line has whitespace where the other line has none.

       --ignore-blank-lines
           Ignore changes whose lines are all blank.

       -I<regex>, --ignore-matching-lines=<regex>
           Ignore changes whose all lines match <regex>. This option may be
           specified more than once.

       --inter-hunk-context=<lines>
           Show the context between diff hunks, up to the specified number of
           lines, thereby fusing hunks that are close to each other. Defaults
           to diff.interHunkContext or 0 if the config option is unset.

       -W, --function-context
           Show whole function as context lines for each change. The function
           names are determined in the same way as git diff works out patch
           hunk headers (see Defining a custom hunk-header in
           gitattributes(5)).

       --ext-diff
           Allow an external diff helper to be executed. If you set an
           external diff driver with gitattributes(5), you need to use this
           option with git-log(1) and friends.

       --no-ext-diff
           Disallow external diff drivers.

       --textconv, --no-textconv
           Allow (or disallow) external text conversion filters to be run when
           comparing binary files. See gitattributes(5) for details. Because
           textconv filters are typically a one-way conversion, the resulting
           diff is suitable for human consumption, but cannot be applied. For
           this reason, textconv filters are enabled by default only for git-
           diff(1) and git-log(1), but not for git-format-patch(1) or diff
           plumbing commands.

       --ignore-submodules[=<when>]
           Ignore changes to submodules in the diff generation. <when> can be
           either "none", "untracked", "dirty" or "all", which is the default.
           Using "none" will consider the submodule modified when it either
           contains untracked or modified files or its HEAD differs from the
           commit recorded in the superproject and can be used to override any
           settings of the ignore option in git-config(1) or gitmodules(5).
           When "untracked" is used submodules are not considered dirty when
           they only contain untracked content (but they are still scanned for
           modified content). Using "dirty" ignores all changes to the work
           tree of submodules, only changes to the commits stored in the
           superproject are shown (this was the behavior until 1.7.0). Using
           "all" hides all changes to submodules.

       --src-prefix=<prefix>
           Show the given source prefix instead of "a/".

       --dst-prefix=<prefix>
           Show the given destination prefix instead of "b/".

       --no-prefix
           Do not show any source or destination prefix.

       --line-prefix=<prefix>
           Prepend an additional prefix to every line of output.

       --ita-invisible-in-index
           By default entries added by "git add -N" appear as an existing
           empty file in "git diff" and a new file in "git diff --cached".
           This option makes the entry appear as a new file in "git diff" and
           non-existent in "git diff --cached". This option could be reverted
           with --ita-visible-in-index. Both options are experimental and
           could be removed in future.

       For more detailed explanation on these common options, see also
       gitdiffcore(7).

GENERATING PATCH TEXT WITH -P
       Running git-diff(1), git-log(1), git-show(1), git-diff-index(1), git-
       diff-tree(1), or git-diff-files(1) with the -p option produces patch
       text. You can customize the creation of patch text via the
       GIT_EXTERNAL_DIFF and the GIT_DIFF_OPTS environment variables (see
       git(1)).

       What the -p option produces is slightly different from the traditional
       diff format:

        1. It is preceded with a "git diff" header that looks like this:

               diff --git a/file1 b/file2

           The a/ and b/ filenames are the same unless rename/copy is
           involved. Especially, even for a creation or a deletion, /dev/null
           is not used in place of the a/ or b/ filenames.

           When rename/copy is involved, file1 and file2 show the name of the
           source file of the rename/copy and the name of the file that
           rename/copy produces, respectively.

        2. It is followed by one or more extended header lines:

               old mode <mode>
               new mode <mode>
               deleted file mode <mode>
               new file mode <mode>
               copy from <path>
               copy to <path>
               rename from <path>
               rename to <path>
               similarity index <number>
               dissimilarity index <number>
               index <hash>..<hash> <mode>

           File modes are printed as 6-digit octal numbers including the file
           type and file permission bits.

           Path names in extended headers do not include the a/ and b/
           prefixes.

           The similarity index is the percentage of unchanged lines, and the
           dissimilarity index is the percentage of changed lines. It is a
           rounded down integer, followed by a percent sign. The similarity
           index value of 100% is thus reserved for two equal files, while
           100% dissimilarity means that no line from the old file made it
           into the new one.

           The index line includes the blob object names before and after the
           change. The <mode> is included if the file mode does not change;
           otherwise, separate lines indicate the old and the new mode.

        3. Pathnames with "unusual" characters are quoted as explained for the
           configuration variable core.quotePath (see git-config(1)).

        4. All the file1 files in the output refer to files before the commit,
           and all the file2 files refer to files after the commit. It is
           incorrect to apply each change to each file sequentially. For
           example, this patch will swap a and b:

               diff --git a/a b/b
               rename from a
               rename to b
               diff --git a/b b/a
               rename from b
               rename to a

COMBINED DIFF FORMAT
       Any diff-generating command can take the -c or --cc option to produce a
       combined diff when showing a merge. This is the default format when
       showing merges with git-diff(1) or git-show(1). Note also that you can
       give suitable --diff-merges option to any of these commands to force
       generation of diffs in specific format.

       A "combined diff" format looks like this:

           diff --combined describe.c
           index fabadb8,cc95eb0..4866510
           --- a/describe.c
           +++ b/describe.c
           @@@ -98,20 -98,12 +98,20 @@@
                   return (a_date > b_date) ? -1 : (a_date == b_date) ? 0 : 1;
             }

           - static void describe(char *arg)
            -static void describe(struct commit *cmit, int last_one)
           ++static void describe(char *arg, int last_one)
             {
            +      unsigned char sha1[20];
            +      struct commit *cmit;
                   struct commit_list *list;
                   static int initialized = 0;
                   struct commit_name *n;

            +      if (get_sha1(arg, sha1) < 0)
            +              usage(describe_usage);
            +      cmit = lookup_commit_reference(sha1);
            +      if (!cmit)
            +              usage(describe_usage);
            +
                   if (!initialized) {
                           initialized = 1;
                           for_each_ref(get_name);



        1. It is preceded with a "git diff" header, that looks like this (when
           the -c option is used):

               diff --combined file

           or like this (when the --cc option is used):

               diff --cc file

        2. It is followed by one or more extended header lines (this example
           shows a merge with two parents):

               index <hash>,<hash>..<hash>
               mode <mode>,<mode>..<mode>
               new file mode <mode>
               deleted file mode <mode>,<mode>

           The mode <mode>,<mode>..<mode> line appears only if at least one of
           the <mode> is different from the rest. Extended headers with
           information about detected contents movement (renames and copying
           detection) are designed to work with diff of two <tree-ish> and are
           not used by combined diff format.

        3. It is followed by two-line from-file/to-file header

               --- a/file
               +++ b/file

           Similar to two-line header for traditional unified diff format,
           /dev/null is used to signal created or deleted files.

           However, if the --combined-all-paths option is provided, instead of
           a two-line from-file/to-file you get a N+1 line from-file/to-file
           header, where N is the number of parents in the merge commit

               --- a/file
               --- a/file
               --- a/file
               +++ b/file

           This extended format can be useful if rename or copy detection is
           active, to allow you to see the original name of the file in
           different parents.

        4. Chunk header format is modified to prevent people from accidentally
           feeding it to patch -p1. Combined diff format was created for
           review of merge commit changes, and was not meant to be applied.
           The change is similar to the change in the extended index header:

               @@@ <from-file-range> <from-file-range> <to-file-range> @@@

           There are (number of parents + 1) @ characters in the chunk header
           for combined diff format.

       Unlike the traditional unified diff format, which shows two files A and
       B with a single column that has - (minus -- appears in A but removed in
       B), + (plus -- missing in A but added to B), or " " (space --
       unchanged) prefix, this format compares two or more files file1,
       file2,... with one file X, and shows how X differs from each of fileN.
       One column for each of fileN is prepended to the output line to note
       how X's line is different from it.

       A - character in the column N means that the line appears in fileN but
       it does not appear in the result. A + character in the column N means
       that the line appears in the result, and fileN does not have that line
       (in other words, the line was added, from the point of view of that
       parent).

       In the above example output, the function signature was changed from
       both files (hence two - removals from both file1 and file2, plus ++ to
       mean one line that was added does not appear in either file1 or file2).
       Also eight other lines are the same from file1 but do not appear in
       file2 (hence prefixed with +).

       When shown by git diff-tree -c, it compares the parents of a merge
       commit with the merge result (i.e. file1..fileN are the parents). When
       shown by git diff-files -c, it compares the two unresolved merge
       parents with the working tree file (i.e. file1 is stage 2 aka "our
       version", file2 is stage 3 aka "their version").

EXAMPLES
       git log --no-merges
           Show the whole commit history, but skip any merges

       git log v2.6.12.. include/scsi drivers/scsi
           Show all commits since version v2.6.12 that changed any file in the
           include/scsi or drivers/scsi subdirectories

       git log --since="2 weeks ago" -- gitk
           Show the changes during the last two weeks to the file gitk. The --
           is necessary to avoid confusion with the branch named gitk

       git log --name-status release..test
           Show the commits that are in the "test" branch but not yet in the
           "release" branch, along with the list of paths each commit
           modifies.

       git log --follow builtin/rev-list.c
           Shows the commits that changed builtin/rev-list.c, including those
           commits that occurred before the file was given its present name.

       git log --branches --not --remotes=origin
           Shows all commits that are in any of local branches but not in any
           of remote-tracking branches for origin (what you have that origin
           doesn't).

       git log main --not --remotes=*/main
           Shows all commits that are in local main but not in any remote
           repository main branches.

       git log -p -m --first-parent
           Shows the history including change diffs, but only from the "main
           branch" perspective, skipping commits that come from merged
           branches, and showing full diffs of changes introduced by the
           merges. This makes sense only when following a strict policy of
           merging all topic branches when staying on a single integration
           branch.

       git log -L '/int main/',/^}/:main.c
           Shows how the function main() in the file main.c evolved over time.

       git log -3
           Limits the number of commits to show to 3.

DISCUSSION
       Git is to some extent character encoding agnostic.

       o   The contents of the blob objects are uninterpreted sequences of
           bytes. There is no encoding translation at the core level.

       o   Path names are encoded in UTF-8 normalization form C. This applies
           to tree objects, the index file, ref names, as well as path names
           in command line arguments, environment variables and config files
           (.git/config (see git-config(1)), gitignore(5), gitattributes(5)
           and gitmodules(5)).

           Note that Git at the core level treats path names simply as
           sequences of non-NUL bytes, there are no path name encoding
           conversions (except on Mac and Windows). Therefore, using non-ASCII
           path names will mostly work even on platforms and file systems that
           use legacy extended ASCII encodings. However, repositories created
           on such systems will not work properly on UTF-8-based systems (e.g.
           Linux, Mac, Windows) and vice versa. Additionally, many Git-based
           tools simply assume path names to be UTF-8 and will fail to display
           other encodings correctly.

       o   Commit log messages are typically encoded in UTF-8, but other
           extended ASCII encodings are also supported. This includes
           ISO-8859-x, CP125x and many others, but not UTF-16/32, EBCDIC and
           CJK multi-byte encodings (GBK, Shift-JIS, Big5, EUC-x, CP9xx etc.).

       Although we encourage that the commit log messages are encoded in
       UTF-8, both the core and Git Porcelain are designed not to force UTF-8
       on projects. If all participants of a particular project find it more
       convenient to use legacy encodings, Git does not forbid it. However,
       there are a few things to keep in mind.

        1. git commit and git commit-tree issues a warning if the commit log
           message given to it does not look like a valid UTF-8 string, unless
           you explicitly say your project uses a legacy encoding. The way to
           say this is to have i18n.commitencoding in .git/config file, like
           this:

               [i18n]
                       commitEncoding = ISO-8859-1

           Commit objects created with the above setting record the value of
           i18n.commitEncoding in its encoding header. This is to help other
           people who look at them later. Lack of this header implies that the
           commit log message is encoded in UTF-8.

        2. git log, git show, git blame and friends look at the encoding
           header of a commit object, and try to re-code the log message into
           UTF-8 unless otherwise specified. You can specify the desired
           output encoding with i18n.logOutputEncoding in .git/config file,
           like this:

               [i18n]
                       logOutputEncoding = ISO-8859-1

           If you do not have this configuration variable, the value of
           i18n.commitEncoding is used instead.

       Note that we deliberately chose not to re-code the commit log message
       when a commit is made to force UTF-8 at the commit object level,
       because re-coding to UTF-8 is not necessarily a reversible operation.

CONFIGURATION
       See git-config(1) for core variables and git-diff(1) for settings
       related to diff generation.

       format.pretty
           Default for the --format option. (See Pretty Formats above.)
           Defaults to medium.

       i18n.logOutputEncoding
           Encoding to use when displaying logs. (See Discussion above.)
           Defaults to the value of i18n.commitEncoding if set, and UTF-8
           otherwise.

       log.date
           Default format for human-readable dates. (Compare the --date
           option.) Defaults to "default", which means to write dates like Sat
           May 8 19:35:34 2010 -0500.

           If the format is set to "auto:foo" and the pager is in use, format
           "foo" will be the used for the date format. Otherwise "default"
           will be used.

       log.follow
           If true, git log will act as if the --follow option was used when a
           single <path> is given. This has the same limitations as --follow,
           i.e. it cannot be used to follow multiple files and does not work
           well on non-linear history.

       log.showRoot
           If false, git log and related commands will not treat the initial
           commit as a big creation event. Any root commits in git log -p
           output would be shown without a diff attached. The default is true.

       log.showSignature
           If true, git log and related commands will act as if the
           --show-signature option was passed to them.

       mailmap.*
           See git-shortlog(1).

       notes.displayRef
           Which refs, in addition to the default set by core.notesRef or
           GIT_NOTES_REF, to read notes from when showing commit messages with
           the log family of commands. See git-notes(1).

           May be an unabbreviated ref name or a glob and may be specified
           multiple times. A warning will be issued for refs that do not
           exist, but a glob that does not match any refs is silently ignored.

           This setting can be disabled by the --no-notes option, overridden
           by the GIT_NOTES_DISPLAY_REF environment variable, and overridden
           by the --notes=<ref> option.

GIT
       Part of the git(1) suite



Git 2.30.1.378.g1d4f23            02/08/2021                        GIT-LOG(1)
```



## `show`




```
GIT-SHOW(1)                       Git Manual                       GIT-SHOW(1)



NAME
       git-show - さまざまな種類のオブジェクトを表示する

SYNOPSIS
       git show [<options>] [<object>...]


DESCRIPTION
       1つ以上のオブジェクト（ブロブ、ツリー、タグ、およびコミット）を表示します。

       コミットの場合、ログメッセージとテキストの差分が表示されます。
       また、git diff-tree --cc によって生成される特別な形式でマージコミットを示します。

       タグの場合、タグメッセージと参照オブジェクトが表示されます。

       ツリーの場合は、名前が表示されます（--name-only を指定した git ls-tree と同等）。

       プレーンブロブの場合は、プレーンコンテンツが表示されます。
       
       このコマンドは、git diff-tree コマンドに適用可能なオプションを使用して、
       コミットによって導入された変更の表示方法を制御します。

       このマニュアルページでは、最も頻繁に使用されるオプションについてのみ説明します。

OPTIONS
       <object>...
           The names of objects to show (defaults to HEAD). For a more
           complete list of ways to spell object names, see "SPECIFYING
           REVISIONS" section in gitrevisions(7).

       --pretty[=<format>], --format=<format>
           Pretty-print the contents of the commit logs in a given format,
           where <format> can be one of oneline, short, medium, full, fuller,
           reference, email, raw, format:<string> and tformat:<string>. When
           <format> is none of the above, and has %placeholder in it, it acts
           as if --pretty=tformat:<format> were given.

           See the "PRETTY FORMATS" section for some additional details for
           each format. When =<format> part is omitted, it defaults to medium.

           Note: you can specify the default pretty format in the repository
           configuration (see git-config(1)).

       --abbrev-commit
           Instead of showing the full 40-byte hexadecimal commit object name,
           show a prefix that names the object uniquely. "--abbrev=<n>" (which
           also modifies diff output, if it is displayed) option can be used
           to specify the minimum length of the prefix.

           This should make "--pretty=oneline" a whole lot more readable for
           people using 80-column terminals.

       --no-abbrev-commit
           Show the full 40-byte hexadecimal commit object name. This negates
           --abbrev-commit, either explicit or implied by other options such
           as "--oneline". It also overrides the log.abbrevCommit variable.

       --oneline
           This is a shorthand for "--pretty=oneline --abbrev-commit" used
           together.

       --encoding=<encoding>
           The commit objects record the encoding used for the log message in
           their encoding header; this option can be used to tell the command
           to re-code the commit log message in the encoding preferred by the
           user. For non plumbing commands this defaults to UTF-8. Note that
           if an object claims to be encoded in X and we are outputting in X,
           we will output the object verbatim; this means that invalid
           sequences in the original commit may be copied to the output.

       --expand-tabs=<n>, --expand-tabs, --no-expand-tabs
           Perform a tab expansion (replace each tab with enough spaces to
           fill to the next display column that is multiple of <n>) in the log
           message before showing it in the output.  --expand-tabs is a
           short-hand for --expand-tabs=8, and --no-expand-tabs is a
           short-hand for --expand-tabs=0, which disables tab expansion.

           By default, tabs are expanded in pretty formats that indent the log
           message by 4 spaces (i.e.  medium, which is the default, full, and
           fuller).

       --notes[=<ref>]
           Show the notes (see git-notes(1)) that annotate the commit, when
           showing the commit log message. This is the default for git log,
           git show and git whatchanged commands when there is no --pretty,
           --format, or --oneline option given on the command line.

           By default, the notes shown are from the notes refs listed in the
           core.notesRef and notes.displayRef variables (or corresponding
           environment overrides). See git-config(1) for more details.

           With an optional <ref> argument, use the ref to find the notes to
           display. The ref can specify the full refname when it begins with
           refs/notes/; when it begins with notes/, refs/ and otherwise
           refs/notes/ is prefixed to form a full name of the ref.

           Multiple --notes options can be combined to control which notes are
           being displayed. Examples: "--notes=foo" will show only notes from
           "refs/notes/foo"; "--notes=foo --notes" will show both notes from
           "refs/notes/foo" and from the default notes ref(s).

       --no-notes
           Do not show notes. This negates the above --notes option, by
           resetting the list of notes refs from which notes are shown.
           Options are parsed in the order given on the command line, so e.g.
           "--notes --notes=foo --no-notes --notes=bar" will only show notes
           from "refs/notes/bar".

       --show-notes[=<ref>], --[no-]standard-notes
           These options are deprecated. Use the above --notes/--no-notes
           options instead.

       --show-signature
           Check the validity of a signed commit object by passing the
           signature to gpg --verify and show the output.

PRETTY FORMATS
       If the commit is a merge, and if the pretty-format is not oneline,
       email or raw, an additional line is inserted before the Author: line.
       This line begins with "Merge: " and the hashes of ancestral commits are
       printed, separated by spaces. Note that the listed commits may not
       necessarily be the list of the direct parent commits if you have
       limited your view of history: for example, if you are only interested
       in changes related to a certain directory or file.

       There are several built-in formats, and you can define additional
       formats by setting a pretty.<name> config option to either another
       format name, or a format: string, as described below (see git-
       config(1)). Here are the details of the built-in formats:

       o   oneline

               <hash> <title line>

           This is designed to be as compact as possible.

       o   short

               commit <hash>
               Author: <author>

               <title line>

       o   medium

               commit <hash>
               Author: <author>
               Date:   <author date>

               <title line>

               <full commit message>

       o   full

               commit <hash>
               Author: <author>
               Commit: <committer>

               <title line>

               <full commit message>

       o   fuller

               commit <hash>
               Author:     <author>
               AuthorDate: <author date>
               Commit:     <committer>
               CommitDate: <committer date>

               <title line>

               <full commit message>

       o   reference

               <abbrev hash> (<title line>, <short author date>)

           This format is used to refer to another commit in a commit message
           and is the same as --pretty='format:%C(auto)%h (%s, %ad)'. By
           default, the date is formatted with --date=short unless another
           --date option is explicitly specified. As with any format: with
           format placeholders, its output is not affected by other options
           like --decorate and --walk-reflogs.

       o   email

               From <hash> <date>
               From: <author>
               Date: <author date>
               Subject: [PATCH] <title line>

               <full commit message>

       o   mboxrd

           Like email, but lines in the commit message starting with "From "
           (preceded by zero or more ">") are quoted with ">" so they aren't
           confused as starting a new commit.

       o   raw

           The raw format shows the entire commit exactly as stored in the
           commit object. Notably, the hashes are displayed in full,
           regardless of whether --abbrev or --no-abbrev are used, and parents
           information show the true parent commits, without taking grafts or
           history simplification into account. Note that this format affects
           the way commits are displayed, but not the way the diff is shown
           e.g. with git log --raw. To get full object names in a raw diff
           format, use --no-abbrev.

       o   format:<string>

           The format:<string> format allows you to specify which information
           you want to show. It works a little bit like printf format, with
           the notable exception that you get a newline with %n instead of \n.

           E.g, format:"The author of %h was %an, %ar%nThe title was >>%s<<%n"
           would show something like this:

               The author of fe6e0ee was Junio C Hamano, 23 hours ago
               The title was >>t4119: test autocomputing -p<n> for traditional diff input.<<

           The placeholders are:

           o   Placeholders that expand to a single literal character:

               %n
                   newline

               %%
                   a raw %

               %x00
                   print a byte from a hex code

           o   Placeholders that affect formatting of later placeholders:

               %Cred
                   switch color to red

               %Cgreen
                   switch color to green

               %Cblue
                   switch color to blue

               %Creset
                   reset color

               %C(...)
                   color specification, as described under Values in the
                   "CONFIGURATION FILE" section of git-config(1). By default,
                   colors are shown only when enabled for log output (by
                   color.diff, color.ui, or --color, and respecting the auto
                   settings of the former if we are going to a terminal).
                   %C(auto,...)  is accepted as a historical synonym for the
                   default (e.g., %C(auto,red)). Specifying %C(always,...)
                   will show the colors even when color is not otherwise
                   enabled (though consider just using --color=always to
                   enable color for the whole output, including this format
                   and anything else git might color).  auto alone (i.e.
                   %C(auto)) will turn on auto coloring on the next
                   placeholders until the color is switched again.

               %m
                   left (<), right (>) or boundary (-) mark

               %w([<w>[,<i1>[,<i2>]]])
                   switch line wrapping, like the -w option of git-
                   shortlog(1).

               %<(<N>[,trunc|ltrunc|mtrunc])
                   make the next placeholder take at least N columns, padding
                   spaces on the right if necessary. Optionally truncate at
                   the beginning (ltrunc), the middle (mtrunc) or the end
                   (trunc) if the output is longer than N columns. Note that
                   truncating only works correctly with N >= 2.

               %<|(<N>)
                   make the next placeholder take at least until Nth columns,
                   padding spaces on the right if necessary

               %>(<N>), %>|(<N>)
                   similar to %<(<N>), %<|(<N>) respectively, but padding
                   spaces on the left

               %>>(<N>), %>>|(<N>)
                   similar to %>(<N>), %>|(<N>) respectively, except that if
                   the next placeholder takes more spaces than given and there
                   are spaces on its left, use those spaces

               %><(<N>), %><|(<N>)
                   similar to %<(<N>), %<|(<N>) respectively, but padding both
                   sides (i.e. the text is centered)

           o   Placeholders that expand to information extracted from the
               commit:

               %H
                   commit hash

               %h
                   abbreviated commit hash

               %T
                   tree hash

               %t
                   abbreviated tree hash

               %P
                   parent hashes

               %p
                   abbreviated parent hashes

               %an
                   author name

               %aN
                   author name (respecting .mailmap, see git-shortlog(1) or
                   git-blame(1))

               %ae
                   author email

               %aE
                   author email (respecting .mailmap, see git-shortlog(1) or
                   git-blame(1))

               %al
                   author email local-part (the part before the @ sign)

               %aL
                   author local-part (see %al) respecting .mailmap, see git-
                   shortlog(1) or git-blame(1))

               %ad
                   author date (format respects --date= option)

               %aD
                   author date, RFC2822 style

               %ar
                   author date, relative

               %at
                   author date, UNIX timestamp

               %ai
                   author date, ISO 8601-like format

               %aI
                   author date, strict ISO 8601 format

               %as
                   author date, short format (YYYY-MM-DD)

               %cn
                   committer name

               %cN
                   committer name (respecting .mailmap, see git-shortlog(1) or
                   git-blame(1))

               %ce
                   committer email

               %cE
                   committer email (respecting .mailmap, see git-shortlog(1)
                   or git-blame(1))

               %cl
                   committer email local-part (the part before the @ sign)

               %cL
                   committer local-part (see %cl) respecting .mailmap, see
                   git-shortlog(1) or git-blame(1))

               %cd
                   committer date (format respects --date= option)

               %cD
                   committer date, RFC2822 style

               %cr
                   committer date, relative

               %ct
                   committer date, UNIX timestamp

               %ci
                   committer date, ISO 8601-like format

               %cI
                   committer date, strict ISO 8601 format

               %cs
                   committer date, short format (YYYY-MM-DD)

               %d
                   ref names, like the --decorate option of git-log(1)

               %D
                   ref names without the " (", ")" wrapping.

               %S
                   ref name given on the command line by which the commit was
                   reached (like git log --source), only works with git log

               %e
                   encoding

               %s
                   subject

               %f
                   sanitized subject line, suitable for a filename

               %b
                   body

               %B
                   raw body (unwrapped subject and body)

               %N
                   commit notes

               %GG
                   raw verification message from GPG for a signed commit

               %G?
                   show "G" for a good (valid) signature, "B" for a bad
                   signature, "U" for a good signature with unknown validity,
                   "X" for a good signature that has expired, "Y" for a good
                   signature made by an expired key, "R" for a good signature
                   made by a revoked key, "E" if the signature cannot be
                   checked (e.g. missing key) and "N" for no signature

               %GS
                   show the name of the signer for a signed commit

               %GK
                   show the key used to sign a signed commit

               %GF
                   show the fingerprint of the key used to sign a signed
                   commit

               %GP
                   show the fingerprint of the primary key whose subkey was
                   used to sign a signed commit

               %GT
                   show the trust level for the key used to sign a signed
                   commit

               %gD
                   reflog selector, e.g., refs/stash@{1} or refs/stash@{2
                   minutes ago}; the format follows the rules described for
                   the -g option. The portion before the @ is the refname as
                   given on the command line (so git log -g refs/heads/main
                   would yield refs/heads/main@{0}).

               %gd
                   shortened reflog selector; same as %gD, but the refname
                   portion is shortened for human readability (so
                   refs/heads/main becomes just main).

               %gn
                   reflog identity name

               %gN
                   reflog identity name (respecting .mailmap, see git-
                   shortlog(1) or git-blame(1))

               %ge
                   reflog identity email

               %gE
                   reflog identity email (respecting .mailmap, see git-
                   shortlog(1) or git-blame(1))

               %gs
                   reflog subject

               %(trailers[:options])
                   display the trailers of the body as interpreted by git-
                   interpret-trailers(1). The trailers string may be followed
                   by a colon and zero or more comma-separated options. If any
                   option is provided multiple times the last occurance wins.

                   The boolean options accept an optional value [=<BOOL>]. The
                   values true, false, on, off etc. are all accepted. See the
                   "boolean" sub-section in "EXAMPLES" in git-config(1). If a
                   boolean option is given with no value, it's enabled.

                   o   key=<K>: only show trailers with specified key.
                       Matching is done case-insensitively and trailing colon
                       is optional. If option is given multiple times trailer
                       lines matching any of the keys are shown. This option
                       automatically enables the only option so that
                       non-trailer lines in the trailer block are hidden. If
                       that is not desired it can be disabled with only=false.
                       E.g., %(trailers:key=Reviewed-by) shows trailer lines
                       with key Reviewed-by.

                   o   only[=<BOOL>]: select whether non-trailer lines from
                       the trailer block should be included.

                   o   separator=<SEP>: specify a separator inserted between
                       trailer lines. When this option is not given each
                       trailer line is terminated with a line feed character.
                       The string SEP may contain the literal formatting codes
                       described above. To use comma as separator one must use
                       %x2C as it would otherwise be parsed as next option.
                       E.g., %(trailers:key=Ticket,separator=%x2C ) shows all
                       trailer lines whose key is "Ticket" separated by a
                       comma and a space.

                   o   unfold[=<BOOL>]: make it behave as if
                       interpret-trailer's --unfold option was given. E.g.,
                       %(trailers:only,unfold=true) unfolds and shows all
                       trailer lines.

                   o   keyonly[=<BOOL>]: only show the key part of the
                       trailer.

                   o   valueonly[=<BOOL>]: only show the value part of the
                       trailer.

                   o   key_value_separator=<SEP>: specify a separator inserted
                       between trailer lines. When this option is not given
                       each trailer key-value pair is separated by ": ".
                       Otherwise it shares the same semantics as
                       separator=<SEP> above.

           Note
           Some placeholders may depend on other options given to the revision
           traversal engine. For example, the %g* reflog options will insert
           an empty string unless we are traversing reflog entries (e.g., by
           git log -g). The %d and %D placeholders will use the "short"
           decoration format if --decorate was not already provided on the
           command line.

       If you add a + (plus sign) after % of a placeholder, a line-feed is
       inserted immediately before the expansion if and only if the
       placeholder expands to a non-empty string.

       If you add a - (minus sign) after % of a placeholder, all consecutive
       line-feeds immediately preceding the expansion are deleted if and only
       if the placeholder expands to an empty string.

       If you add a ` ` (space) after % of a placeholder, a space is inserted
       immediately before the expansion if and only if the placeholder expands
       to a non-empty string.

       o   tformat:

           The tformat: format works exactly like format:, except that it
           provides "terminator" semantics instead of "separator" semantics.
           In other words, each commit has the message terminator character
           (usually a newline) appended, rather than a separator placed
           between entries. This means that the final entry of a single-line
           format will be properly terminated with a new line, just as the
           "oneline" format does. For example:

               $ git log -2 --pretty=format:%h 4da45bef \
                 | perl -pe '$_ .= " -- NO NEWLINE\n" unless /\n/'
               4da45be
               7134973 -- NO NEWLINE

               $ git log -2 --pretty=tformat:%h 4da45bef \
                 | perl -pe '$_ .= " -- NO NEWLINE\n" unless /\n/'
               4da45be
               7134973

           In addition, any unrecognized string that has a % in it is
           interpreted as if it has tformat: in front of it. For example,
           these two are equivalent:

               $ git log -2 --pretty=tformat:%h 4da45bef
               $ git log -2 --pretty=%h 4da45bef


DIFF FORMATTING
       The options below can be used to change the way git show generates diff
       output.

       -p, -u, --patch
           Generate patch (see section on generating patches).

       -s, --no-patch
           Suppress diff output. Useful for commands like git show that show
           the patch by default, or to cancel the effect of --patch.

       --diff-merges=(off|none|first-parent|1|separate|m|combined|c|dense-combined|cc),
       --no-diff-merges
           Specify diff format to be used for merge commits. Default is
           dense-combined unless --first-parent is in use, in which case
           first-parent is the default.

           --diff-merges=(off|none), --no-diff-merges
               Disable output of diffs for merge commits. Useful to override
               implied value.

           --diff-merges=first-parent, --diff-merges=1
               This option makes merge commits show the full diff with respect
               to the first parent only.

           --diff-merges=separate, --diff-merges=m, -m
               This makes merge commits show the full diff with respect to
               each of the parents. Separate log entry and diff is generated
               for each parent.  -m doesn't produce any output without -p.

           --diff-merges=combined, --diff-merges=c, -c
               With this option, diff output for a merge commit shows the
               differences from each of the parents to the merge result
               simultaneously instead of showing pairwise diff between a
               parent and the result one at a time. Furthermore, it lists only
               files which were modified from all parents.  -c implies -p.

           --diff-merges=dense-combined, --diff-merges=cc, --cc
               With this option the output produced by --diff-merges=combined
               is further compressed by omitting uninteresting hunks whose
               contents in the parents have only two variants and the merge
               result picks one of them without modification.  --cc implies
               -p.

       --combined-all-paths
           This flag causes combined diffs (used for merge commits) to list
           the name of the file from all parents. It thus only has effect when
           --diff-merges=[dense-]combined is in use, and is likely only useful
           if filename changes are detected (i.e. when either rename or copy
           detection have been requested).

       -U<n>, --unified=<n>
           Generate diffs with <n> lines of context instead of the usual
           three. Implies --patch.

       --output=<file>
           Output to a specific file instead of stdout.

       --output-indicator-new=<char>, --output-indicator-old=<char>,
       --output-indicator-context=<char>
           Specify the character used to indicate new, old or context lines in
           the generated patch. Normally they are +, - and ' ' respectively.

       --raw
           For each commit, show a summary of changes using the raw diff
           format. See the "RAW OUTPUT FORMAT" section of git-diff(1). This is
           different from showing the log itself in raw format, which you can
           achieve with --format=raw.

       --patch-with-raw
           Synonym for -p --raw.

       -t
           Show the tree objects in the diff output.

       --indent-heuristic
           Enable the heuristic that shifts diff hunk boundaries to make
           patches easier to read. This is the default.

       --no-indent-heuristic
           Disable the indent heuristic.

       --minimal
           Spend extra time to make sure the smallest possible diff is
           produced.

       --patience
           Generate a diff using the "patience diff" algorithm.

       --histogram
           Generate a diff using the "histogram diff" algorithm.

       --anchored=<text>
           Generate a diff using the "anchored diff" algorithm.

           This option may be specified more than once.

           If a line exists in both the source and destination, exists only
           once, and starts with this text, this algorithm attempts to prevent
           it from appearing as a deletion or addition in the output. It uses
           the "patience diff" algorithm internally.

       --diff-algorithm={patience|minimal|histogram|myers}
           Choose a diff algorithm. The variants are as follows:

           default, myers
               The basic greedy diff algorithm. Currently, this is the
               default.

           minimal
               Spend extra time to make sure the smallest possible diff is
               produced.

           patience
               Use "patience diff" algorithm when generating patches.

           histogram
               This algorithm extends the patience algorithm to "support
               low-occurrence common elements".

           For instance, if you configured the diff.algorithm variable to a
           non-default value and want to use the default one, then you have to
           use --diff-algorithm=default option.

       --stat[=<width>[,<name-width>[,<count>]]]
           Generate a diffstat. By default, as much space as necessary will be
           used for the filename part, and the rest for the graph part.
           Maximum width defaults to terminal width, or 80 columns if not
           connected to a terminal, and can be overridden by <width>. The
           width of the filename part can be limited by giving another width
           <name-width> after a comma. The width of the graph part can be
           limited by using --stat-graph-width=<width> (affects all commands
           generating a stat graph) or by setting diff.statGraphWidth=<width>
           (does not affect git format-patch). By giving a third parameter
           <count>, you can limit the output to the first <count> lines,
           followed by ...  if there are more.

           These parameters can also be set individually with
           --stat-width=<width>, --stat-name-width=<name-width> and
           --stat-count=<count>.

       --compact-summary
           Output a condensed summary of extended header information such as
           file creations or deletions ("new" or "gone", optionally "+l" if
           it's a symlink) and mode changes ("+x" or "-x" for adding or
           removing executable bit respectively) in diffstat. The information
           is put between the filename part and the graph part. Implies
           --stat.

       --numstat
           Similar to --stat, but shows number of added and deleted lines in
           decimal notation and pathname without abbreviation, to make it more
           machine friendly. For binary files, outputs two - instead of saying
           0 0.

       --shortstat
           Output only the last line of the --stat format containing total
           number of modified files, as well as number of added and deleted
           lines.

       -X[<param1,param2,...>], --dirstat[=<param1,param2,...>]
           Output the distribution of relative amount of changes for each
           sub-directory. The behavior of --dirstat can be customized by
           passing it a comma separated list of parameters. The defaults are
           controlled by the diff.dirstat configuration variable (see git-
           config(1)). The following parameters are available:

           changes
               Compute the dirstat numbers by counting the lines that have
               been removed from the source, or added to the destination. This
               ignores the amount of pure code movements within a file. In
               other words, rearranging lines in a file is not counted as much
               as other changes. This is the default behavior when no
               parameter is given.

           lines
               Compute the dirstat numbers by doing the regular line-based
               diff analysis, and summing the removed/added line counts. (For
               binary files, count 64-byte chunks instead, since binary files
               have no natural concept of lines). This is a more expensive
               --dirstat behavior than the changes behavior, but it does count
               rearranged lines within a file as much as other changes. The
               resulting output is consistent with what you get from the other
               --*stat options.

           files
               Compute the dirstat numbers by counting the number of files
               changed. Each changed file counts equally in the dirstat
               analysis. This is the computationally cheapest --dirstat
               behavior, since it does not have to look at the file contents
               at all.

           cumulative
               Count changes in a child directory for the parent directory as
               well. Note that when using cumulative, the sum of the
               percentages reported may exceed 100%. The default
               (non-cumulative) behavior can be specified with the
               noncumulative parameter.

           <limit>
               An integer parameter specifies a cut-off percent (3% by
               default). Directories contributing less than this percentage of
               the changes are not shown in the output.

           Example: The following will count changed files, while ignoring
           directories with less than 10% of the total amount of changed
           files, and accumulating child directory counts in the parent
           directories: --dirstat=files,10,cumulative.

       --cumulative
           Synonym for --dirstat=cumulative

       --dirstat-by-file[=<param1,param2>...]
           Synonym for --dirstat=files,param1,param2...

       --summary
           Output a condensed summary of extended header information such as
           creations, renames and mode changes.

       --patch-with-stat
           Synonym for -p --stat.

       -z
           Separate the commits with NULs instead of with new newlines.

           Also, when --raw or --numstat has been given, do not munge
           pathnames and use NULs as output field terminators.

           Without this option, pathnames with "unusual" characters are quoted
           as explained for the configuration variable core.quotePath (see
           git-config(1)).

       --name-only
           Show only names of changed files.

       --name-status
           Show only names and status of changed files. See the description of
           the --diff-filter option on what the status letters mean.

       --submodule[=<format>]
           Specify how differences in submodules are shown. When specifying
           --submodule=short the short format is used. This format just shows
           the names of the commits at the beginning and end of the range.
           When --submodule or --submodule=log is specified, the log format is
           used. This format lists the commits in the range like git-
           submodule(1) summary does. When --submodule=diff is specified, the
           diff format is used. This format shows an inline diff of the
           changes in the submodule contents between the commit range.
           Defaults to diff.submodule or the short format if the config option
           is unset.

       --color[=<when>]
           Show colored diff.  --color (i.e. without =<when>) is the same as
           --color=always.  <when> can be one of always, never, or auto.

       --no-color
           Turn off colored diff. It is the same as --color=never.

       --color-moved[=<mode>]
           Moved lines of code are colored differently. The <mode> defaults to
           no if the option is not given and to zebra if the option with no
           mode is given. The mode must be one of:

           no
               Moved lines are not highlighted.

           default
               Is a synonym for zebra. This may change to a more sensible mode
               in the future.

           plain
               Any line that is added in one location and was removed in
               another location will be colored with color.diff.newMoved.
               Similarly color.diff.oldMoved will be used for removed lines
               that are added somewhere else in the diff. This mode picks up
               any moved line, but it is not very useful in a review to
               determine if a block of code was moved without permutation.

           blocks
               Blocks of moved text of at least 20 alphanumeric characters are
               detected greedily. The detected blocks are painted using either
               the color.diff.{old,new}Moved color. Adjacent blocks cannot be
               told apart.

           zebra
               Blocks of moved text are detected as in blocks mode. The blocks
               are painted using either the color.diff.{old,new}Moved color or
               color.diff.{old,new}MovedAlternative. The change between the
               two colors indicates that a new block was detected.

           dimmed-zebra
               Similar to zebra, but additional dimming of uninteresting parts
               of moved code is performed. The bordering lines of two adjacent
               blocks are considered interesting, the rest is uninteresting.
               dimmed_zebra is a deprecated synonym.

       --no-color-moved
           Turn off move detection. This can be used to override configuration
           settings. It is the same as --color-moved=no.

       --color-moved-ws=<modes>
           This configures how whitespace is ignored when performing the move
           detection for --color-moved. These modes can be given as a comma
           separated list:

           no
               Do not ignore whitespace when performing move detection.

           ignore-space-at-eol
               Ignore changes in whitespace at EOL.

           ignore-space-change
               Ignore changes in amount of whitespace. This ignores whitespace
               at line end, and considers all other sequences of one or more
               whitespace characters to be equivalent.

           ignore-all-space
               Ignore whitespace when comparing lines. This ignores
               differences even if one line has whitespace where the other
               line has none.

           allow-indentation-change
               Initially ignore any whitespace in the move detection, then
               group the moved code blocks only into a block if the change in
               whitespace is the same per line. This is incompatible with the
               other modes.

       --no-color-moved-ws
           Do not ignore whitespace when performing move detection. This can
           be used to override configuration settings. It is the same as
           --color-moved-ws=no.

       --word-diff[=<mode>]
           Show a word diff, using the <mode> to delimit changed words. By
           default, words are delimited by whitespace; see --word-diff-regex
           below. The <mode> defaults to plain, and must be one of:

           color
               Highlight changed words using only colors. Implies --color.

           plain
               Show words as [-removed-] and {+added+}. Makes no attempts to
               escape the delimiters if they appear in the input, so the
               output may be ambiguous.

           porcelain
               Use a special line-based format intended for script
               consumption. Added/removed/unchanged runs are printed in the
               usual unified diff format, starting with a +/-/` ` character at
               the beginning of the line and extending to the end of the line.
               Newlines in the input are represented by a tilde ~ on a line of
               its own.

           none
               Disable word diff again.

           Note that despite the name of the first mode, color is used to
           highlight the changed parts in all modes if enabled.

       --word-diff-regex=<regex>
           Use <regex> to decide what a word is, instead of considering runs
           of non-whitespace to be a word. Also implies --word-diff unless it
           was already enabled.

           Every non-overlapping match of the <regex> is considered a word.
           Anything between these matches is considered whitespace and
           ignored(!) for the purposes of finding differences. You may want to
           append |[^[:space:]] to your regular expression to make sure that
           it matches all non-whitespace characters. A match that contains a
           newline is silently truncated(!) at the newline.

           For example, --word-diff-regex=.  will treat each character as a
           word and, correspondingly, show differences character by character.

           The regex can also be set via a diff driver or configuration
           option, see gitattributes(5) or git-config(1). Giving it explicitly
           overrides any diff driver or configuration setting. Diff drivers
           override configuration settings.

       --color-words[=<regex>]
           Equivalent to --word-diff=color plus (if a regex was specified)
           --word-diff-regex=<regex>.

       --no-renames
           Turn off rename detection, even when the configuration file gives
           the default to do so.

       --[no-]rename-empty
           Whether to use empty blobs as rename source.

       --check
           Warn if changes introduce conflict markers or whitespace errors.
           What are considered whitespace errors is controlled by
           core.whitespace configuration. By default, trailing whitespaces
           (including lines that consist solely of whitespaces) and a space
           character that is immediately followed by a tab character inside
           the initial indent of the line are considered whitespace errors.
           Exits with non-zero status if problems are found. Not compatible
           with --exit-code.

       --ws-error-highlight=<kind>
           Highlight whitespace errors in the context, old or new lines of the
           diff. Multiple values are separated by comma, none resets previous
           values, default reset the list to new and all is a shorthand for
           old,new,context. When this option is not given, and the
           configuration variable diff.wsErrorHighlight is not set, only
           whitespace errors in new lines are highlighted. The whitespace
           errors are colored with color.diff.whitespace.

       --full-index
           Instead of the first handful of characters, show the full pre- and
           post-image blob object names on the "index" line when generating
           patch format output.

       --binary
           In addition to --full-index, output a binary diff that can be
           applied with git-apply. Implies --patch.

       --abbrev[=<n>]
           Instead of showing the full 40-byte hexadecimal object name in
           diff-raw format output and diff-tree header lines, show the
           shortest prefix that is at least <n> hexdigits long that uniquely
           refers the object. In diff-patch output format, --full-index takes
           higher precedence, i.e. if --full-index is specified, full blob
           names will be shown regardless of --abbrev. Non default number of
           digits can be specified with --abbrev=<n>.

       -B[<n>][/<m>], --break-rewrites[=[<n>][/<m>]]
           Break complete rewrite changes into pairs of delete and create.
           This serves two purposes:

           It affects the way a change that amounts to a total rewrite of a
           file not as a series of deletion and insertion mixed together with
           a very few lines that happen to match textually as the context, but
           as a single deletion of everything old followed by a single
           insertion of everything new, and the number m controls this aspect
           of the -B option (defaults to 60%).  -B/70% specifies that less
           than 30% of the original should remain in the result for Git to
           consider it a total rewrite (i.e. otherwise the resulting patch
           will be a series of deletion and insertion mixed together with
           context lines).

           When used with -M, a totally-rewritten file is also considered as
           the source of a rename (usually -M only considers a file that
           disappeared as the source of a rename), and the number n controls
           this aspect of the -B option (defaults to 50%).  -B20% specifies
           that a change with addition and deletion compared to 20% or more of
           the file's size are eligible for being picked up as a possible
           source of a rename to another file.

       -M[<n>], --find-renames[=<n>]
           If generating diffs, detect and report renames for each commit. For
           following files across renames while traversing history, see
           --follow. If n is specified, it is a threshold on the similarity
           index (i.e. amount of addition/deletions compared to the file's
           size). For example, -M90% means Git should consider a delete/add
           pair to be a rename if more than 90% of the file hasn't changed.
           Without a % sign, the number is to be read as a fraction, with a
           decimal point before it. I.e., -M5 becomes 0.5, and is thus the
           same as -M50%. Similarly, -M05 is the same as -M5%. To limit
           detection to exact renames, use -M100%. The default similarity
           index is 50%.

       -C[<n>], --find-copies[=<n>]
           Detect copies as well as renames. See also --find-copies-harder. If
           n is specified, it has the same meaning as for -M<n>.

       --find-copies-harder
           For performance reasons, by default, -C option finds copies only if
           the original file of the copy was modified in the same changeset.
           This flag makes the command inspect unmodified files as candidates
           for the source of copy. This is a very expensive operation for
           large projects, so use it with caution. Giving more than one -C
           option has the same effect.

       -D, --irreversible-delete
           Omit the preimage for deletes, i.e. print only the header but not
           the diff between the preimage and /dev/null. The resulting patch is
           not meant to be applied with patch or git apply; this is solely for
           people who want to just concentrate on reviewing the text after the
           change. In addition, the output obviously lacks enough information
           to apply such a patch in reverse, even manually, hence the name of
           the option.

           When used together with -B, omit also the preimage in the deletion
           part of a delete/create pair.

       -l<num>
           The -M and -C options require O(n^2) processing time where n is the
           number of potential rename/copy targets. This option prevents
           rename/copy detection from running if the number of rename/copy
           targets exceeds the specified number.

       --diff-filter=[(A|C|D|M|R|T|U|X|B)...[*]]
           Select only files that are Added (A), Copied (C), Deleted (D),
           Modified (M), Renamed (R), have their type (i.e. regular file,
           symlink, submodule, ...) changed (T), are Unmerged (U), are Unknown
           (X), or have had their pairing Broken (B). Any combination of the
           filter characters (including none) can be used. When *
           (All-or-none) is added to the combination, all paths are selected
           if there is any file that matches other criteria in the comparison;
           if there is no file that matches other criteria, nothing is
           selected.

           Also, these upper-case letters can be downcased to exclude. E.g.
           --diff-filter=ad excludes added and deleted paths.

           Note that not all diffs can feature all types. For instance, diffs
           from the index to the working tree can never have Added entries
           (because the set of paths included in the diff is limited by what
           is in the index). Similarly, copied and renamed entries cannot
           appear if detection for those types is disabled.

       -S<string>
           Look for differences that change the number of occurrences of the
           specified string (i.e. addition/deletion) in a file. Intended for
           the scripter's use.

           It is useful when you're looking for an exact block of code (like a
           struct), and want to know the history of that block since it first
           came into being: use the feature iteratively to feed the
           interesting block in the preimage back into -S, and keep going
           until you get the very first version of the block.

           Binary files are searched as well.

       -G<regex>
           Look for differences whose patch text contains added/removed lines
           that match <regex>.

           To illustrate the difference between -S<regex> --pickaxe-regex and
           -G<regex>, consider a commit with the following diff in the same
           file:

               +    return frotz(nitfol, two->ptr, 1, 0);
               ...
               -    hit = frotz(nitfol, mf2.ptr, 1, 0);

           While git log -G"frotz\(nitfol" will show this commit, git log
           -S"frotz\(nitfol" --pickaxe-regex will not (because the number of
           occurrences of that string did not change).

           Unless --text is supplied patches of binary files without a
           textconv filter will be ignored.

           See the pickaxe entry in gitdiffcore(7) for more information.

       --find-object=<object-id>
           Look for differences that change the number of occurrences of the
           specified object. Similar to -S, just the argument is different in
           that it doesn't search for a specific string but for a specific
           object id.

           The object can be a blob or a submodule commit. It implies the -t
           option in git-log to also find trees.

       --pickaxe-all
           When -S or -G finds a change, show all the changes in that
           changeset, not just the files that contain the change in <string>.

       --pickaxe-regex
           Treat the <string> given to -S as an extended POSIX regular
           expression to match.

       -O<orderfile>
           Control the order in which files appear in the output. This
           overrides the diff.orderFile configuration variable (see git-
           config(1)). To cancel diff.orderFile, use -O/dev/null.

           The output order is determined by the order of glob patterns in
           <orderfile>. All files with pathnames that match the first pattern
           are output first, all files with pathnames that match the second
           pattern (but not the first) are output next, and so on. All files
           with pathnames that do not match any pattern are output last, as if
           there was an implicit match-all pattern at the end of the file. If
           multiple pathnames have the same rank (they match the same pattern
           but no earlier patterns), their output order relative to each other
           is the normal order.

           <orderfile> is parsed as follows:

           o   Blank lines are ignored, so they can be used as separators for
               readability.

           o   Lines starting with a hash ("#") are ignored, so they can be
               used for comments. Add a backslash ("\") to the beginning of
               the pattern if it starts with a hash.

           o   Each other line contains a single pattern.

           Patterns have the same syntax and semantics as patterns used for
           fnmatch(3) without the FNM_PATHNAME flag, except a pathname also
           matches a pattern if removing any number of the final pathname
           components matches the pattern. For example, the pattern "foo*bar"
           matches "fooasdfbar" and "foo/bar/baz/asdf" but not "foobarx".

       -R
           Swap two inputs; that is, show differences from index or on-disk
           file to tree contents.

       --relative[=<path>], --no-relative
           When run from a subdirectory of the project, it can be told to
           exclude changes outside the directory and show pathnames relative
           to it with this option. When you are not in a subdirectory (e.g. in
           a bare repository), you can name which subdirectory to make the
           output relative to by giving a <path> as an argument.
           --no-relative can be used to countermand both diff.relative config
           option and previous --relative.

       -a, --text
           Treat all files as text.

       --ignore-cr-at-eol
           Ignore carriage-return at the end of line when doing a comparison.

       --ignore-space-at-eol
           Ignore changes in whitespace at EOL.

       -b, --ignore-space-change
           Ignore changes in amount of whitespace. This ignores whitespace at
           line end, and considers all other sequences of one or more
           whitespace characters to be equivalent.

       -w, --ignore-all-space
           Ignore whitespace when comparing lines. This ignores differences
           even if one line has whitespace where the other line has none.

       --ignore-blank-lines
           Ignore changes whose lines are all blank.

       -I<regex>, --ignore-matching-lines=<regex>
           Ignore changes whose all lines match <regex>. This option may be
           specified more than once.

       --inter-hunk-context=<lines>
           Show the context between diff hunks, up to the specified number of
           lines, thereby fusing hunks that are close to each other. Defaults
           to diff.interHunkContext or 0 if the config option is unset.

       -W, --function-context
           Show whole function as context lines for each change. The function
           names are determined in the same way as git diff works out patch
           hunk headers (see Defining a custom hunk-header in
           gitattributes(5)).

       --ext-diff
           Allow an external diff helper to be executed. If you set an
           external diff driver with gitattributes(5), you need to use this
           option with git-log(1) and friends.

       --no-ext-diff
           Disallow external diff drivers.

       --textconv, --no-textconv
           Allow (or disallow) external text conversion filters to be run when
           comparing binary files. See gitattributes(5) for details. Because
           textconv filters are typically a one-way conversion, the resulting
           diff is suitable for human consumption, but cannot be applied. For
           this reason, textconv filters are enabled by default only for git-
           diff(1) and git-log(1), but not for git-format-patch(1) or diff
           plumbing commands.

       --ignore-submodules[=<when>]
           Ignore changes to submodules in the diff generation. <when> can be
           either "none", "untracked", "dirty" or "all", which is the default.
           Using "none" will consider the submodule modified when it either
           contains untracked or modified files or its HEAD differs from the
           commit recorded in the superproject and can be used to override any
           settings of the ignore option in git-config(1) or gitmodules(5).
           When "untracked" is used submodules are not considered dirty when
           they only contain untracked content (but they are still scanned for
           modified content). Using "dirty" ignores all changes to the work
           tree of submodules, only changes to the commits stored in the
           superproject are shown (this was the behavior until 1.7.0). Using
           "all" hides all changes to submodules.

       --src-prefix=<prefix>
           Show the given source prefix instead of "a/".

       --dst-prefix=<prefix>
           Show the given destination prefix instead of "b/".

       --no-prefix
           Do not show any source or destination prefix.

       --line-prefix=<prefix>
           Prepend an additional prefix to every line of output.

       --ita-invisible-in-index
           By default entries added by "git add -N" appear as an existing
           empty file in "git diff" and a new file in "git diff --cached".
           This option makes the entry appear as a new file in "git diff" and
           non-existent in "git diff --cached". This option could be reverted
           with --ita-visible-in-index. Both options are experimental and
           could be removed in future.

       For more detailed explanation on these common options, see also
       gitdiffcore(7).

GENERATING PATCH TEXT WITH -P
       Running git-diff(1), git-log(1), git-show(1), git-diff-index(1), git-
       diff-tree(1), or git-diff-files(1) with the -p option produces patch
       text. You can customize the creation of patch text via the
       GIT_EXTERNAL_DIFF and the GIT_DIFF_OPTS environment variables (see
       git(1)).

       What the -p option produces is slightly different from the traditional
       diff format:

        1. It is preceded with a "git diff" header that looks like this:

               diff --git a/file1 b/file2

           The a/ and b/ filenames are the same unless rename/copy is
           involved. Especially, even for a creation or a deletion, /dev/null
           is not used in place of the a/ or b/ filenames.

           When rename/copy is involved, file1 and file2 show the name of the
           source file of the rename/copy and the name of the file that
           rename/copy produces, respectively.

        2. It is followed by one or more extended header lines:

               old mode <mode>
               new mode <mode>
               deleted file mode <mode>
               new file mode <mode>
               copy from <path>
               copy to <path>
               rename from <path>
               rename to <path>
               similarity index <number>
               dissimilarity index <number>
               index <hash>..<hash> <mode>

           File modes are printed as 6-digit octal numbers including the file
           type and file permission bits.

           Path names in extended headers do not include the a/ and b/
           prefixes.

           The similarity index is the percentage of unchanged lines, and the
           dissimilarity index is the percentage of changed lines. It is a
           rounded down integer, followed by a percent sign. The similarity
           index value of 100% is thus reserved for two equal files, while
           100% dissimilarity means that no line from the old file made it
           into the new one.

           The index line includes the blob object names before and after the
           change. The <mode> is included if the file mode does not change;
           otherwise, separate lines indicate the old and the new mode.

        3. Pathnames with "unusual" characters are quoted as explained for the
           configuration variable core.quotePath (see git-config(1)).

        4. All the file1 files in the output refer to files before the commit,
           and all the file2 files refer to files after the commit. It is
           incorrect to apply each change to each file sequentially. For
           example, this patch will swap a and b:

               diff --git a/a b/b
               rename from a
               rename to b
               diff --git a/b b/a
               rename from b
               rename to a

COMBINED DIFF FORMAT
       Any diff-generating command can take the -c or --cc option to produce a
       combined diff when showing a merge. This is the default format when
       showing merges with git-diff(1) or git-show(1). Note also that you can
       give suitable --diff-merges option to any of these commands to force
       generation of diffs in specific format.

       A "combined diff" format looks like this:

           diff --combined describe.c
           index fabadb8,cc95eb0..4866510
           --- a/describe.c
           +++ b/describe.c
           @@@ -98,20 -98,12 +98,20 @@@
                   return (a_date > b_date) ? -1 : (a_date == b_date) ? 0 : 1;
             }

           - static void describe(char *arg)
            -static void describe(struct commit *cmit, int last_one)
           ++static void describe(char *arg, int last_one)
             {
            +      unsigned char sha1[20];
            +      struct commit *cmit;
                   struct commit_list *list;
                   static int initialized = 0;
                   struct commit_name *n;

            +      if (get_sha1(arg, sha1) < 0)
            +              usage(describe_usage);
            +      cmit = lookup_commit_reference(sha1);
            +      if (!cmit)
            +              usage(describe_usage);
            +
                   if (!initialized) {
                           initialized = 1;
                           for_each_ref(get_name);



        1. It is preceded with a "git diff" header, that looks like this (when
           the -c option is used):

               diff --combined file

           or like this (when the --cc option is used):

               diff --cc file

        2. It is followed by one or more extended header lines (this example
           shows a merge with two parents):

               index <hash>,<hash>..<hash>
               mode <mode>,<mode>..<mode>
               new file mode <mode>
               deleted file mode <mode>,<mode>

           The mode <mode>,<mode>..<mode> line appears only if at least one of
           the <mode> is different from the rest. Extended headers with
           information about detected contents movement (renames and copying
           detection) are designed to work with diff of two <tree-ish> and are
           not used by combined diff format.

        3. It is followed by two-line from-file/to-file header

               --- a/file
               +++ b/file

           Similar to two-line header for traditional unified diff format,
           /dev/null is used to signal created or deleted files.

           However, if the --combined-all-paths option is provided, instead of
           a two-line from-file/to-file you get a N+1 line from-file/to-file
           header, where N is the number of parents in the merge commit

               --- a/file
               --- a/file
               --- a/file
               +++ b/file

           This extended format can be useful if rename or copy detection is
           active, to allow you to see the original name of the file in
           different parents.

        4. Chunk header format is modified to prevent people from accidentally
           feeding it to patch -p1. Combined diff format was created for
           review of merge commit changes, and was not meant to be applied.
           The change is similar to the change in the extended index header:

               @@@ <from-file-range> <from-file-range> <to-file-range> @@@

           There are (number of parents + 1) @ characters in the chunk header
           for combined diff format.

       Unlike the traditional unified diff format, which shows two files A and
       B with a single column that has - (minus -- appears in A but removed in
       B), + (plus -- missing in A but added to B), or " " (space --
       unchanged) prefix, this format compares two or more files file1,
       file2,... with one file X, and shows how X differs from each of fileN.
       One column for each of fileN is prepended to the output line to note
       how X's line is different from it.

       A - character in the column N means that the line appears in fileN but
       it does not appear in the result. A + character in the column N means
       that the line appears in the result, and fileN does not have that line
       (in other words, the line was added, from the point of view of that
       parent).

       In the above example output, the function signature was changed from
       both files (hence two - removals from both file1 and file2, plus ++ to
       mean one line that was added does not appear in either file1 or file2).
       Also eight other lines are the same from file1 but do not appear in
       file2 (hence prefixed with +).

       When shown by git diff-tree -c, it compares the parents of a merge
       commit with the merge result (i.e. file1..fileN are the parents). When
       shown by git diff-files -c, it compares the two unresolved merge
       parents with the working tree file (i.e. file1 is stage 2 aka "our
       version", file2 is stage 3 aka "their version").

EXAMPLES
       git show v1.0.0
           Shows the tag v1.0.0, along with the object the tags points at.

       git show v1.0.0^{tree}
           Shows the tree pointed to by the tag v1.0.0.

       git show -s --format=%s v1.0.0^{commit}
           Shows the subject of the commit pointed to by the tag v1.0.0.

       git show next~10:Documentation/README
           Shows the contents of the file Documentation/README as they were
           current in the 10th last commit of the branch next.

       git show main:Makefile main:t/Makefile
           Concatenates the contents of said Makefiles in the head of the
           branch main.

DISCUSSION
       Git is to some extent character encoding agnostic.

       o   The contents of the blob objects are uninterpreted sequences of
           bytes. There is no encoding translation at the core level.

       o   Path names are encoded in UTF-8 normalization form C. This applies
           to tree objects, the index file, ref names, as well as path names
           in command line arguments, environment variables and config files
           (.git/config (see git-config(1)), gitignore(5), gitattributes(5)
           and gitmodules(5)).

           Note that Git at the core level treats path names simply as
           sequences of non-NUL bytes, there are no path name encoding
           conversions (except on Mac and Windows). Therefore, using non-ASCII
           path names will mostly work even on platforms and file systems that
           use legacy extended ASCII encodings. However, repositories created
           on such systems will not work properly on UTF-8-based systems (e.g.
           Linux, Mac, Windows) and vice versa. Additionally, many Git-based
           tools simply assume path names to be UTF-8 and will fail to display
           other encodings correctly.

       o   Commit log messages are typically encoded in UTF-8, but other
           extended ASCII encodings are also supported. This includes
           ISO-8859-x, CP125x and many others, but not UTF-16/32, EBCDIC and
           CJK multi-byte encodings (GBK, Shift-JIS, Big5, EUC-x, CP9xx etc.).

       Although we encourage that the commit log messages are encoded in
       UTF-8, both the core and Git Porcelain are designed not to force UTF-8
       on projects. If all participants of a particular project find it more
       convenient to use legacy encodings, Git does not forbid it. However,
       there are a few things to keep in mind.

        1. git commit and git commit-tree issues a warning if the commit log
           message given to it does not look like a valid UTF-8 string, unless
           you explicitly say your project uses a legacy encoding. The way to
           say this is to have i18n.commitencoding in .git/config file, like
           this:

               [i18n]
                       commitEncoding = ISO-8859-1

           Commit objects created with the above setting record the value of
           i18n.commitEncoding in its encoding header. This is to help other
           people who look at them later. Lack of this header implies that the
           commit log message is encoded in UTF-8.

        2. git log, git show, git blame and friends look at the encoding
           header of a commit object, and try to re-code the log message into
           UTF-8 unless otherwise specified. You can specify the desired
           output encoding with i18n.logOutputEncoding in .git/config file,
           like this:

               [i18n]
                       logOutputEncoding = ISO-8859-1

           If you do not have this configuration variable, the value of
           i18n.commitEncoding is used instead.

       Note that we deliberately chose not to re-code the commit log message
       when a commit is made to force UTF-8 at the commit object level,
       because re-coding to UTF-8 is not necessarily a reversible operation.

GIT
       Part of the git(1) suite



Git 2.30.1.378.g1d4f23            02/08/2021                       GIT-SHOW(1)
```



## `status`




```
GIT-STATUS(1)                     Git Manual                     GIT-STATUS(1)



NAME
       git-status - 作業ツリーのステータスを表示する

SYNOPSIS
       git status [<options>...] [--] [<pathspec>...]


DESCRIPTION
       インデックスファイルと現在のHEADコミットの間に違いがあるパス、
       作業ツリーとインデックスファイルの間に違いがあるパス、
       およびGitによって追跡されない（そして gitignore(5) によって無視されない）作業ツリー内のパス
       を表示します。
       1つ目は、git commit を実行してコミットするものです。
       2番目と3番目は、git commit を実行する前に git add を実行することでコミットできるものです。

OPTIONS
       -s, --short
           Give the output in the short-format.

       -b, --branch
           Show the branch and tracking info even in short-format.

       --show-stash
           Show the number of entries currently stashed away.

       --porcelain[=<version>]
           Give the output in an easy-to-parse format for scripts. This is
           similar to the short output, but will remain stable across Git
           versions and regardless of user configuration. See below for
           details.

           The version parameter is used to specify the format version. This
           is optional and defaults to the original version v1 format.

       --long
           Give the output in the long-format. This is the default.

       -v, --verbose
           In addition to the names of files that have been changed, also show
           the textual changes that are staged to be committed (i.e., like the
           output of git diff --cached). If -v is specified twice, then also
           show the changes in the working tree that have not yet been staged
           (i.e., like the output of git diff).

       -u[<mode>], --untracked-files[=<mode>]
           Show untracked files.

           The mode parameter is used to specify the handling of untracked
           files. It is optional: it defaults to all, and if specified, it
           must be stuck to the option (e.g.  -uno, but not -u no).

           The possible options are:

           o   no - Show no untracked files.

           o   normal - Shows untracked files and directories.

           o   all - Also shows individual files in untracked directories.

           When -u option is not used, untracked files and directories are
           shown (i.e. the same as specifying normal), to help you avoid
           forgetting to add newly created files. Because it takes extra work
           to find untracked files in the filesystem, this mode may take some
           time in a large working tree. Consider enabling untracked cache and
           split index if supported (see git update-index --untracked-cache
           and git update-index --split-index), Otherwise you can use no to
           have git status return more quickly without showing untracked
           files.

           The default can be changed using the status.showUntrackedFiles
           configuration variable documented in git-config(1).

       --ignore-submodules[=<when>]
           Ignore changes to submodules when looking for changes. <when> can
           be either "none", "untracked", "dirty" or "all", which is the
           default. Using "none" will consider the submodule modified when it
           either contains untracked or modified files or its HEAD differs
           from the commit recorded in the superproject and can be used to
           override any settings of the ignore option in git-config(1) or
           gitmodules(5). When "untracked" is used submodules are not
           considered dirty when they only contain untracked content (but they
           are still scanned for modified content). Using "dirty" ignores all
           changes to the work tree of submodules, only changes to the commits
           stored in the superproject are shown (this was the behavior before
           1.7.0). Using "all" hides all changes to submodules (and suppresses
           the output of submodule summaries when the config option
           status.submoduleSummary is set).

       --ignored[=<mode>]
           Show ignored files as well.

           The mode parameter is used to specify the handling of ignored
           files. It is optional: it defaults to traditional.

           The possible options are:

           o   traditional - Shows ignored files and directories, unless
               --untracked-files=all is specified, in which case individual
               files in ignored directories are displayed.

           o   no - Show no ignored files.

           o   matching - Shows ignored files and directories matching an
               ignore pattern.

           When matching mode is specified, paths that explicitly match an
           ignored pattern are shown. If a directory matches an ignore
           pattern, then it is shown, but not paths contained in the ignored
           directory. If a directory does not match an ignore pattern, but all
           contents are ignored, then the directory is not shown, but all
           contents are shown.

       -z
           Terminate entries with NUL, instead of LF. This implies the
           --porcelain=v1 output format if no other format is given.

       --column[=<options>], --no-column
           Display untracked files in columns. See configuration variable
           column.status for option syntax.--column and --no-column without
           options are equivalent to always and never respectively.

       --ahead-behind, --no-ahead-behind
           Display or do not display detailed ahead/behind counts for the
           branch relative to its upstream branch. Defaults to true.

       --renames, --no-renames
           Turn on/off rename detection regardless of user configuration. See
           also git-diff(1) --no-renames.

       --find-renames[=<n>]
           Turn on rename detection, optionally setting the similarity
           threshold. See also git-diff(1) --find-renames.

       <pathspec>...
           See the pathspec entry in gitglossary(7).

OUTPUT
       The output from this command is designed to be used as a commit
       template comment. The default, long format, is designed to be human
       readable, verbose and descriptive. Its contents and format are subject
       to change at any time.

       The paths mentioned in the output, unlike many other Git commands, are
       made relative to the current directory if you are working in a
       subdirectory (this is on purpose, to help cutting and pasting). See the
       status.relativePaths config option below.

   Short Format
       In the short-format, the status of each path is shown as one of these
       forms

           XY PATH
           XY ORIG_PATH -> PATH

       where ORIG_PATH is where the renamed/copied contents came from.
       ORIG_PATH is only shown when the entry is renamed or copied. The XY is
       a two-letter status code.

       The fields (including the ->) are separated from each other by a single
       space. If a filename contains whitespace or other nonprintable
       characters, that field will be quoted in the manner of a C string
       literal: surrounded by ASCII double quote (34) characters, and with
       interior special characters backslash-escaped.

       There are three different types of states that are shown using this
       format, and each one uses the XY syntax differently:

       o   When a merge is occurring and the merge was successful, or outside
           of a merge situation, X shows the status of the index and Y shows
           the status of the working tree.

       o   When a merge conflict has occurred and has not yet been resolved, X
           and Y show the state introduced by each head of the merge, relative
           to the common ancestor. These paths are said to be unmerged.

       o   When a path is untracked, X and Y are always the same, since they
           are unknown to the index.  ??  is used for untracked paths. Ignored
           files are not listed unless --ignored is used; if it is, ignored
           files are indicated by !!.

       Note that the term merge here also includes rebases using the default
       --merge strategy, cherry-picks, and anything else using the merge
       machinery.

       In the following table, these three classes are shown in separate
       sections, and these characters are used for X and Y fields for the
       first two sections that show tracked paths:

       o   ' ' = unmodified

       o   M = modified

       o   A = added

       o   D = deleted

       o   R = renamed

       o   C = copied

       o   U = updated but unmerged

           X          Y     Meaning
           -------------------------------------------------
                    [AMD]   not updated
           M        [ MD]   updated in index
           A        [ MD]   added to index
           D                deleted from index
           R        [ MD]   renamed in index
           C        [ MD]   copied in index
           [MARC]           index and work tree matches
           [ MARC]     M    work tree changed since index
           [ MARC]     D    deleted in work tree
           [ D]        R    renamed in work tree
           [ D]        C    copied in work tree
           -------------------------------------------------
           D           D    unmerged, both deleted
           A           U    unmerged, added by us
           U           D    unmerged, deleted by them
           U           A    unmerged, added by them
           D           U    unmerged, deleted by us
           A           A    unmerged, both added
           U           U    unmerged, both modified
           -------------------------------------------------
           ?           ?    untracked
           !           !    ignored
           -------------------------------------------------

       Submodules have more state and instead report M the submodule has a
       different HEAD than recorded in the index m the submodule has modified
       content ? the submodule has untracked files since modified content or
       untracked files in a submodule cannot be added via git add in the
       superproject to prepare a commit.

       m and ? are applied recursively. For example if a nested submodule in a
       submodule contains an untracked file, this is reported as ? as well.

       If -b is used the short-format status is preceded by a line

           ## branchname tracking info

   Porcelain Format Version 1
       Version 1 porcelain format is similar to the short format, but is
       guaranteed not to change in a backwards-incompatible way between Git
       versions or based on user configuration. This makes it ideal for
       parsing by scripts. The description of the short format above also
       describes the porcelain format, with a few exceptions:

        1. The user's color.status configuration is not respected; color will
           always be off.

        2. The user's status.relativePaths configuration is not respected;
           paths shown will always be relative to the repository root.

       There is also an alternate -z format recommended for machine parsing.
       In that format, the status field is the same, but some other things
       change. First, the -> is omitted from rename entries and the field
       order is reversed (e.g from -> to becomes to from). Second, a NUL
       (ASCII 0) follows each filename, replacing space as a field separator
       and the terminating newline (but a space still separates the status
       field from the first filename). Third, filenames containing special
       characters are not specially formatted; no quoting or
       backslash-escaping is performed.

       Any submodule changes are reported as modified M instead of m or single
       ?.

   Porcelain Format Version 2
       Version 2 format adds more detailed information about the state of the
       worktree and changed items. Version 2 also defines an extensible set of
       easy to parse optional headers.

       Header lines start with "#" and are added in response to specific
       command line arguments. Parsers should ignore headers they don't
       recognize.

       Branch Headers
           If --branch is given, a series of header lines are printed with
           information about the current branch.

               Line                                     Notes
               ------------------------------------------------------------
               # branch.oid <commit> | (initial)        Current commit.
               # branch.head <branch> | (detached)      Current branch.
               # branch.upstream <upstream_branch>      If upstream is set.
               # branch.ab +<ahead> -<behind>           If upstream is set and
                                                        the commit is present.
               ------------------------------------------------------------

       Changed Tracked Entries
           Following the headers, a series of lines are printed for tracked
           entries. One of three different line formats may be used to
           describe an entry depending on the type of change. Tracked entries
           are printed in an undefined order; parsers should allow for a
           mixture of the 3 line types in any order.

           Ordinary changed entries have the following format:

               1 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <path>

           Renamed or copied entries have the following format:

               2 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <X><score> <path><sep><origPath>

               Field       Meaning
               --------------------------------------------------------
               <XY>        A 2 character field containing the staged and
                           unstaged XY values described in the short format,
                           with unchanged indicated by a "." rather than
                           a space.
               <sub>       A 4 character field describing the submodule state.
                           "N..." when the entry is not a submodule.
                           "S<c><m><u>" when the entry is a submodule.
                           <c> is "C" if the commit changed; otherwise ".".
                           <m> is "M" if it has tracked changes; otherwise ".".
                           <u> is "U" if there are untracked changes; otherwise ".".
               <mH>        The octal file mode in HEAD.
               <mI>        The octal file mode in the index.
               <mW>        The octal file mode in the worktree.
               <hH>        The object name in HEAD.
               <hI>        The object name in the index.
               <X><score>  The rename or copy score (denoting the percentage
                           of similarity between the source and target of the
                           move or copy). For example "R100" or "C75".
               <path>      The pathname.  In a renamed/copied entry, this
                           is the target path.
               <sep>       When the `-z` option is used, the 2 pathnames are separated
                           with a NUL (ASCII 0x00) byte; otherwise, a tab (ASCII 0x09)
                           byte separates them.
               <origPath>  The pathname in the commit at HEAD or in the index.
                           This is only present in a renamed/copied entry, and
                           tells where the renamed/copied contents came from.
               --------------------------------------------------------

           Unmerged entries have the following format; the first character is
           a "u" to distinguish from ordinary changed entries.

               u <xy> <sub> <m1> <m2> <m3> <mW> <h1> <h2> <h3> <path>

               Field       Meaning
               --------------------------------------------------------
               <XY>        A 2 character field describing the conflict type
                           as described in the short format.
               <sub>       A 4 character field describing the submodule state
                           as described above.
               <m1>        The octal file mode in stage 1.
               <m2>        The octal file mode in stage 2.
               <m3>        The octal file mode in stage 3.
               <mW>        The octal file mode in the worktree.
               <h1>        The object name in stage 1.
               <h2>        The object name in stage 2.
               <h3>        The object name in stage 3.
               <path>      The pathname.
               --------------------------------------------------------

       Other Items
           Following the tracked entries (and if requested), a series of lines
           will be printed for untracked and then ignored items found in the
           worktree.

           Untracked items have the following format:

               ? <path>

           Ignored items have the following format:

               ! <path>

       Pathname Format Notes and -z
           When the -z option is given, pathnames are printed as is and
           without any quoting and lines are terminated with a NUL (ASCII
           0x00) byte.

           Without the -z option, pathnames with "unusual" characters are
           quoted as explained for the configuration variable core.quotePath
           (see git-config(1)).

CONFIGURATION
       The command honors color.status (or status.color -- they mean the same
       thing and the latter is kept for backward compatibility) and
       color.status.<slot> configuration variables to colorize its output.

       If the config variable status.relativePaths is set to false, then all
       paths shown are relative to the repository root, not to the current
       directory.

       If status.submoduleSummary is set to a non zero number or true
       (identical to -1 or an unlimited number), the submodule summary will be
       enabled for the long format and a summary of commits for modified
       submodules will be shown (see --summary-limit option of git-
       submodule(1)). Please note that the summary output from the status
       command will be suppressed for all submodules when
       diff.ignoreSubmodules is set to all or only for those submodules where
       submodule.<name>.ignore=all. To also view the summary for ignored
       submodules you can either use the --ignore-submodules=dirty command
       line option or the git submodule summary command, which shows a similar
       output but does not honor these settings.

BACKGROUND REFRESH
       By default, git status will automatically refresh the index, updating
       the cached stat information from the working tree and writing out the
       result. Writing out the updated index is an optimization that isn't
       strictly necessary (status computes the values for itself, but writing
       them out is just to save subsequent programs from repeating our
       computation). When status is run in the background, the lock held
       during the write may conflict with other simultaneous processes,
       causing them to fail. Scripts running status in the background should
       consider using git --no-optional-locks status (see git(1) for details).

SEE ALSO
       gitignore(5)

GIT
       Part of the git(1) suite



Git 2.30.1.378.g1d4f23            02/08/2021                     GIT-STATUS(1)
```



## `branch`




```
GIT-BRANCH(1)                     Git Manual                     GIT-BRANCH(1)



NAME
       git-branch - ブランチを一覧表示、作成、または削除する

SYNOPSIS
       git branch [--color[=<when>] | --no-color] [--show-current]
               [-v [--abbrev=<n> | --no-abbrev]]
               [--column[=<options>] | --no-column] [--sort=<key>]
               [--merged [<commit>]] [--no-merged [<commit>]]
               [--contains [<commit>]] [--no-contains [<commit>]]
               [--points-at <object>] [--format=<format>]
               [(-r | --remotes) | (-a | --all)]
               [--list] [<pattern>...]
       git branch [--track | --no-track] [-f] <branchname> [<start-point>]
       git branch (--set-upstream-to=<upstream> | -u <upstream>) [<branchname>]
       git branch --unset-upstream [<branchname>]
       git branch (-m | -M) [<oldbranch>] <newbranch>
       git branch (-c | -C) [<oldbranch>] <newbranch>
       git branch (-d | -D) [-r] <branchname>...
       git branch --edit-description [<branchname>]


DESCRIPTION
       --list が指定されている場合、またはオプション以外の引数がない場合は、既存のブランチが一覧表示されます。
       現在のブランチは緑色で強調表示され、アスタリスクでマークされます。
       リンクされたワークツリーでチェックアウトされたブランチは、シアンで強調表示され、プラス記号でマークされます。
       オプション -r を使用すると、リモート追跡ブランチが一覧表示され、
       オプション -a を使用すると、ローカルブランチとリモートブランチの両方が表示されます。
       
       <pattern> が指定されている場合、出力を一致するブランチに制限するための
       シェルワイルドカードとして使用されます。
       複数のパターンが指定されている場合、いずれかのパターンに一致するとブランチが表示されます。
       
       <pattern> を指定するときは、--list を使用する必要があることに注意してください。
       そうしないと、コマンドがブランチの作成として解釈される可能性があります。
       
       --contains を使用すると、名前付きコミットを含むブランチ（つまり、チップコミットが
       名前付きコミットの子孫であるブランチ）のみが表示され、--no-contains はそれを反転します。
       --merged を使用すると、名前付きコミットにマージされたブランチ（つまり、名前付きコミットから
       チップコミットに到達できるブランチ）のみが一覧表示されます。
       --no-merged を使用すると、指定されたコミットにマージされていないブランチのみが一覧表示されます。
       <commit> 引数が欠落している場合、デフォルトで HEAD（つまり、現在のブランチの先端）になります。
       
       コマンドの2番目の形式は、現在の HEAD、または指定されている場合は <start-point> を指す
       <branchname> という名前の新しいブランチヘッドを作成します。
       特別な場合として、<start-point> の場合、マージベースが1つしかない場合は、
       A と B のマージベースのショートカットとして「A...B」を使用できます。
        A と B の最大1つを省略できます。その場合、デフォルトで HEAD になります。
       
       これにより新しいブランチが作成されますが、作業ツリーがそれに切り替わらないことに注意してください。
       「gitswitch <newbranch>」を使用して、新しいブランチに切り替えます。
       
       ローカルブランチがリモートトラッキングブランチから開始されると、
       Gitはブランチ（具体的には branch.<name>.remote および branch.<name>.merge 構成エントリ）
       をセットアップして、git pull がリモート追跡ブランチから適切にマージされるようにします。
       この動作は、グローバルの branch.autoSetupMerge 構成フラグを介して変更できます。
       この設定は、-track および --no-track オプションを使用してオーバーライドでき、
       後で git branch--set-upstream-to を使用して変更できます。
       
       -m または -M オプションを使用すると、<oldbranch> の名前が <newbranch> に変更されます。
       <oldbranch> に対応する reflog がある場合は、<newbranch> に一致するように名前が変更され、
       ブランチの名前変更を記憶するために reflog エントリが作成されます。
       <newbranch> が存在する場合は、-M を使用して名前の変更を強制する必要があります。
       
       -c および -C オプションのセマンティクスは、-m および -M とまったく同じですが、
       ブランチの名前が変更される代わりに、構成および reflog とともに新しい名前にコピーされます。
       
       -d または -D オプションを指定すると、<branchname> が削除されます。
       削除するブランチを複数指定できます。ブランチに現在 reflog がある場合、reflog も削除されます。
       
       -r を -d と一緒に使用して、リモート追跡ブランチを削除します。
       リモート追跡ブランチを削除するのは、リモートリポジトリに存在しなくなった場合、
       または git fetch が再度フェッチしないように構成されている場合にのみ意味があることに注意してください。
       廃止されたすべてのリモートトラッキングブランチをクリーンアップする方法については、git-remote(1) の
       prune サブコマンドも参照してください。

OPTIONS
       -d, --delete
           Delete a branch. The branch must be fully merged in its upstream
           branch, or in HEAD if no upstream was set with --track or
           --set-upstream-to.

       -D
           Shortcut for --delete --force.

       --create-reflog
           Create the branch's reflog. This activates recording of all changes
           made to the branch ref, enabling use of date based sha1 expressions
           such as "<branchname>@{yesterday}". Note that in non-bare
           repositories, reflogs are usually enabled by default by the
           core.logAllRefUpdates config option. The negated form
           --no-create-reflog only overrides an earlier --create-reflog, but
           currently does not negate the setting of core.logAllRefUpdates.

       -f, --force
           Reset <branchname> to <startpoint>, even if <branchname> exists
           already. Without -f, git branch refuses to change an existing
           branch. In combination with -d (or --delete), allow deleting the
           branch irrespective of its merged status. In combination with -m
           (or --move), allow renaming the branch even if the new branch name
           already exists, the same applies for -c (or --copy).

       -m, --move
           Move/rename a branch and the corresponding reflog.

       -M
           Shortcut for --move --force.

       -c, --copy
           Copy a branch and the corresponding reflog.

       -C
           Shortcut for --copy --force.

       --color[=<when>]
           Color branches to highlight current, local, and remote-tracking
           branches. The value must be always (the default), never, or auto.

       --no-color
           Turn off branch colors, even when the configuration file gives the
           default to color output. Same as --color=never.

       -i, --ignore-case
           Sorting and filtering branches are case insensitive.

       --column[=<options>], --no-column
           Display branch listing in columns. See configuration variable
           column.branch for option syntax.--column and --no-column without
           options are equivalent to always and never respectively.

           This option is only applicable in non-verbose mode.

       -r, --remotes
           List or delete (if used with -d) the remote-tracking branches.
           Combine with --list to match the optional pattern(s).

       -a, --all
           List both remote-tracking branches and local branches. Combine with
           --list to match optional pattern(s).

       -l, --list
           List branches. With optional <pattern>..., e.g.  git branch --list
           'maint-*', list only the branches that match the pattern(s).

       --show-current
           Print the name of the current branch. In detached HEAD state,
           nothing is printed.

       -v, -vv, --verbose
           When in list mode, show sha1 and commit subject line for each head,
           along with relationship to upstream branch (if any). If given
           twice, print the path of the linked worktree (if any) and the name
           of the upstream branch, as well (see also git remote show
           <remote>). Note that the current worktree's HEAD will not have its
           path printed (it will always be your current directory).

       -q, --quiet
           Be more quiet when creating or deleting a branch, suppressing
           non-error messages.

       --abbrev=<n>
           In the verbose listing that show the commit object name, show the
           shortest prefix that is at least <n> hexdigits long that uniquely
           refers the object. The default value is 7 and can be overridden by
           the core.abbrev config option.

       --no-abbrev
           Display the full sha1s in the output listing rather than
           abbreviating them.

       -t, --track
           When creating a new branch, set up branch.<name>.remote and
           branch.<name>.merge configuration entries to mark the start-point
           branch as "upstream" from the new branch. This configuration will
           tell git to show the relationship between the two branches in git
           status and git branch -v. Furthermore, it directs git pull without
           arguments to pull from the upstream when the new branch is checked
           out.

           This behavior is the default when the start point is a
           remote-tracking branch. Set the branch.autoSetupMerge configuration
           variable to false if you want git switch, git checkout and git
           branch to always behave as if --no-track were given. Set it to
           always if you want this behavior when the start-point is either a
           local or remote-tracking branch.

       --no-track
           Do not set up "upstream" configuration, even if the
           branch.autoSetupMerge configuration variable is true.

       --set-upstream
           As this option had confusing syntax, it is no longer supported.
           Please use --track or --set-upstream-to instead.

       -u <upstream>, --set-upstream-to=<upstream>
           Set up <branchname>'s tracking information so <upstream> is
           considered <branchname>'s upstream branch. If no <branchname> is
           specified, then it defaults to the current branch.

       --unset-upstream
           Remove the upstream information for <branchname>. If no branch is
           specified it defaults to the current branch.

       --edit-description
           Open an editor and edit the text to explain what the branch is for,
           to be used by various other commands (e.g.  format-patch,
           request-pull, and merge (if enabled)). Multi-line explanations may
           be used.

       --contains [<commit>]
           Only list branches which contain the specified commit (HEAD if not
           specified). Implies --list.

       --no-contains [<commit>]
           Only list branches which don't contain the specified commit (HEAD
           if not specified). Implies --list.

       --merged [<commit>]
           Only list branches whose tips are reachable from the specified
           commit (HEAD if not specified). Implies --list.

       --no-merged [<commit>]
           Only list branches whose tips are not reachable from the specified
           commit (HEAD if not specified). Implies --list.

       <branchname>
           The name of the branch to create or delete. The new branch name
           must pass all checks defined by git-check-ref-format(1). Some of
           these checks may restrict the characters allowed in a branch name.

       <start-point>
           The new branch head will point to this commit. It may be given as a
           branch name, a commit-id, or a tag. If this option is omitted, the
           current HEAD will be used instead.

       <oldbranch>
           The name of an existing branch to rename.

       <newbranch>
           The new name for an existing branch. The same restrictions as for
           <branchname> apply.

       --sort=<key>
           Sort based on the key given. Prefix - to sort in descending order
           of the value. You may use the --sort=<key> option multiple times,
           in which case the last key becomes the primary key. The keys
           supported are the same as those in git for-each-ref. Sort order
           defaults to the value configured for the branch.sort variable if
           exists, or to sorting based on the full refname (including refs/...
           prefix). This lists detached HEAD (if present) first, then local
           branches and finally remote-tracking branches. See git-config(1).

       --points-at <object>
           Only list branches of the given object.

       --format <format>
           A string that interpolates %(fieldname) from a branch ref being
           shown and the object it points at. The format is the same as that
           of git-for-each-ref(1).

CONFIGURATION
       pager.branch is only respected when listing branches, i.e., when --list
       is used or implied. The default is to use a pager. See git-config(1).

EXAMPLES
       Start development from a known tag

               $ git clone git://git.kernel.org/pub/scm/.../linux-2.6 my2.6
               $ cd my2.6
               $ git branch my2.6.14 v2.6.14   (1)
               $ git switch my2.6.14

           1. This step and the next one could be combined into a single step
           with "checkout -b my2.6.14 v2.6.14".

       Delete an unneeded branch

               $ git clone git://git.kernel.org/.../git.git my.git
               $ cd my.git
               $ git branch -d -r origin/todo origin/html origin/man   (1)
               $ git branch -D test                                    (2)

           1. Delete the remote-tracking branches "todo", "html" and "man".
           The next fetch or pull will create them again unless you configure
           them not to. See git-fetch(1).
           2. Delete the "test" branch even if the "main" branch (or
           whichever branch is currently checked out) does not have all
           commits from the test branch.

       Listing branches from a specific remote

               $ git branch -r -l '<remote>/<pattern>'                 (1)
               $ git for-each-ref 'refs/remotes/<remote>/<pattern>'    (2)

           1. Using -a would conflate <remote> with any local branches you
           happen to have been prefixed with the same <remote> pattern.
           2. for-each-ref can take a wide range of options. See git-for-each-
           ref(1)

       Patterns will normally need quoting.

NOTES
       If you are creating a branch that you want to switch to immediately, it
       is easier to use the "git switch" command with its -c option to do the
       same thing with a single command.

       The options --contains, --no-contains, --merged and --no-merged serve
       four related but different purposes:

       o   --contains <commit> is used to find all branches which will need
           special attention if <commit> were to be rebased or amended, since
           those branches contain the specified <commit>.

       o   --no-contains <commit> is the inverse of that, i.e. branches that
           don't contain the specified <commit>.

       o   --merged is used to find all branches which can be safely deleted,
           since those branches are fully contained by HEAD.

       o   --no-merged is used to find branches which are candidates for
           merging into HEAD, since those branches are not fully contained by
           HEAD.

       When combining multiple --contains and --no-contains filters, only
       references that contain at least one of the --contains commits and
       contain none of the --no-contains commits are shown.

       When combining multiple --merged and --no-merged filters, only
       references that are reachable from at least one of the --merged commits
       and from none of the --no-merged commits are shown.

SEE ALSO
       git-check-ref-format(1), git-fetch(1), git-remote(1), "Understanding
       history: What is a branch?"[1] in the Git User's Manual.

GIT
       Part of the git(1) suite

NOTES
        1. "Understanding history: What is a branch?"
           git-htmldocs/user-manual.html#what-is-a-branch



Git 2.30.1.378.g1d4f23            02/08/2021                     GIT-BRANCH(1)
```



## `commit`




```
GIT-COMMIT(1)                     Git Manual                     GIT-COMMIT(1)



NAME
       git-commit - リポジトリへの変更を記録する

SYNOPSIS
       git commit [-a | --interactive | --patch] [-s] [-v] [-u<mode>] [--amend]
                  [--dry-run] [(-c | -C | --fixup | --squash) <commit>]
                  [-F <file> | -m <msg>] [--reset-author] [--allow-empty]
                  [--allow-empty-message] [--no-verify] [-e] [--author=<author>]
                  [--date=<date>] [--cleanup=<mode>] [--[no-]status]
                  [-i | -o] [--pathspec-from-file=<file> [--pathspec-file-nul]]
                  [-S[<keyid>]] [--] [<pathspec>...]


DESCRIPTION
       インデックスの現在の内容と変更を説明する指定されたログメッセージを含む新しいコミットを作成します。
       新しいコミットは HEAD の直接の子であり、通常は現在のブランチの先端であり、
       ブランチはそれを指すように更新されます（ブランチが作業ツリーに関連付けられていない場合を除きます。
       この場合、HEAD は git-checkout(1) で説明されているように「デタッチ」されます）。

       コミットするコンテンツは、いくつかの方法で指定できます：
           
        1. commitコマンドを使用する前に、git-add(1) を使用してインデックスに変更を段階的に「追加」します
           （注：変更されたファイルでも「追加」する必要があります）。
           
        2. commit コマンドを使用する前に、git-rm(1) を使用して
           作業ツリーとインデックスからファイルを削除します。
           
        3. ファイルを commit コマンドの引数としてリストする（--interactive または --patch スイッチなし）。
           この場合、コミットはインデックスにステージングされた変更を無視し、
           代わりにリストされたファイルの現在のコンテンツを記録します
           （これはすでに Git に知られている必要があります）。

        4. コミットコマンドで -a スイッチを使用して、すべての既知のファイル
           （つまり、インデックスに既にリストされているすべてのファイル）
           からの変更を自動的に「add」し、作業ツリーから削除されたインデックス内のファイルを
           自動的に「rm」します。
           次に実際のコミットを実行します。
           
        5. --interactive または --patch スイッチを commit コマンドとともに使用して、
           操作を完了する前に、インデックスの内容に加えて、どのファイルまたはハンクを
           コミットの一部にするかを1つずつ決定します。
           これらのモードの操作方法については、git-add(1) の「Interactive Mode」セクションを参照してください。
       
       --dry-run オプションを使用すると、同じパラメーターセット（オプションとパス）を
       指定することで、次のコミットで上記のいずれかに含まれるものの概要を取得できます。
       
       コミットを行い、その直後に間違いを見つけた場合は、git reset を使用して回復できます。

OPTIONS
       -a, --all
           Tell the command to automatically stage files that have been
           modified and deleted, but new files you have not told Git about are
           not affected.

       -p, --patch
           Use the interactive patch selection interface to chose which
           changes to commit. See git-add(1) for details.

       -C <commit>, --reuse-message=<commit>
           Take an existing commit object, and reuse the log message and the
           authorship information (including the timestamp) when creating the
           commit.

       -c <commit>, --reedit-message=<commit>
           Like -C, but with -c the editor is invoked, so that the user can
           further edit the commit message.

       --fixup=<commit>
           Construct a commit message for use with rebase --autosquash. The
           commit message will be the subject line from the specified commit
           with a prefix of "fixup! ". See git-rebase(1) for details.

       --squash=<commit>
           Construct a commit message for use with rebase --autosquash. The
           commit message subject line is taken from the specified commit with
           a prefix of "squash! ". Can be used with additional commit message
           options (-m/-c/-C/-F). See git-rebase(1) for details.

       --reset-author
           When used with -C/-c/--amend options, or when committing after a
           conflicting cherry-pick, declare that the authorship of the
           resulting commit now belongs to the committer. This also renews the
           author timestamp.

       --short
           When doing a dry-run, give the output in the short-format. See git-
           status(1) for details. Implies --dry-run.

       --branch
           Show the branch and tracking info even in short-format.

       --porcelain
           When doing a dry-run, give the output in a porcelain-ready format.
           See git-status(1) for details. Implies --dry-run.

       --long
           When doing a dry-run, give the output in the long-format. Implies
           --dry-run.

       -z, --null
           When showing short or porcelain status output, print the filename
           verbatim and terminate the entries with NUL, instead of LF. If no
           format is given, implies the --porcelain output format. Without the
           -z option, filenames with "unusual" characters are quoted as
           explained for the configuration variable core.quotePath (see git-
           config(1)).

       -F <file>, --file=<file>
           Take the commit message from the given file. Use - to read the
           message from the standard input.

       --author=<author>
           Override the commit author. Specify an explicit author using the
           standard A U Thor <author@example.com> format. Otherwise <author>
           is assumed to be a pattern and is used to search for an existing
           commit by that author (i.e. rev-list --all -i --author=<author>);
           the commit author is then copied from the first such commit found.

       --date=<date>
           Override the author date used in the commit.

       -m <msg>, --message=<msg>
           Use the given <msg> as the commit message. If multiple -m options
           are given, their values are concatenated as separate paragraphs.

           The -m option is mutually exclusive with -c, -C, and -F.

       -t <file>, --template=<file>
           When editing the commit message, start the editor with the contents
           in the given file. The commit.template configuration variable is
           often used to give this option implicitly to the command. This
           mechanism can be used by projects that want to guide participants
           with some hints on what to write in the message in what order. If
           the user exits the editor without editing the message, the commit
           is aborted. This has no effect when a message is given by other
           means, e.g. with the -m or -F options.

       -s, --signoff, --no-signoff
           Add a Signed-off-by trailer by the committer at the end of the
           commit log message. The meaning of a signoff depends on the project
           to which you're committing. For example, it may certify that the
           committer has the rights to submit the work under the project's
           license or agrees to some contributor representation, such as a
           Developer Certificate of Origin. (See
           http://developercertificate.org for the one used by the Linux
           kernel and Git projects.) Consult the documentation or leadership
           of the project to which you're contributing to understand how the
           signoffs are used in that project.

           The --no-signoff option can be used to countermand an earlier
           --signoff option on the command line.

       -n, --no-verify
           This option bypasses the pre-commit and commit-msg hooks. See also
           githooks(5).

       --allow-empty
           Usually recording a commit that has the exact same tree as its sole
           parent commit is a mistake, and the command prevents you from
           making such a commit. This option bypasses the safety, and is
           primarily for use by foreign SCM interface scripts.

       --allow-empty-message
           Like --allow-empty this command is primarily for use by foreign SCM
           interface scripts. It allows you to create a commit with an empty
           commit message without using plumbing commands like git-commit-
           tree(1).

       --cleanup=<mode>
           This option determines how the supplied commit message should be
           cleaned up before committing. The <mode> can be strip, whitespace,
           verbatim, scissors or default.

           strip
               Strip leading and trailing empty lines, trailing whitespace,
               commentary and collapse consecutive empty lines.

           whitespace
               Same as strip except #commentary is not removed.

           verbatim
               Do not change the message at all.

           scissors
               Same as whitespace except that everything from (and including)
               the line found below is truncated, if the message is to be
               edited. "#" can be customized with core.commentChar.

                   # ------------------------ >8 ------------------------

           default
               Same as strip if the message is to be edited. Otherwise
               whitespace.

           The default can be changed by the commit.cleanup configuration
           variable (see git-config(1)).

       -e, --edit
           The message taken from file with -F, command line with -m, and from
           commit object with -C are usually used as the commit log message
           unmodified. This option lets you further edit the message taken
           from these sources.

       --no-edit
           Use the selected commit message without launching an editor. For
           example, git commit --amend --no-edit amends a commit without
           changing its commit message.

       --amend
           Replace the tip of the current branch by creating a new commit. The
           recorded tree is prepared as usual (including the effect of the -i
           and -o options and explicit pathspec), and the message from the
           original commit is used as the starting point, instead of an empty
           message, when no other message is specified from the command line
           via options such as -m, -F, -c, etc. The new commit has the same
           parents and author as the current one (the --reset-author option
           can countermand this).

           It is a rough equivalent for:

                       $ git reset --soft HEAD^
                       $ ... do something else to come up with the right tree ...
                       $ git commit -c ORIG_HEAD

           but can be used to amend a merge commit.

           You should understand the implications of rewriting history if you
           amend a commit that has already been published. (See the
           "RECOVERING FROM UPSTREAM REBASE" section in git-rebase(1).)

       --no-post-rewrite
           Bypass the post-rewrite hook.

       -i, --include
           Before making a commit out of staged contents so far, stage the
           contents of paths given on the command line as well. This is
           usually not what you want unless you are concluding a conflicted
           merge.

       -o, --only
           Make a commit by taking the updated working tree contents of the
           paths specified on the command line, disregarding any contents that
           have been staged for other paths. This is the default mode of
           operation of git commit if any paths are given on the command line,
           in which case this option can be omitted. If this option is
           specified together with --amend, then no paths need to be
           specified, which can be used to amend the last commit without
           committing changes that have already been staged. If used together
           with --allow-empty paths are also not required, and an empty commit
           will be created.

       --pathspec-from-file=<file>
           Pathspec is passed in <file> instead of commandline args. If <file>
           is exactly - then standard input is used. Pathspec elements are
           separated by LF or CR/LF. Pathspec elements can be quoted as
           explained for the configuration variable core.quotePath (see git-
           config(1)). See also --pathspec-file-nul and global
           --literal-pathspecs.

       --pathspec-file-nul
           Only meaningful with --pathspec-from-file. Pathspec elements are
           separated with NUL character and all other characters are taken
           literally (including newlines and quotes).

       -u[<mode>], --untracked-files[=<mode>]
           Show untracked files.

           The mode parameter is optional (defaults to all), and is used to
           specify the handling of untracked files; when -u is not used, the
           default is normal, i.e. show untracked files and directories.

           The possible options are:

           o   no - Show no untracked files

           o   normal - Shows untracked files and directories

           o   all - Also shows individual files in untracked directories.

           The default can be changed using the status.showUntrackedFiles
           configuration variable documented in git-config(1).

       -v, --verbose
           Show unified diff between the HEAD commit and what would be
           committed at the bottom of the commit message template to help the
           user describe the commit by reminding what changes the commit has.
           Note that this diff output doesn't have its lines prefixed with #.
           This diff will not be a part of the commit message. See the
           commit.verbose configuration variable in git-config(1).

           If specified twice, show in addition the unified diff between what
           would be committed and the worktree files, i.e. the unstaged
           changes to tracked files.

       -q, --quiet
           Suppress commit summary message.

       --dry-run
           Do not create a commit, but show a list of paths that are to be
           committed, paths with local changes that will be left uncommitted
           and paths that are untracked.

       --status
           Include the output of git-status(1) in the commit message template
           when using an editor to prepare the commit message. Defaults to on,
           but can be used to override configuration variable commit.status.

       --no-status
           Do not include the output of git-status(1) in the commit message
           template when using an editor to prepare the default commit
           message.

       -S[<keyid>], --gpg-sign[=<keyid>], --no-gpg-sign
           GPG-sign commits. The keyid argument is optional and defaults to
           the committer identity; if specified, it must be stuck to the
           option without a space.  --no-gpg-sign is useful to countermand
           both commit.gpgSign configuration variable, and earlier --gpg-sign.

       --
           Do not interpret any more arguments as options.

       <pathspec>...
           When pathspec is given on the command line, commit the contents of
           the files that match the pathspec without recording the changes
           already added to the index. The contents of these files are also
           staged for the next commit on top of what have been staged before.

           For more details, see the pathspec entry in gitglossary(7).

EXAMPLES
       When recording your own work, the contents of modified files in your
       working tree are temporarily stored to a staging area called the
       "index" with git add. A file can be reverted back, only in the index
       but not in the working tree, to that of the last commit with git
       restore --staged <file>, which effectively reverts git add and prevents
       the changes to this file from participating in the next commit. After
       building the state to be committed incrementally with these commands,
       git commit (without any pathname parameter) is used to record what has
       been staged so far. This is the most basic form of the command. An
       example:

           $ edit hello.c
           $ git rm goodbye.c
           $ git add hello.c
           $ git commit


       Instead of staging files after each individual change, you can tell git
       commit to notice the changes to the files whose contents are tracked in
       your working tree and do corresponding git add and git rm for you. That
       is, this example does the same as the earlier example if there is no
       other change in your working tree:

           $ edit hello.c
           $ rm goodbye.c
           $ git commit -a


       The command git commit -a first looks at your working tree, notices
       that you have modified hello.c and removed goodbye.c, and performs
       necessary git add and git rm for you.

       After staging changes to many files, you can alter the order the
       changes are recorded in, by giving pathnames to git commit. When
       pathnames are given, the command makes a commit that only records the
       changes made to the named paths:

           $ edit hello.c hello.h
           $ git add hello.c hello.h
           $ edit Makefile
           $ git commit Makefile


       This makes a commit that records the modification to Makefile. The
       changes staged for hello.c and hello.h are not included in the
       resulting commit. However, their changes are not lost -- they are still
       staged and merely held back. After the above sequence, if you do:

           $ git commit


       this second commit would record the changes to hello.c and hello.h as
       expected.

       After a merge (initiated by git merge or git pull) stops because of
       conflicts, cleanly merged paths are already staged to be committed for
       you, and paths that conflicted are left in unmerged state. You would
       have to first check which paths are conflicting with git status and
       after fixing them manually in your working tree, you would stage the
       result as usual with git add:

           $ git status | grep unmerged
           unmerged: hello.c
           $ edit hello.c
           $ git add hello.c


       After resolving conflicts and staging the result, git ls-files -u would
       stop mentioning the conflicted path. When you are done, run git commit
       to finally record the merge:

           $ git commit


       As with the case to record your own changes, you can use -a option to
       save typing. One difference is that during a merge resolution, you
       cannot use git commit with pathnames to alter the order the changes are
       committed, because the merge should be recorded as a single commit. In
       fact, the command refuses to run when given pathnames (but see -i
       option).

COMMIT INFORMATION
       Author and committer information is taken from the following
       environment variables, if set:

           GIT_AUTHOR_NAME
           GIT_AUTHOR_EMAIL
           GIT_AUTHOR_DATE
           GIT_COMMITTER_NAME
           GIT_COMMITTER_EMAIL
           GIT_COMMITTER_DATE

       (nb "<", ">" and "\n"s are stripped)

       The author and committer names are by convention some form of a
       personal name (that is, the name by which other humans refer to you),
       although Git does not enforce or require any particular form. Arbitrary
       Unicode may be used, subject to the constraints listed above. This name
       has no effect on authentication; for that, see the credential.username
       variable in git-config(1).

       In case (some of) these environment variables are not set, the
       information is taken from the configuration items user.name and
       user.email, or, if not present, the environment variable EMAIL, or, if
       that is not set, system user name and the hostname used for outgoing
       mail (taken from /etc/mailname and falling back to the fully qualified
       hostname when that file does not exist).

       The author.name and committer.name and their corresponding email
       options override user.name and user.email if set and are overridden
       themselves by the environment variables.

       The typical usage is to set just the user.name and user.email
       variables; the other options are provided for more complex use cases.

DATE FORMATS
       The GIT_AUTHOR_DATE, GIT_COMMITTER_DATE environment variables and the
       --date option support the following date formats:

       Git internal format
           It is <unix timestamp> <time zone offset>, where <unix timestamp>
           is the number of seconds since the UNIX epoch.  <time zone offset>
           is a positive or negative offset from UTC. For example CET (which
           is 1 hour ahead of UTC) is +0100.

       RFC 2822
           The standard email format as described by RFC 2822, for example
           Thu, 07 Apr 2005 22:13:13 +0200.

       ISO 8601
           Time and date specified by the ISO 8601 standard, for example
           2005-04-07T22:13:13. The parser accepts a space instead of the T
           character as well. Fractional parts of a second will be ignored,
           for example 2005-04-07T22:13:13.019 will be treated as
           2005-04-07T22:13:13.

               Note
               In addition, the date part is accepted in the following
               formats: YYYY.MM.DD, MM/DD/YYYY and DD.MM.YYYY.

DISCUSSION
       Though not required, it's a good idea to begin the commit message with
       a single short (less than 50 character) line summarizing the change,
       followed by a blank line and then a more thorough description. The text
       up to the first blank line in a commit message is treated as the commit
       title, and that title is used throughout Git. For example, git-format-
       patch(1) turns a commit into email, and it uses the title on the
       Subject line and the rest of the commit in the body.

       Git is to some extent character encoding agnostic.

       o   The contents of the blob objects are uninterpreted sequences of
           bytes. There is no encoding translation at the core level.

       o   Path names are encoded in UTF-8 normalization form C. This applies
           to tree objects, the index file, ref names, as well as path names
           in command line arguments, environment variables and config files
           (.git/config (see git-config(1)), gitignore(5), gitattributes(5)
           and gitmodules(5)).

           Note that Git at the core level treats path names simply as
           sequences of non-NUL bytes, there are no path name encoding
           conversions (except on Mac and Windows). Therefore, using non-ASCII
           path names will mostly work even on platforms and file systems that
           use legacy extended ASCII encodings. However, repositories created
           on such systems will not work properly on UTF-8-based systems (e.g.
           Linux, Mac, Windows) and vice versa. Additionally, many Git-based
           tools simply assume path names to be UTF-8 and will fail to display
           other encodings correctly.

       o   Commit log messages are typically encoded in UTF-8, but other
           extended ASCII encodings are also supported. This includes
           ISO-8859-x, CP125x and many others, but not UTF-16/32, EBCDIC and
           CJK multi-byte encodings (GBK, Shift-JIS, Big5, EUC-x, CP9xx etc.).

       Although we encourage that the commit log messages are encoded in
       UTF-8, both the core and Git Porcelain are designed not to force UTF-8
       on projects. If all participants of a particular project find it more
       convenient to use legacy encodings, Git does not forbid it. However,
       there are a few things to keep in mind.

        1. git commit and git commit-tree issues a warning if the commit log
           message given to it does not look like a valid UTF-8 string, unless
           you explicitly say your project uses a legacy encoding. The way to
           say this is to have i18n.commitencoding in .git/config file, like
           this:

               [i18n]
                       commitEncoding = ISO-8859-1

           Commit objects created with the above setting record the value of
           i18n.commitEncoding in its encoding header. This is to help other
           people who look at them later. Lack of this header implies that the
           commit log message is encoded in UTF-8.

        2. git log, git show, git blame and friends look at the encoding
           header of a commit object, and try to re-code the log message into
           UTF-8 unless otherwise specified. You can specify the desired
           output encoding with i18n.logOutputEncoding in .git/config file,
           like this:

               [i18n]
                       logOutputEncoding = ISO-8859-1

           If you do not have this configuration variable, the value of
           i18n.commitEncoding is used instead.

       Note that we deliberately chose not to re-code the commit log message
       when a commit is made to force UTF-8 at the commit object level,
       because re-coding to UTF-8 is not necessarily a reversible operation.

ENVIRONMENT AND CONFIGURATION VARIABLES
       The editor used to edit the commit log message will be chosen from the
       GIT_EDITOR environment variable, the core.editor configuration
       variable, the VISUAL environment variable, or the EDITOR environment
       variable (in that order). See git-var(1) for details.

HOOKS
       This command can run commit-msg, prepare-commit-msg, pre-commit,
       post-commit and post-rewrite hooks. See githooks(5) for more
       information.

FILES
       $GIT_DIR/COMMIT_EDITMSG
           This file contains the commit message of a commit in progress. If
           git commit exits due to an error before creating a commit, any
           commit message that has been provided by the user (e.g., in an
           editor session) will be available in this file, but will be
           overwritten by the next invocation of git commit.

SEE ALSO
       git-add(1), git-rm(1), git-mv(1), git-merge(1), git-commit-tree(1)

GIT
       Part of the git(1) suite



Git 2.30.1.378.g1d4f23            02/08/2021                     GIT-COMMIT(1)
```



## `merge`




```
GIT-MERGE(1)                      Git Manual                      GIT-MERGE(1)



NAME
       git-merge - 2つ以上の開発履歴を結合する

SYNOPSIS
       git merge [-n] [--stat] [--no-commit] [--squash] [--[no-]edit]
               [--no-verify] [-s <strategy>] [-X <strategy-option>] [-S[<keyid>]]
               [--[no-]allow-unrelated-histories]
               [--[no-]rerere-autoupdate] [-m <msg>] [-F <file>] [<commit>...]
       git merge (--continue | --abort | --quit)


DESCRIPTION
       名前付きコミットからの変更を（履歴が現在のブランチから分岐したため）現在のブランチに組み込みます。
       このコマンドは、git pull が別のリポジトリからの変更を組み込むために使用し、
       手動で1つのブランチから別のブランチに変更をマージするために使用できます。
       
       次の履歴が存在し、現在のブランチが「main」であると想定します：

                     A---B---C topic
                    /
               D---E---F---G main

       
       次に、「git merge topic」は、マスター（つまり、E）から分岐してから現在のコミット（C）までマスターの
       上にある topic ブランチで行われた変更を再生し、その結果を、2つの親コミットの名前と
       変更を説明するユーザーからのログメッセージと共に新しいコミットに記録します。

                     A---B---C topic
                    /         \
               D---E---F---G---H main

       
       2番目の構文（「"git merge --abort」）は、マージによってコンフリクトが発生した後にのみ実行できます。
       git merge --abort はマージプロセスを中止し、マージ前の状態を再構築しようとします。
       ただし、マージの開始時にコミットされていない変更があった場合（特に、マージの開始後にそれらの変更が
       さらに変更された場合）、git merge --abort は、元の（マージ前の）変更を再構築できない場合があります。
       したがって：
       
       警告：重要なコミットされていない変更を使用して git merge を実行することはお勧めしません。
       可能ではありますが、コンフリクトが発生した場合に元に戻すのが難しい状態になる可能性があります。
       
       3番目の構文（「git merge --continue」）は、マージによってコンフリクトが発生した後にのみ実行できます。


OPTIONS
       --commit, --no-commit
           Perform the merge and commit the result. This option can be used to
           override --no-commit.

           With --no-commit perform the merge and stop just before creating a
           merge commit, to give the user a chance to inspect and further
           tweak the merge result before committing.

           Note that fast-forward updates do not create a merge commit and
           therefore there is no way to stop those merges with --no-commit.
           Thus, if you want to ensure your branch is not changed or updated
           by the merge command, use --no-ff with --no-commit.

       --edit, -e, --no-edit
           Invoke an editor before committing successful mechanical merge to
           further edit the auto-generated merge message, so that the user can
           explain and justify the merge. The --no-edit option can be used to
           accept the auto-generated message (this is generally discouraged).
           The --edit (or -e) option is still useful if you are giving a draft
           message with the -m option from the command line and want to edit
           it in the editor.

           Older scripts may depend on the historical behaviour of not
           allowing the user to edit the merge log message. They will see an
           editor opened when they run git merge. To make it easier to adjust
           such scripts to the updated behaviour, the environment variable
           GIT_MERGE_AUTOEDIT can be set to no at the beginning of them.

       --cleanup=<mode>
           This option determines how the merge message will be cleaned up
           before committing. See git-commit(1) for more details. In addition,
           if the <mode> is given a value of scissors, scissors will be
           appended to MERGE_MSG before being passed on to the commit
           machinery in the case of a merge conflict.

       --ff, --no-ff, --ff-only
           Specifies how a merge is handled when the merged-in history is
           already a descendant of the current history.  --ff is the default
           unless merging an annotated (and possibly signed) tag that is not
           stored in its natural place in the refs/tags/ hierarchy, in which
           case --no-ff is assumed.

           With --ff, when possible resolve the merge as a fast-forward (only
           update the branch pointer to match the merged branch; do not create
           a merge commit). When not possible (when the merged-in history is
           not a descendant of the current history), create a merge commit.

           With --no-ff, create a merge commit in all cases, even when the
           merge could instead be resolved as a fast-forward.

           With --ff-only, resolve the merge as a fast-forward when possible.
           When not possible, refuse to merge and exit with a non-zero status.

       -S[<keyid>], --gpg-sign[=<keyid>], --no-gpg-sign
           GPG-sign the resulting merge commit. The keyid argument is optional
           and defaults to the committer identity; if specified, it must be
           stuck to the option without a space.  --no-gpg-sign is useful to
           countermand both commit.gpgSign configuration variable, and earlier
           --gpg-sign.

       --log[=<n>], --no-log
           In addition to branch names, populate the log message with one-line
           descriptions from at most <n> actual commits that are being merged.
           See also git-fmt-merge-msg(1).

           With --no-log do not list one-line descriptions from the actual
           commits being merged.

       --signoff, --no-signoff
           Add a Signed-off-by trailer by the committer at the end of the
           commit log message. The meaning of a signoff depends on the project
           to which you're committing. For example, it may certify that the
           committer has the rights to submit the work under the project's
           license or agrees to some contributor representation, such as a
           Developer Certificate of Origin. (See
           http://developercertificate.org for the one used by the Linux
           kernel and Git projects.) Consult the documentation or leadership
           of the project to which you're contributing to understand how the
           signoffs are used in that project.

           The --no-signoff option can be used to countermand an earlier
           --signoff option on the command line.

       --stat, -n, --no-stat
           Show a diffstat at the end of the merge. The diffstat is also
           controlled by the configuration option merge.stat.

           With -n or --no-stat do not show a diffstat at the end of the
           merge.

       --squash, --no-squash
           Produce the working tree and index state as if a real merge
           happened (except for the merge information), but do not actually
           make a commit, move the HEAD, or record $GIT_DIR/MERGE_HEAD (to
           cause the next git commit command to create a merge commit). This
           allows you to create a single commit on top of the current branch
           whose effect is the same as merging another branch (or more in case
           of an octopus).

           With --no-squash perform the merge and commit the result. This
           option can be used to override --squash.

           With --squash, --commit is not allowed, and will fail.

       --no-verify
           This option bypasses the pre-merge and commit-msg hooks. See also
           githooks(5).

       -s <strategy>, --strategy=<strategy>
           Use the given merge strategy; can be supplied more than once to
           specify them in the order they should be tried. If there is no -s
           option, a built-in list of strategies is used instead (git
           merge-recursive when merging a single head, git merge-octopus
           otherwise).

       -X <option>, --strategy-option=<option>
           Pass merge strategy specific option through to the merge strategy.

       --verify-signatures, --no-verify-signatures
           Verify that the tip commit of the side branch being merged is
           signed with a valid key, i.e. a key that has a valid uid: in the
           default trust model, this means the signing key has been signed by
           a trusted key. If the tip commit of the side branch is not signed
           with a valid key, the merge is aborted.

       --summary, --no-summary
           Synonyms to --stat and --no-stat; these are deprecated and will be
           removed in the future.

       -q, --quiet
           Operate quietly. Implies --no-progress.

       -v, --verbose
           Be verbose.

       --progress, --no-progress
           Turn progress on/off explicitly. If neither is specified, progress
           is shown if standard error is connected to a terminal. Note that
           not all merge strategies may support progress reporting.

       --autostash, --no-autostash
           Automatically create a temporary stash entry before the operation
           begins, and apply it after the operation ends. This means that you
           can run the operation on a dirty worktree. However, use with care:
           the final stash application after a successful merge might result
           in non-trivial conflicts.

       --allow-unrelated-histories
           By default, git merge command refuses to merge histories that do
           not share a common ancestor. This option can be used to override
           this safety when merging histories of two projects that started
           their lives independently. As that is a very rare occasion, no
           configuration variable to enable this by default exists and will
           not be added.

       -m <msg>
           Set the commit message to be used for the merge commit (in case one
           is created).

           If --log is specified, a shortlog of the commits being merged will
           be appended to the specified message.

           The git fmt-merge-msg command can be used to give a good default
           for automated git merge invocations. The automated message can
           include the branch description.

       -F <file>, --file=<file>
           Read the commit message to be used for the merge commit (in case
           one is created).

           If --log is specified, a shortlog of the commits being merged will
           be appended to the specified message.

       --rerere-autoupdate, --no-rerere-autoupdate
           Allow the rerere mechanism to update the index with the result of
           auto-conflict resolution if possible.

       --overwrite-ignore, --no-overwrite-ignore
           Silently overwrite ignored files from the merge result. This is the
           default behavior. Use --no-overwrite-ignore to abort.

       --abort
           Abort the current conflict resolution process, and try to
           reconstruct the pre-merge state. If an autostash entry is present,
           apply it to the worktree.

           If there were uncommitted worktree changes present when the merge
           started, git merge --abort will in some cases be unable to
           reconstruct these changes. It is therefore recommended to always
           commit or stash your changes before running git merge.

           git merge --abort is equivalent to git reset --merge when
           MERGE_HEAD is present unless MERGE_AUTOSTASH is also present in
           which case git merge --abort applies the stash entry to the
           worktree whereas git reset --merge will save the stashed changes in
           the stash list.

       --quit
           Forget about the current merge in progress. Leave the index and the
           working tree as-is. If MERGE_AUTOSTASH is present, the stash entry
           will be saved to the stash list.

       --continue
           After a git merge stops due to conflicts you can conclude the merge
           by running git merge --continue (see "HOW TO RESOLVE CONFLICTS"
           section below).

       <commit>...
           Commits, usually other branch heads, to merge into our branch.
           Specifying more than one commit will create a merge with more than
           two parents (affectionately called an Octopus merge).

           If no commit is given from the command line, merge the
           remote-tracking branches that the current branch is configured to
           use as its upstream. See also the configuration section of this
           manual page.

           When FETCH_HEAD (and no other commit) is specified, the branches
           recorded in the .git/FETCH_HEAD file by the previous invocation of
           git fetch for merging are merged to the current branch.

PRE-MERGE CHECKS
       Before applying outside changes, you should get your own work in good
       shape and committed locally, so it will not be clobbered if there are
       conflicts. See also git-stash(1). git pull and git merge will stop
       without doing anything when local uncommitted changes overlap with
       files that git pull/git merge may need to update.

       To avoid recording unrelated changes in the merge commit, git pull and
       git merge will also abort if there are any changes registered in the
       index relative to the HEAD commit. (Special narrow exceptions to this
       rule may exist depending on which merge strategy is in use, but
       generally, the index must match HEAD.)

       If all named commits are already ancestors of HEAD, git merge will exit
       early with the message "Already up to date."

FAST-FORWARD MERGE
       Often the current branch head is an ancestor of the named commit. This
       is the most common case especially when invoked from git pull: you are
       tracking an upstream repository, you have committed no local changes,
       and now you want to update to a newer upstream revision. In this case,
       a new commit is not needed to store the combined history; instead, the
       HEAD (along with the index) is updated to point at the named commit,
       without creating an extra merge commit.

       This behavior can be suppressed with the --no-ff option.

TRUE MERGE
       Except in a fast-forward merge (see above), the branches to be merged
       must be tied together by a merge commit that has both of them as its
       parents.

       A merged version reconciling the changes from all branches to be merged
       is committed, and your HEAD, index, and working tree are updated to it.
       It is possible to have modifications in the working tree as long as
       they do not overlap; the update will preserve them.

       When it is not obvious how to reconcile the changes, the following
       happens:

        1. The HEAD pointer stays the same.

        2. The MERGE_HEAD ref is set to point to the other branch head.

        3. Paths that merged cleanly are updated both in the index file and in
           your working tree.

        4. For conflicting paths, the index file records up to three versions:
           stage 1 stores the version from the common ancestor, stage 2 from
           HEAD, and stage 3 from MERGE_HEAD (you can inspect the stages with
           git ls-files -u). The working tree files contain the result of the
           "merge" program; i.e. 3-way merge results with familiar conflict
           markers <<< === >>>.

        5. No other changes are made. In particular, the local modifications
           you had before you started merge will stay the same and the index
           entries for them stay as they were, i.e. matching HEAD.

       If you tried a merge which resulted in complex conflicts and want to
       start over, you can recover with git merge --abort.

MERGING TAG
       When merging an annotated (and possibly signed) tag, Git always creates
       a merge commit even if a fast-forward merge is possible, and the commit
       message template is prepared with the tag message. Additionally, if the
       tag is signed, the signature check is reported as a comment in the
       message template. See also git-tag(1).

       When you want to just integrate with the work leading to the commit
       that happens to be tagged, e.g. synchronizing with an upstream release
       point, you may not want to make an unnecessary merge commit.

       In such a case, you can "unwrap" the tag yourself before feeding it to
       git merge, or pass --ff-only when you do not have any work on your own.
       e.g.

           git fetch origin
           git merge v1.2.3^0
           git merge --ff-only v1.2.3


HOW CONFLICTS ARE PRESENTED
       During a merge, the working tree files are updated to reflect the
       result of the merge. Among the changes made to the common ancestor's
       version, non-overlapping ones (that is, you changed an area of the file
       while the other side left that area intact, or vice versa) are
       incorporated in the final result verbatim. When both sides made changes
       to the same area, however, Git cannot randomly pick one side over the
       other, and asks you to resolve it by leaving what both sides did to
       that area.

       By default, Git uses the same style as the one used by the "merge"
       program from the RCS suite to present such a conflicted hunk, like
       this:

           Here are lines that are either unchanged from the common
           ancestor, or cleanly resolved because only one side changed.
           <<<<<<< yours:sample.txt
           Conflict resolution is hard;
           let's go shopping.
           =======
           Git makes conflict resolution easy.
           >>>>>>> theirs:sample.txt
           And here is another line that is cleanly resolved or unmodified.


       The area where a pair of conflicting changes happened is marked with
       markers <<<<<<<, =======, and >>>>>>>. The part before the ======= is
       typically your side, and the part afterwards is typically their side.

       The default format does not show what the original said in the
       conflicting area. You cannot tell how many lines are deleted and
       replaced with Barbie's remark on your side. The only thing you can tell
       is that your side wants to say it is hard and you'd prefer to go
       shopping, while the other side wants to claim it is easy.

       An alternative style can be used by setting the "merge.conflictStyle"
       configuration variable to "diff3". In "diff3" style, the above conflict
       may look like this:

           Here are lines that are either unchanged from the common
           ancestor, or cleanly resolved because only one side changed.
           <<<<<<< yours:sample.txt
           Conflict resolution is hard;
           let's go shopping.
           |||||||
           Conflict resolution is hard.
           =======
           Git makes conflict resolution easy.
           >>>>>>> theirs:sample.txt
           And here is another line that is cleanly resolved or unmodified.


       In addition to the <<<<<<<, =======, and >>>>>>> markers, it uses
       another ||||||| marker that is followed by the original text. You can
       tell that the original just stated a fact, and your side simply gave in
       to that statement and gave up, while the other side tried to have a
       more positive attitude. You can sometimes come up with a better
       resolution by viewing the original.

HOW TO RESOLVE CONFLICTS
       After seeing a conflict, you can do two things:

       o   Decide not to merge. The only clean-ups you need are to reset the
           index file to the HEAD commit to reverse 2. and to clean up working
           tree changes made by 2. and 3.; git merge --abort can be used for
           this.

       o   Resolve the conflicts. Git will mark the conflicts in the working
           tree. Edit the files into shape and git add them to the index. Use
           git commit or git merge --continue to seal the deal. The latter
           command checks whether there is a (interrupted) merge in progress
           before calling git commit.

       You can work through the conflict with a number of tools:

       o   Use a mergetool.  git mergetool to launch a graphical mergetool
           which will work you through the merge.

       o   Look at the diffs.  git diff will show a three-way diff,
           highlighting changes from both the HEAD and MERGE_HEAD versions.

       o   Look at the diffs from each branch.  git log --merge -p <path> will
           show diffs first for the HEAD version and then the MERGE_HEAD
           version.

       o   Look at the originals.  git show :1:filename shows the common
           ancestor, git show :2:filename shows the HEAD version, and git show
           :3:filename shows the MERGE_HEAD version.

EXAMPLES
       o   Merge branches fixes and enhancements on top of the current branch,
           making an octopus merge:

               $ git merge fixes enhancements


       o   Merge branch obsolete into the current branch, using ours merge
           strategy:

               $ git merge -s ours obsolete


       o   Merge branch maint into the current branch, but do not make a new
           commit automatically:

               $ git merge --no-commit maint

           This can be used when you want to include further changes to the
           merge, or want to write your own merge commit message.

           You should refrain from abusing this option to sneak substantial
           changes into a merge commit. Small fixups like bumping
           release/version name would be acceptable.

MERGE STRATEGIES
       The merge mechanism (git merge and git pull commands) allows the
       backend merge strategies to be chosen with -s option. Some strategies
       can also take their own options, which can be passed by giving
       -X<option> arguments to git merge and/or git pull.

       resolve
           This can only resolve two heads (i.e. the current branch and
           another branch you pulled from) using a 3-way merge algorithm. It
           tries to carefully detect criss-cross merge ambiguities and is
           considered generally safe and fast.

       recursive
           This can only resolve two heads using a 3-way merge algorithm. When
           there is more than one common ancestor that can be used for 3-way
           merge, it creates a merged tree of the common ancestors and uses
           that as the reference tree for the 3-way merge. This has been
           reported to result in fewer merge conflicts without causing
           mismerges by tests done on actual merge commits taken from Linux
           2.6 kernel development history. Additionally this can detect and
           handle merges involving renames, but currently cannot make use of
           detected copies. This is the default merge strategy when pulling or
           merging one branch.

           The recursive strategy can take the following options:

           ours
               This option forces conflicting hunks to be auto-resolved
               cleanly by favoring our version. Changes from the other tree
               that do not conflict with our side are reflected in the merge
               result. For a binary file, the entire contents are taken from
               our side.

               This should not be confused with the ours merge strategy, which
               does not even look at what the other tree contains at all. It
               discards everything the other tree did, declaring our history
               contains all that happened in it.

           theirs
               This is the opposite of ours; note that, unlike ours, there is
               no theirs merge strategy to confuse this merge option with.

           patience
               With this option, merge-recursive spends a little extra time to
               avoid mismerges that sometimes occur due to unimportant
               matching lines (e.g., braces from distinct functions). Use this
               when the branches to be merged have diverged wildly. See also
               git-diff(1) --patience.

           diff-algorithm=[patience|minimal|histogram|myers]
               Tells merge-recursive to use a different diff algorithm, which
               can help avoid mismerges that occur due to unimportant matching
               lines (such as braces from distinct functions). See also git-
               diff(1) --diff-algorithm.

           ignore-space-change, ignore-all-space, ignore-space-at-eol,
           ignore-cr-at-eol
               Treats lines with the indicated type of whitespace change as
               unchanged for the sake of a three-way merge. Whitespace changes
               mixed with other changes to a line are not ignored. See also
               git-diff(1) -b, -w, --ignore-space-at-eol, and
               --ignore-cr-at-eol.

               o   If their version only introduces whitespace changes to a
                   line, our version is used;

               o   If our version introduces whitespace changes but their
                   version includes a substantial change, their version is
                   used;

               o   Otherwise, the merge proceeds in the usual way.

           renormalize
               This runs a virtual check-out and check-in of all three stages
               of a file when resolving a three-way merge. This option is
               meant to be used when merging branches with different clean
               filters or end-of-line normalization rules. See "Merging
               branches with differing checkin/checkout attributes" in
               gitattributes(5) for details.

           no-renormalize
               Disables the renormalize option. This overrides the
               merge.renormalize configuration variable.

           no-renames
               Turn off rename detection. This overrides the merge.renames
               configuration variable. See also git-diff(1) --no-renames.

           find-renames[=<n>]
               Turn on rename detection, optionally setting the similarity
               threshold. This is the default. This overrides the
               merge.renames configuration variable. See also git-diff(1)
               --find-renames.

           rename-threshold=<n>
               Deprecated synonym for find-renames=<n>.

           subtree[=<path>]
               This option is a more advanced form of subtree strategy, where
               the strategy makes a guess on how two trees must be shifted to
               match with each other when merging. Instead, the specified path
               is prefixed (or stripped from the beginning) to make the shape
               of two trees to match.

       octopus
           This resolves cases with more than two heads, but refuses to do a
           complex merge that needs manual resolution. It is primarily meant
           to be used for bundling topic branch heads together. This is the
           default merge strategy when pulling or merging more than one
           branch.

       ours
           This resolves any number of heads, but the resulting tree of the
           merge is always that of the current branch head, effectively
           ignoring all changes from all other branches. It is meant to be
           used to supersede old development history of side branches. Note
           that this is different from the -Xours option to the recursive
           merge strategy.

       subtree
           This is a modified recursive strategy. When merging trees A and B,
           if B corresponds to a subtree of A, B is first adjusted to match
           the tree structure of A, instead of reading the trees at the same
           level. This adjustment is also done to the common ancestor tree.

       With the strategies that use 3-way merge (including the default,
       recursive), if a change is made on both branches, but later reverted on
       one of the branches, that change will be present in the merged result;
       some people find this behavior confusing. It occurs because only the
       heads and the merge base are considered when performing a merge, not
       the individual commits. The merge algorithm therefore considers the
       reverted change as no change at all, and substitutes the changed
       version instead.

CONFIGURATION
       merge.conflictStyle
           Specify the style in which conflicted hunks are written out to
           working tree files upon merge. The default is "merge", which shows
           a <<<<<<< conflict marker, changes made by one side, a =======
           marker, changes made by the other side, and then a >>>>>>> marker.
           An alternate style, "diff3", adds a ||||||| marker and the original
           text before the ======= marker.

       merge.defaultToUpstream
           If merge is called without any commit argument, merge the upstream
           branches configured for the current branch by using their last
           observed values stored in their remote-tracking branches. The
           values of the branch.<current branch>.merge that name the branches
           at the remote named by branch.<current branch>.remote are
           consulted, and then they are mapped via remote.<remote>.fetch to
           their corresponding remote-tracking branches, and the tips of these
           tracking branches are merged.

       merge.ff
           By default, Git does not create an extra merge commit when merging
           a commit that is a descendant of the current commit. Instead, the
           tip of the current branch is fast-forwarded. When set to false,
           this variable tells Git to create an extra merge commit in such a
           case (equivalent to giving the --no-ff option from the command
           line). When set to only, only such fast-forward merges are allowed
           (equivalent to giving the --ff-only option from the command line).

       merge.verifySignatures
           If true, this is equivalent to the --verify-signatures command line
           option. See git-merge(1) for details.

       merge.branchdesc
           In addition to branch names, populate the log message with the
           branch description text associated with them. Defaults to false.

       merge.log
           In addition to branch names, populate the log message with at most
           the specified number of one-line descriptions from the actual
           commits that are being merged. Defaults to false, and true is a
           synonym for 20.

       merge.suppressDest
           By adding a glob that matches the names of integration branches to
           this multi-valued configuration variable, the default merge message
           computed for merges into these integration branches will omit "into
           <branch name>" from its title.

           An element with an empty value can be used to clear the list of
           globs accumulated from previous configuration entries. When there
           is no merge.suppressDest variable defined, the default value of
           main is used for backward compatibility.

       merge.renameLimit
           The number of files to consider when performing rename detection
           during a merge; if not specified, defaults to the value of
           diff.renameLimit. This setting has no effect if rename detection is
           turned off.

       merge.renames
           Whether Git detects renames. If set to "false", rename detection is
           disabled. If set to "true", basic rename detection is enabled.
           Defaults to the value of diff.renames.

       merge.directoryRenames
           Whether Git detects directory renames, affecting what happens at
           merge time to new files added to a directory on one side of history
           when that directory was renamed on the other side of history. If
           merge.directoryRenames is set to "false", directory rename
           detection is disabled, meaning that such new files will be left
           behind in the old directory. If set to "true", directory rename
           detection is enabled, meaning that such new files will be moved
           into the new directory. If set to "conflict", a conflict will be
           reported for such paths. If merge.renames is false,
           merge.directoryRenames is ignored and treated as false. Defaults to
           "conflict".

       merge.renormalize
           Tell Git that canonical representation of files in the repository
           has changed over time (e.g. earlier commits record text files with
           CRLF line endings, but recent ones use LF line endings). In such a
           repository, Git can convert the data recorded in commits to a
           canonical form before performing a merge to reduce unnecessary
           conflicts. For more information, see section "Merging branches with
           differing checkin/checkout attributes" in gitattributes(5).

       merge.stat
           Whether to print the diffstat between ORIG_HEAD and the merge
           result at the end of the merge. True by default.

       merge.autoStash
           When set to true, automatically create a temporary stash entry
           before the operation begins, and apply it after the operation ends.
           This means that you can run merge on a dirty worktree. However, use
           with care: the final stash application after a successful merge
           might result in non-trivial conflicts. This option can be
           overridden by the --no-autostash and --autostash options of git-
           merge(1). Defaults to false.

       merge.tool
           Controls which merge tool is used by git-mergetool(1). The list
           below shows the valid built-in values. Any other value is treated
           as a custom merge tool and requires that a corresponding
           mergetool.<tool>.cmd variable is defined.

       merge.guitool
           Controls which merge tool is used by git-mergetool(1) when the
           -g/--gui flag is specified. The list below shows the valid built-in
           values. Any other value is treated as a custom merge tool and
           requires that a corresponding mergetool.<guitool>.cmd variable is
           defined.

           o   araxis

           o   bc

           o   bc3

           o   bc4

           o   codecompare

           o   deltawalker

           o   diffmerge

           o   diffuse

           o   ecmerge

           o   emerge

           o   examdiff

           o   guiffy

           o   gvimdiff

           o   gvimdiff2

           o   gvimdiff3

           o   kdiff3

           o   meld

           o   nvimdiff

           o   nvimdiff2

           o   nvimdiff3

           o   opendiff

           o   p4merge

           o   smerge

           o   tkdiff

           o   tortoisemerge

           o   vimdiff

           o   vimdiff2

           o   vimdiff3

           o   winmerge

           o   xxdiff

       merge.verbosity
           Controls the amount of output shown by the recursive merge
           strategy. Level 0 outputs nothing except a final error message if
           conflicts were detected. Level 1 outputs only conflicts, 2 outputs
           conflicts and file changes. Level 5 and above outputs debugging
           information. The default is level 2. Can be overridden by the
           GIT_MERGE_VERBOSITY environment variable.

       merge.<driver>.name
           Defines a human-readable name for a custom low-level merge driver.
           See gitattributes(5) for details.

       merge.<driver>.driver
           Defines the command that implements a custom low-level merge
           driver. See gitattributes(5) for details.

       merge.<driver>.recursive
           Names a low-level merge driver to be used when performing an
           internal merge between common ancestors. See gitattributes(5) for
           details.

       branch.<name>.mergeOptions
           Sets default options for merging into branch <name>. The syntax and
           supported options are the same as those of git merge, but option
           values containing whitespace characters are currently not
           supported.

SEE ALSO
       git-fmt-merge-msg(1), git-pull(1), gitattributes(5), git-reset(1), git-
       diff(1), git-ls-files(1), git-add(1), git-rm(1), git-mergetool(1)

GIT
       Part of the git(1) suite



Git 2.30.1.378.g1d4f23            02/08/2021                      GIT-MERGE(1)
```



## `rebase`

:::danger リベースの禁止事項

「リモートリポジトリにプッシュしたコミット」をリベースするのは絶対にしないこと。ローカルとリモートで不整合になり、その後のプッシュが失敗するようになってしまいます。

:::


```
GIT-REBASE(1)                     Git Manual                     GIT-REBASE(1)



NAME
       git-rebase - 別のベースチップの上にコミットを再適用する

SYNOPSIS
       git rebase [-i | --interactive] [<options>] [--exec <cmd>]
               [--onto <newbase> | --keep-base] [<upstream> [<branch>]]
       git rebase [-i | --interactive] [<options>] [--exec <cmd>] [--onto <newbase>]
               --root [<branch>]
       git rebase (--continue | --skip | --abort | --quit | --edit-todo | --show-current-patch)


DESCRIPTION       
       <branch> が指定されている場合、git rebase は他の処理を行う前に自動的に
       git switch <branch> を実行します。
       それ以外の場合は、現在のブランチに残ります。
       
       <upstream> が指定されていない場合、branch.<name> .remote および
       branch.<name>.merge オプションで構成されたアップストリーム（詳細は git-config(1) を参照）が
       使用され、--fork-point オプションが想定されます。
       現在ブランチを使用していない場合、または現在のブランチにアップストリームが構成されていない場合、
       リベースは中止されます。
       
       現在のブランチでコミットによって行われたが <upstream> にないすべての変更は、一時領域に保存されます。
       これは、git log <upstream>..HEADで表示されるのと同じコミットのセットです。
       または、--fork-point がアクティブな場合は、git log'fork_point'..HEAD を使用します
       （以下の --fork-point の説明を参照してください）。
       または、--root オプションが指定されている場合は、git log HEAD を使用します。
       
       現在のブランチは <upstream> にリセットされ、--onto オプションが指定されている場合は
       <newbase> にリセットされます。
       これは、git reset --hard <upstream>（または <newbase>）とまったく同じ効果があります。
       ORIG_HEAD は、リセット前にブランチの先端を指すように設定されています。
       
       以前に一時領域に保存されたコミットは、現在のブランチに1つずつ順番に再適用されます。
       HEAD..<upstream> でのコミットと同じテキスト変更を導入する HEAD でのコミットは省略されることに
       注意してください（つまり、パッチは異なるコミットメッセージまたはスキップされるタイムスタンプの
       アップストリームですでに受け入れられています）。
       
       マージが失敗すると、このプロセスが完全に自動化されなくなる可能性があります。
       このようなマージの失敗を解決し、git rebase --continue を実行する必要があります。
       もう1つのオプションは、git rebase --skip を使用してマージの失敗を引き起こしたコミットを
       バイパスすることです。
       元の <branch> をチェックアウトし、.git/rebase-apply 作業ファイルを削除するには、
       代わりにコマンド git rebase --abort を使用します。

       次の履歴が存在し、現在のブランチが「topic」であると想定します：

                     A---B---C topic
                    /
               D---E---F---G main


       この時点から、次のコマンドのいずれかの結果：

           git rebase main
           git rebase main topic

       こうなります:

                             A'--B'--C' topic
                            /
               D---E---F---G main


       注：後者の形式は、git checkout topic の省略形であり、その後に git rebase main が続きます。
       リベースが終了すると、topic はチェックアウトされたブランチのままになります。
       
       アップストリームブランチに、行った変更がすでに含まれている場合（たとえば、アップストリームに適用された
       パッチをメールで送信したため）、そのコミットはスキップされます。
       たとえば、次の履歴で git rebase main を実行します
       （A' と A は同じ変更セットを導入しますが、コミッター情報は異なります）：

                     A---B---C topic
                    /
               D---E---A'---F main


       結果は次のようになります:

                              B'---C' topic
                             /
               D---E---A'---F main


       これは、rebase --onto を使用して、topic ブランチを後者のブランチからフォークしたふりをするために、
       あるブランチに基づいて topic ブランチを別のブランチに移植する方法です。
       
       まず、topic が next ブランチに基づいていると仮定しましょう。
       たとえば、topic で開発された機能は、next に見られるいくつかの機能に依存します。

               o---o---o---o---o  main
                    \
                     o---o---o---o---o  next
                                      \
                                       o---o---o  topic

       
       main ブランチから topic をフォークしたいと思います。
       たとえば、topic が依存する機能がより安定した main ブランチにマージされたためです。
       ツリーを次のように表示します：

               o---o---o---o---o  main
                   |            \
                   |             o'--o'--o'  topic
                    \
                     o---o---o---o---o  next


       これは、次のコマンドを使用して取得できます：

           git rebase --onto main next topic
       
       --onto オプションの別の例は、ブランチの一部をリベースすることです。次のような状況の場合：

                                       H---I---J topicB
                                      /
                             E---F---G  topicA
                            /
               A---B---C---D  main


       次のコマンド

           git rebase --onto main topicA topicB

       結果は次のようになります：

                            H'--I'--J'  topicB
                           /
                           | E---F---G  topicA
                           |/
               A---B---C---D  main


       これは、topicB が topicA に依存していない場合に役立ちます。

       A range of commits could also be removed with rebase. If we have the
       following situation:
       
       コミットの範囲は、リベースで削除することもできます。次のような状況の場合：

               E---F---G---H---I---J  topicA


       次のコマンド

           git rebase --onto topicA~5 topicA~3 topicA

       コミット F と G が削除されます：

               E---H'---I'---J'  topicA

       
       これは、F と G に何らかの欠陥がある場合、または topicA の一部にすべきではない場合に役立ちます。
       --onto および <upstream> パラメーターの引数は、任意の有効な commit-ish にすることが
       できることに注意してください。

       コンフリクトが発生した場合、git rebase は最初の問題のあるコミットで停止し、
       ツリーにコンフリクトマーカーを残します。
       git diff を使用してマーカー（<<<<<<）を見つけ、編集してコンフリクトを解決できます。
       編集するファイルごとに、コンフリクトが解決されたことを Git に通知する必要があります。
       通常、これは次の方法で行われます。

           git add <filename>

       コンフリクトを手動で解決し、必要な解決策でインデックスを更新した後、
       次のコマンドでリベースプロセスを続行できます。

           git rebase --continue

       或いは、git rebase で元に戻すこともできます。

           git rebase --abort

CONFIGURATION
       rebase.useBuiltin
           Unused configuration variable. Used in Git versions 2.20 and 2.21
           as an escape hatch to enable the legacy shellscript implementation
           of rebase. Now the built-in rewrite of it in C is always used.
           Setting this will emit a warning, to alert any remaining users that
           setting this now does nothing.

       rebase.backend
           Default backend to use for rebasing. Possible choices are apply or
           merge. In the future, if the merge backend gains all remaining
           capabilities of the apply backend, this setting may become unused.

       rebase.stat
           Whether to show a diffstat of what changed upstream since the last
           rebase. False by default.

       rebase.autoSquash
           If set to true enable --autosquash option by default.

       rebase.autoStash
           When set to true, automatically create a temporary stash entry
           before the operation begins, and apply it after the operation ends.
           This means that you can run rebase on a dirty worktree. However,
           use with care: the final stash application after a successful
           rebase might result in non-trivial conflicts. This option can be
           overridden by the --no-autostash and --autostash options of git-
           rebase(1). Defaults to false.

       rebase.missingCommitsCheck
           If set to "warn", git rebase -i will print a warning if some
           commits are removed (e.g. a line was deleted), however the rebase
           will still proceed. If set to "error", it will print the previous
           warning and stop the rebase, git rebase --edit-todo can then be
           used to correct the error. If set to "ignore", no checking is done.
           To drop a commit without warning or error, use the drop command in
           the todo list. Defaults to "ignore".

       rebase.instructionFormat
           A format string, as specified in git-log(1), to be used for the
           todo list during an interactive rebase. The format will
           automatically have the long commit hash prepended to the format.

       rebase.abbreviateCommands
           If set to true, git rebase will use abbreviated command names in
           the todo list resulting in something like this:

                       p deadbee The oneline of the commit
                       p fa1afe1 The oneline of the next commit
                       ...

           instead of:

                       pick deadbee The oneline of the commit
                       pick fa1afe1 The oneline of the next commit
                       ...

           Defaults to false.

       rebase.rescheduleFailedExec
           Automatically reschedule exec commands that failed. This only makes
           sense in interactive mode (or when an --exec option was provided).
           This is the same as specifying the --reschedule-failed-exec option.

       sequence.editor
           Text editor used by git rebase -i for editing the rebase
           instruction file. The value is meant to be interpreted by the shell
           when it is used. It can be overridden by the GIT_SEQUENCE_EDITOR
           environment variable. When not configured the default commit
           message editor is used instead.

OPTIONS
       --onto <newbase>
           Starting point at which to create the new commits. If the --onto
           option is not specified, the starting point is <upstream>. May be
           any valid commit, and not just an existing branch name.

           As a special case, you may use "A...B" as a shortcut for the merge
           base of A and B if there is exactly one merge base. You can leave
           out at most one of A and B, in which case it defaults to HEAD.

       --keep-base
           Set the starting point at which to create the new commits to the
           merge base of <upstream> <branch>. Running git rebase --keep-base
           <upstream> <branch> is equivalent to running git rebase --onto
           <upstream>... <upstream>.

           This option is useful in the case where one is developing a feature
           on top of an upstream branch. While the feature is being worked on,
           the upstream branch may advance and it may not be the best idea to
           keep rebasing on top of the upstream but to keep the base commit
           as-is.

           Although both this option and --fork-point find the merge base
           between <upstream> and <branch>, this option uses the merge base as
           the starting point on which new commits will be created, whereas
           --fork-point uses the merge base to determine the set of commits
           which will be rebased.

           See also INCOMPATIBLE OPTIONS below.

       <upstream>
           Upstream branch to compare against. May be any valid commit, not
           just an existing branch name. Defaults to the configured upstream
           for the current branch.

       <branch>
           Working branch; defaults to HEAD.

       --continue
           Restart the rebasing process after having resolved a merge
           conflict.

       --abort
           Abort the rebase operation and reset HEAD to the original branch.
           If <branch> was provided when the rebase operation was started,
           then HEAD will be reset to <branch>. Otherwise HEAD will be reset
           to where it was when the rebase operation was started.

       --quit
           Abort the rebase operation but HEAD is not reset back to the
           original branch. The index and working tree are also left unchanged
           as a result. If a temporary stash entry was created using
           --autostash, it will be saved to the stash list.

       --apply
           Use applying strategies to rebase (calling git-am internally). This
           option may become a no-op in the future once the merge backend
           handles everything the apply one does.

           See also INCOMPATIBLE OPTIONS below.

       --empty={drop,keep,ask}
           How to handle commits that are not empty to start and are not clean
           cherry-picks of any upstream commit, but which become empty after
           rebasing (because they contain a subset of already upstream
           changes). With drop (the default), commits that become empty are
           dropped. With keep, such commits are kept. With ask (implied by
           --interactive), the rebase will halt when an empty commit is
           applied allowing you to choose whether to drop it, edit files more,
           or just commit the empty changes. Other options, like --exec, will
           use the default of drop unless -i/--interactive is explicitly
           specified.

           Note that commits which start empty are kept (unless
           --no-keep-empty is specified), and commits which are clean
           cherry-picks (as determined by git log --cherry-mark ...) are
           detected and dropped as a preliminary step (unless
           --reapply-cherry-picks is passed).

           See also INCOMPATIBLE OPTIONS below.

       --no-keep-empty, --keep-empty
           Do not keep commits that start empty before the rebase (i.e. that
           do not change anything from its parent) in the result. The default
           is to keep commits which start empty, since creating such commits
           requires passing the --allow-empty override flag to git commit,
           signifying that a user is very intentionally creating such a commit
           and thus wants to keep it.

           Usage of this flag will probably be rare, since you can get rid of
           commits that start empty by just firing up an interactive rebase
           and removing the lines corresponding to the commits you don't want.
           This flag exists as a convenient shortcut, such as for cases where
           external tools generate many empty commits and you want them all
           removed.

           For commits which do not start empty but become empty after
           rebasing, see the --empty flag.

           See also INCOMPATIBLE OPTIONS below.

       --reapply-cherry-picks, --no-reapply-cherry-picks
           Reapply all clean cherry-picks of any upstream commit instead of
           preemptively dropping them. (If these commits then become empty
           after rebasing, because they contain a subset of already upstream
           changes, the behavior towards them is controlled by the --empty
           flag.)

           By default (or if --no-reapply-cherry-picks is given), these
           commits will be automatically dropped. Because this necessitates
           reading all upstream commits, this can be expensive in repos with a
           large number of upstream commits that need to be read.

           --reapply-cherry-picks allows rebase to forgo reading all upstream
           commits, potentially improving performance.

           See also INCOMPATIBLE OPTIONS below.

       --allow-empty-message
           No-op. Rebasing commits with an empty message used to fail and this
           option would override that behavior, allowing commits with empty
           messages to be rebased. Now commits with an empty message do not
           cause rebasing to halt.

           See also INCOMPATIBLE OPTIONS below.

       --skip
           Restart the rebasing process by skipping the current patch.

       --edit-todo
           Edit the todo list during an interactive rebase.

       --show-current-patch
           Show the current patch in an interactive rebase or when rebase is
           stopped because of conflicts. This is the equivalent of git show
           REBASE_HEAD.

       -m, --merge
           Use merging strategies to rebase. When the recursive (default)
           merge strategy is used, this allows rebase to be aware of renames
           on the upstream side. This is the default.

           Note that a rebase merge works by replaying each commit from the
           working branch on top of the <upstream> branch. Because of this,
           when a merge conflict happens, the side reported as ours is the
           so-far rebased series, starting with <upstream>, and theirs is the
           working branch. In other words, the sides are swapped.

           See also INCOMPATIBLE OPTIONS below.

       -s <strategy>, --strategy=<strategy>
           Use the given merge strategy. If there is no -s option git
           merge-recursive is used instead. This implies --merge.

           Because git rebase replays each commit from the working branch on
           top of the <upstream> branch using the given strategy, using the
           ours strategy simply empties all patches from the <branch>, which
           makes little sense.

           See also INCOMPATIBLE OPTIONS below.

       -X <strategy-option>, --strategy-option=<strategy-option>
           Pass the <strategy-option> through to the merge strategy. This
           implies --merge and, if no strategy has been specified, -s
           recursive. Note the reversal of ours and theirs as noted above for
           the -m option.

           See also INCOMPATIBLE OPTIONS below.

       --rerere-autoupdate, --no-rerere-autoupdate
           Allow the rerere mechanism to update the index with the result of
           auto-conflict resolution if possible.

       -S[<keyid>], --gpg-sign[=<keyid>], --no-gpg-sign
           GPG-sign commits. The keyid argument is optional and defaults to
           the committer identity; if specified, it must be stuck to the
           option without a space.  --no-gpg-sign is useful to countermand
           both commit.gpgSign configuration variable, and earlier --gpg-sign.

       -q, --quiet
           Be quiet. Implies --no-stat.

       -v, --verbose
           Be verbose. Implies --stat.

       --stat
           Show a diffstat of what changed upstream since the last rebase. The
           diffstat is also controlled by the configuration option
           rebase.stat.

       -n, --no-stat
           Do not show a diffstat as part of the rebase process.

       --no-verify
           This option bypasses the pre-rebase hook. See also githooks(5).

       --verify
           Allows the pre-rebase hook to run, which is the default. This
           option can be used to override --no-verify. See also githooks(5).

       -C<n>
           Ensure at least <n> lines of surrounding context match before and
           after each change. When fewer lines of surrounding context exist
           they all must match. By default no context is ever ignored. Implies
           --apply.

           See also INCOMPATIBLE OPTIONS below.

       --no-ff, --force-rebase, -f
           Individually replay all rebased commits instead of fast-forwarding
           over the unchanged ones. This ensures that the entire history of
           the rebased branch is composed of new commits.

           You may find this helpful after reverting a topic branch merge, as
           this option recreates the topic branch with fresh commits so it can
           be remerged successfully without needing to "revert the reversion"
           (see the revert-a-faulty-merge How-To[1] for details).

       --fork-point, --no-fork-point
           Use reflog to find a better common ancestor between <upstream> and
           <branch> when calculating which commits have been introduced by
           <branch>.

           When --fork-point is active, fork_point will be used instead of
           <upstream> to calculate the set of commits to rebase, where
           fork_point is the result of git merge-base --fork-point <upstream>
           <branch> command (see git-merge-base(1)). If fork_point ends up
           being empty, the <upstream> will be used as a fallback.

           If <upstream> is given on the command line, then the default is
           --no-fork-point, otherwise the default is --fork-point.

           If your branch was based on <upstream> but <upstream> was rewound
           and your branch contains commits which were dropped, this option
           can be used with --keep-base in order to drop those commits from
           your branch.

           See also INCOMPATIBLE OPTIONS below.

       --ignore-whitespace
           Ignore whitespace differences when trying to reconcile differences.
           Currently, each backend implements an approximation of this
           behavior:

           apply backend: When applying a patch, ignore changes in whitespace
           in context lines. Unfortunately, this means that if the "old" lines
           being replaced by the patch differ only in whitespace from the
           existing file, you will get a merge conflict instead of a
           successful patch application.

           merge backend: Treat lines with only whitespace changes as
           unchanged when merging. Unfortunately, this means that any patch
           hunks that were intended to modify whitespace and nothing else will
           be dropped, even if the other side had no changes that conflicted.

       --whitespace=<option>
           This flag is passed to the git apply program (see git-apply(1))
           that applies the patch. Implies --apply.

           See also INCOMPATIBLE OPTIONS below.

       --committer-date-is-author-date
           Instead of using the current time as the committer date, use the
           author date of the commit being rebased as the committer date. This
           option implies --force-rebase.

       --ignore-date, --reset-author-date
           Instead of using the author date of the original commit, use the
           current time as the author date of the rebased commit. This option
           implies --force-rebase.

           See also INCOMPATIBLE OPTIONS below.

       --signoff
           Add a Signed-off-by trailer to all the rebased commits. Note that
           if --interactive is given then only commits marked to be picked,
           edited or reworded will have the trailer added.

           See also INCOMPATIBLE OPTIONS below.

       -i, --interactive
           Make a list of the commits which are about to be rebased. Let the
           user edit that list before rebasing. This mode can also be used to
           split commits (see SPLITTING COMMITS below).

           The commit list format can be changed by setting the configuration
           option rebase.instructionFormat. A customized instruction format
           will automatically have the long commit hash prepended to the
           format.

           See also INCOMPATIBLE OPTIONS below.

       -r, --rebase-merges[=(rebase-cousins|no-rebase-cousins)]
           By default, a rebase will simply drop merge commits from the todo
           list, and put the rebased commits into a single, linear branch.
           With --rebase-merges, the rebase will instead try to preserve the
           branching structure within the commits that are to be rebased, by
           recreating the merge commits. Any resolved merge conflicts or
           manual amendments in these merge commits will have to be
           resolved/re-applied manually.

           By default, or when no-rebase-cousins was specified, commits which
           do not have <upstream> as direct ancestor will keep their original
           branch point, i.e. commits that would be excluded by git-log(1)'s
           --ancestry-path option will keep their original ancestry by
           default. If the rebase-cousins mode is turned on, such commits are
           instead rebased onto <upstream> (or <onto>, if specified).

           The --rebase-merges mode is similar in spirit to the deprecated
           --preserve-merges but works with interactive rebases, where commits
           can be reordered, inserted and dropped at will.

           It is currently only possible to recreate the merge commits using
           the recursive merge strategy; Different merge strategies can be
           used only via explicit exec git merge -s <strategy> [...]
           commands.

           See also REBASING MERGES and INCOMPATIBLE OPTIONS below.

       -p, --preserve-merges
           [DEPRECATED: use --rebase-merges instead] Recreate merge commits
           instead of flattening the history by replaying commits a merge
           commit introduces. Merge conflict resolutions or manual amendments
           to merge commits are not preserved.

           This uses the --interactive machinery internally, but combining it
           with the --interactive option explicitly is generally not a good
           idea unless you know what you are doing (see BUGS below).

           See also INCOMPATIBLE OPTIONS below.

       -x <cmd>, --exec <cmd>
           Append "exec <cmd>" after each line creating a commit in the final
           history. <cmd> will be interpreted as one or more shell commands.
           Any command that fails will interrupt the rebase, with exit code 1.

           You may execute several commands by either using one instance of
           --exec with several commands:

               git rebase -i --exec "cmd1 && cmd2 && ..."

           or by giving more than one --exec:

               git rebase -i --exec "cmd1" --exec "cmd2" --exec ...

           If --autosquash is used, "exec" lines will not be appended for the
           intermediate commits, and will only appear at the end of each
           squash/fixup series.

           This uses the --interactive machinery internally, but it can be run
           without an explicit --interactive.

           See also INCOMPATIBLE OPTIONS below.

       --root
           Rebase all commits reachable from <branch>, instead of limiting
           them with an <upstream>. This allows you to rebase the root
           commit(s) on a branch. When used with --onto, it will skip changes
           already contained in <newbase> (instead of <upstream>) whereas
           without --onto it will operate on every change. When used together
           with both --onto and --preserve-merges, all root commits will be
           rewritten to have <newbase> as parent instead.

           See also INCOMPATIBLE OPTIONS below.

       --autosquash, --no-autosquash
           When the commit log message begins with "squash! ..." (or "fixup!
           ..."), and there is already a commit in the todo list that matches
           the same ..., automatically modify the todo list of rebase -i so
           that the commit marked for squashing comes right after the commit
           to be modified, and change the action of the moved commit from pick
           to squash (or fixup). A commit matches the ...  if the commit
           subject matches, or if the ...  refers to the commit's hash. As a
           fall-back, partial matches of the commit subject work, too. The
           recommended way to create fixup/squash commits is by using the
           --fixup/--squash options of git-commit(1).

           If the --autosquash option is enabled by default using the
           configuration variable rebase.autoSquash, this option can be used
           to override and disable this setting.

           See also INCOMPATIBLE OPTIONS below.

       --autostash, --no-autostash
           Automatically create a temporary stash entry before the operation
           begins, and apply it after the operation ends. This means that you
           can run rebase on a dirty worktree. However, use with care: the
           final stash application after a successful rebase might result in
           non-trivial conflicts.

       --reschedule-failed-exec, --no-reschedule-failed-exec
           Automatically reschedule exec commands that failed. This only makes
           sense in interactive mode (or when an --exec option was provided).

INCOMPATIBLE OPTIONS
       The following options:

       o   --apply

       o   --whitespace

       o   -C

       are incompatible with the following options:

       o   --merge

       o   --strategy

       o   --strategy-option

       o   --allow-empty-message

       o   --[no-]autosquash

       o   --rebase-merges

       o   --preserve-merges

       o   --interactive

       o   --exec

       o   --no-keep-empty

       o   --empty=

       o   --reapply-cherry-picks

       o   --edit-todo

       o   --root when used in combination with --onto

       In addition, the following pairs of options are incompatible:

       o   --preserve-merges and --interactive

       o   --preserve-merges and --signoff

       o   --preserve-merges and --rebase-merges

       o   --preserve-merges and --empty=

       o   --preserve-merges and --ignore-whitespace

       o   --preserve-merges and --committer-date-is-author-date

       o   --preserve-merges and --ignore-date

       o   --keep-base and --onto

       o   --keep-base and --root

       o   --fork-point and --root

BEHAVIORAL DIFFERENCES
       git rebase has two primary backends: apply and merge. (The apply
       backend used to be known as the am backend, but the name led to
       confusion as it looks like a verb instead of a noun. Also, the merge
       backend used to be known as the interactive backend, but it is now used
       for non-interactive cases as well. Both were renamed based on
       lower-level functionality that underpinned each.) There are some subtle
       differences in how these two backends behave:

   Empty commits
       The apply backend unfortunately drops intentionally empty commits, i.e.
       commits that started empty, though these are rare in practice. It also
       drops commits that become empty and has no option for controlling this
       behavior.

       The merge backend keeps intentionally empty commits by default (though
       with -i they are marked as empty in the todo list editor, or they can
       be dropped automatically with --no-keep-empty).

       Similar to the apply backend, by default the merge backend drops
       commits that become empty unless -i/--interactive is specified (in
       which case it stops and asks the user what to do). The merge backend
       also has an --empty={drop,keep,ask} option for changing the behavior of
       handling commits that become empty.

   Directory rename detection
       Due to the lack of accurate tree information (arising from constructing
       fake ancestors with the limited information available in patches),
       directory rename detection is disabled in the apply backend. Disabled
       directory rename detection means that if one side of history renames a
       directory and the other adds new files to the old directory, then the
       new files will be left behind in the old directory without any warning
       at the time of rebasing that you may want to move these files into the
       new directory.

       Directory rename detection works with the merge backend to provide you
       warnings in such cases.

   Context
       The apply backend works by creating a sequence of patches (by calling
       format-patch internally), and then applying the patches in sequence
       (calling am internally). Patches are composed of multiple hunks, each
       with line numbers, a context region, and the actual changes. The line
       numbers have to be taken with some fuzz, since the other side will
       likely have inserted or deleted lines earlier in the file. The context
       region is meant to help find how to adjust the line numbers in order to
       apply the changes to the right lines. However, if multiple areas of the
       code have the same surrounding lines of context, the wrong one can be
       picked. There are real-world cases where this has caused commits to be
       reapplied incorrectly with no conflicts reported. Setting diff.context
       to a larger value may prevent such types of problems, but increases the
       chance of spurious conflicts (since it will require more lines of
       matching context to apply).

       The merge backend works with a full copy of each relevant file,
       insulating it from these types of problems.

   Labelling of conflicts markers
       When there are content conflicts, the merge machinery tries to annotate
       each side's conflict markers with the commits where the content came
       from. Since the apply backend drops the original information about the
       rebased commits and their parents (and instead generates new fake
       commits based off limited information in the generated patches), those
       commits cannot be identified; instead it has to fall back to a commit
       summary. Also, when merge.conflictStyle is set to diff3, the apply
       backend will use "constructed merge base" to label the content from the
       merge base, and thus provide no information about the merge base commit
       whatsoever.

       The merge backend works with the full commits on both sides of history
       and thus has no such limitations.

   Hooks
       The apply backend has not traditionally called the post-commit hook,
       while the merge backend has. Both have called the post-checkout hook,
       though the merge backend has squelched its output. Further, both
       backends only call the post-checkout hook with the starting point
       commit of the rebase, not the intermediate commits nor the final
       commit. In each case, the calling of these hooks was by accident of
       implementation rather than by design (both backends were originally
       implemented as shell scripts and happened to invoke other commands like
       git checkout or git commit that would call the hooks). Both backends
       should have the same behavior, though it is not entirely clear which,
       if any, is correct. We will likely make rebase stop calling either of
       these hooks in the future.

   Interruptability
       The apply backend has safety problems with an ill-timed interrupt; if
       the user presses Ctrl-C at the wrong time to try to abort the rebase,
       the rebase can enter a state where it cannot be aborted with a
       subsequent git rebase --abort. The merge backend does not appear to
       suffer from the same shortcoming. (See
       https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/ for
       details.)

   Commit Rewording
       When a conflict occurs while rebasing, rebase stops and asks the user
       to resolve. Since the user may need to make notable changes while
       resolving conflicts, after conflicts are resolved and the user has run
       git rebase --continue, the rebase should open an editor and ask the
       user to update the commit message. The merge backend does this, while
       the apply backend blindly applies the original commit message.

   Miscellaneous differences
       There are a few more behavioral differences that most folks would
       probably consider inconsequential but which are mentioned for
       completeness:

       o   Reflog: The two backends will use different wording when describing
           the changes made in the reflog, though both will make use of the
           word "rebase".

       o   Progress, informational, and error messages: The two backends
           provide slightly different progress and informational messages.
           Also, the apply backend writes error messages (such as "Your files
           would be overwritten...") to stdout, while the merge backend writes
           them to stderr.

       o   State directories: The two backends keep their state in different
           directories under .git/

MERGE STRATEGIES
       The merge mechanism (git merge and git pull commands) allows the
       backend merge strategies to be chosen with -s option. Some strategies
       can also take their own options, which can be passed by giving
       -X<option> arguments to git merge and/or git pull.

       resolve
           This can only resolve two heads (i.e. the current branch and
           another branch you pulled from) using a 3-way merge algorithm. It
           tries to carefully detect criss-cross merge ambiguities and is
           considered generally safe and fast.

       recursive
           This can only resolve two heads using a 3-way merge algorithm. When
           there is more than one common ancestor that can be used for 3-way
           merge, it creates a merged tree of the common ancestors and uses
           that as the reference tree for the 3-way merge. This has been
           reported to result in fewer merge conflicts without causing
           mismerges by tests done on actual merge commits taken from Linux
           2.6 kernel development history. Additionally this can detect and
           handle merges involving renames, but currently cannot make use of
           detected copies. This is the default merge strategy when pulling or
           merging one branch.

           The recursive strategy can take the following options:

           ours
               This option forces conflicting hunks to be auto-resolved
               cleanly by favoring our version. Changes from the other tree
               that do not conflict with our side are reflected in the merge
               result. For a binary file, the entire contents are taken from
               our side.

               This should not be confused with the ours merge strategy, which
               does not even look at what the other tree contains at all. It
               discards everything the other tree did, declaring our history
               contains all that happened in it.

           theirs
               This is the opposite of ours; note that, unlike ours, there is
               no theirs merge strategy to confuse this merge option with.

           patience
               With this option, merge-recursive spends a little extra time to
               avoid mismerges that sometimes occur due to unimportant
               matching lines (e.g., braces from distinct functions). Use this
               when the branches to be merged have diverged wildly. See also
               git-diff(1) --patience.

           diff-algorithm=[patience|minimal|histogram|myers]
               Tells merge-recursive to use a different diff algorithm, which
               can help avoid mismerges that occur due to unimportant matching
               lines (such as braces from distinct functions). See also git-
               diff(1) --diff-algorithm.

           ignore-space-change, ignore-all-space, ignore-space-at-eol,
           ignore-cr-at-eol
               Treats lines with the indicated type of whitespace change as
               unchanged for the sake of a three-way merge. Whitespace changes
               mixed with other changes to a line are not ignored. See also
               git-diff(1) -b, -w, --ignore-space-at-eol, and
               --ignore-cr-at-eol.

               o   If their version only introduces whitespace changes to a
                   line, our version is used;

               o   If our version introduces whitespace changes but their
                   version includes a substantial change, their version is
                   used;

               o   Otherwise, the merge proceeds in the usual way.

           renormalize
               This runs a virtual check-out and check-in of all three stages
               of a file when resolving a three-way merge. This option is
               meant to be used when merging branches with different clean
               filters or end-of-line normalization rules. See "Merging
               branches with differing checkin/checkout attributes" in
               gitattributes(5) for details.

           no-renormalize
               Disables the renormalize option. This overrides the
               merge.renormalize configuration variable.

           no-renames
               Turn off rename detection. This overrides the merge.renames
               configuration variable. See also git-diff(1) --no-renames.

           find-renames[=<n>]
               Turn on rename detection, optionally setting the similarity
               threshold. This is the default. This overrides the
               merge.renames configuration variable. See also git-diff(1)
               --find-renames.

           rename-threshold=<n>
               Deprecated synonym for find-renames=<n>.

           subtree[=<path>]
               This option is a more advanced form of subtree strategy, where
               the strategy makes a guess on how two trees must be shifted to
               match with each other when merging. Instead, the specified path
               is prefixed (or stripped from the beginning) to make the shape
               of two trees to match.

       octopus
           This resolves cases with more than two heads, but refuses to do a
           complex merge that needs manual resolution. It is primarily meant
           to be used for bundling topic branch heads together. This is the
           default merge strategy when pulling or merging more than one
           branch.

       ours
           This resolves any number of heads, but the resulting tree of the
           merge is always that of the current branch head, effectively
           ignoring all changes from all other branches. It is meant to be
           used to supersede old development history of side branches. Note
           that this is different from the -Xours option to the recursive
           merge strategy.

       subtree
           This is a modified recursive strategy. When merging trees A and B,
           if B corresponds to a subtree of A, B is first adjusted to match
           the tree structure of A, instead of reading the trees at the same
           level. This adjustment is also done to the common ancestor tree.

       With the strategies that use 3-way merge (including the default,
       recursive), if a change is made on both branches, but later reverted on
       one of the branches, that change will be present in the merged result;
       some people find this behavior confusing. It occurs because only the
       heads and the merge base are considered when performing a merge, not
       the individual commits. The merge algorithm therefore considers the
       reverted change as no change at all, and substitutes the changed
       version instead.

NOTES
       You should understand the implications of using git rebase on a
       repository that you share. See also RECOVERING FROM UPSTREAM REBASE
       below.

       When the git-rebase command is run, it will first execute a
       "pre-rebase" hook if one exists. You can use this hook to do sanity
       checks and reject the rebase if it isn't appropriate. Please see the
       template pre-rebase hook script for an example.

       Upon completion, <branch> will be the current branch.

INTERACTIVE MODE
       Rebasing interactively means that you have a chance to edit the commits
       which are rebased. You can reorder the commits, and you can remove them
       (weeding out bad or otherwise unwanted patches).

       The interactive mode is meant for this type of workflow:

        1. have a wonderful idea

        2. hack on the code

        3. prepare a series for submission

        4. submit

       where point 2. consists of several instances of

       a) regular use

        1. finish something worthy of a commit

        2. commit

       b) independent fixup

        1. realize that something does not work

        2. fix that

        3. commit it

       Sometimes the thing fixed in b.2. cannot be amended to the not-quite
       perfect commit it fixes, because that commit is buried deeply in a
       patch series. That is exactly what interactive rebase is for: use it
       after plenty of "a"s and "b"s, by rearranging and editing commits, and
       squashing multiple commits into one.

       Start it with the last commit you want to retain as-is:

           git rebase -i <after-this-commit>

       An editor will be fired up with all the commits in your current branch
       (ignoring merge commits), which come after the given commit. You can
       reorder the commits in this list to your heart's content, and you can
       remove them. The list looks more or less like this:

           pick deadbee The oneline of this commit
           pick fa1afe1 The oneline of the next commit
           ...


       The oneline descriptions are purely for your pleasure; git rebase will
       not look at them but at the commit names ("deadbee" and "fa1afe1" in
       this example), so do not delete or edit the names.

       By replacing the command "pick" with the command "edit", you can tell
       git rebase to stop after applying that commit, so that you can edit the
       files and/or the commit message, amend the commit, and continue
       rebasing.

       To interrupt the rebase (just like an "edit" command would do, but
       without cherry-picking any commit first), use the "break" command.

       If you just want to edit the commit message for a commit, replace the
       command "pick" with the command "reword".

       To drop a commit, replace the command "pick" with "drop", or just
       delete the matching line.

       If you want to fold two or more commits into one, replace the command
       "pick" for the second and subsequent commits with "squash" or "fixup".
       If the commits had different authors, the folded commit will be
       attributed to the author of the first commit. The suggested commit
       message for the folded commit is the concatenation of the commit
       messages of the first commit and of those with the "squash" command,
       but omits the commit messages of commits with the "fixup" command.

       git rebase will stop when "pick" has been replaced with "edit" or when
       a command fails due to merge errors. When you are done editing and/or
       resolving conflicts you can continue with git rebase --continue.

       For example, if you want to reorder the last 5 commits, such that what
       was HEAD~4 becomes the new HEAD. To achieve that, you would call git
       rebase like this:

           $ git rebase -i HEAD~5


       And move the first patch to the end of the list.

       You might want to recreate merge commits, e.g. if you have a history
       like this:

                      X
                       \
                    A---M---B
                   /
           ---o---O---P---Q


       Suppose you want to rebase the side branch starting at "A" to "Q". Make
       sure that the current HEAD is "B", and call

           $ git rebase -i -r --onto Q O


       Reordering and editing commits usually creates untested intermediate
       steps. You may want to check that your history editing did not break
       anything by running a test, or at least recompiling at intermediate
       points in history by using the "exec" command (shortcut "x"). You may
       do so by creating a todo list like this one:

           pick deadbee Implement feature XXX
           fixup f1a5c00 Fix to feature XXX
           exec make
           pick c0ffeee The oneline of the next commit
           edit deadbab The oneline of the commit after
           exec cd subdir; make test
           ...


       The interactive rebase will stop when a command fails (i.e. exits with
       non-0 status) to give you an opportunity to fix the problem. You can
       continue with git rebase --continue.

       The "exec" command launches the command in a shell (the one specified
       in $SHELL, or the default shell if $SHELL is not set), so you can use
       shell features (like "cd", ">", ";" ...). The command is run from the
       root of the working tree.

           $ git rebase -i --exec "make test"


       This command lets you check that intermediate commits are compilable.
       The todo list becomes like that:

           pick 5928aea one
           exec make test
           pick 04d0fda two
           exec make test
           pick ba46169 three
           exec make test
           pick f4593f9 four
           exec make test


SPLITTING COMMITS
       In interactive mode, you can mark commits with the action "edit".
       However, this does not necessarily mean that git rebase expects the
       result of this edit to be exactly one commit. Indeed, you can undo the
       commit, or you can add other commits. This can be used to split a
       commit into two:

       o   Start an interactive rebase with git rebase -i <commit>^, where
           <commit> is the commit you want to split. In fact, any commit range
           will do, as long as it contains that commit.

       o   Mark the commit you want to split with the action "edit".

       o   When it comes to editing that commit, execute git reset HEAD^. The
           effect is that the HEAD is rewound by one, and the index follows
           suit. However, the working tree stays the same.

       o   Now add the changes to the index that you want to have in the first
           commit. You can use git add (possibly interactively) or git gui (or
           both) to do that.

       o   Commit the now-current index with whatever commit message is
           appropriate now.

       o   Repeat the last two steps until your working tree is clean.

       o   Continue the rebase with git rebase --continue.

       If you are not absolutely sure that the intermediate revisions are
       consistent (they compile, pass the testsuite, etc.) you should use git
       stash to stash away the not-yet-committed changes after each commit,
       test, and amend the commit if fixes are necessary.

RECOVERING FROM UPSTREAM REBASE
       Rebasing (or any other form of rewriting) a branch that others have
       based work on is a bad idea: anyone downstream of it is forced to
       manually fix their history. This section explains how to do the fix
       from the downstream's point of view. The real fix, however, would be to
       avoid rebasing the upstream in the first place.

       To illustrate, suppose you are in a situation where someone develops a
       subsystem branch, and you are working on a topic that is dependent on
       this subsystem. You might end up with a history like the following:

               o---o---o---o---o---o---o---o  main
                    \
                     o---o---o---o---o  subsystem
                                      \
                                       *---*---*  topic


       If subsystem is rebased against main, the following happens:

               o---o---o---o---o---o---o---o  main
                    \                       \
                     o---o---o---o---o       o'--o'--o'--o'--o'  subsystem
                                      \
                                       *---*---*  topic


       If you now continue development as usual, and eventually merge topic to
       subsystem, the commits from subsystem will remain duplicated forever:

               o---o---o---o---o---o---o---o  main
                    \                       \
                     o---o---o---o---o       o'--o'--o'--o'--o'--M  subsystem
                                      \                         /
                                       *---*---*-..........-*--*  topic


       Such duplicates are generally frowned upon because they clutter up
       history, making it harder to follow. To clean things up, you need to
       transplant the commits on topic to the new subsystem tip, i.e., rebase
       topic. This becomes a ripple effect: anyone downstream from topic is
       forced to rebase too, and so on!

       There are two kinds of fixes, discussed in the following subsections:

       Easy case: The changes are literally the same.
           This happens if the subsystem rebase was a simple rebase and had no
           conflicts.

       Hard case: The changes are not the same.
           This happens if the subsystem rebase had conflicts, or used
           --interactive to omit, edit, squash, or fixup commits; or if the
           upstream used one of commit --amend, reset, or a full history
           rewriting command like filter-repo[2].

   The easy case
       Only works if the changes (patch IDs based on the diff contents) on
       subsystem are literally the same before and after the rebase subsystem
       did.

       In that case, the fix is easy because git rebase knows to skip changes
       that are already present in the new upstream (unless
       --reapply-cherry-picks is given). So if you say (assuming you're on
       topic)

               $ git rebase subsystem


       you will end up with the fixed history

               o---o---o---o---o---o---o---o  main
                                            \
                                             o'--o'--o'--o'--o'  subsystem
                                                              \
                                                               *---*---*  topic


   The hard case
       Things get more complicated if the subsystem changes do not exactly
       correspond to the ones before the rebase.

           Note
           While an "easy case recovery" sometimes appears to be successful
           even in the hard case, it may have unintended consequences. For
           example, a commit that was removed via git rebase --interactive
           will be resurrected!

       The idea is to manually tell git rebase "where the old subsystem ended
       and your topic began", that is, what the old merge base between them
       was. You will have to find a way to name the last commit of the old
       subsystem, for example:

       o   With the subsystem reflog: after git fetch, the old tip of
           subsystem is at subsystem@{1}. Subsequent fetches will increase the
           number. (See git-reflog(1).)

       o   Relative to the tip of topic: knowing that your topic has three
           commits, the old tip of subsystem must be topic~3.

       You can then transplant the old subsystem..topic to the new tip by
       saying (for the reflog case, and assuming you are on topic already):

               $ git rebase --onto subsystem subsystem@{1}


       The ripple effect of a "hard case" recovery is especially bad: everyone
       downstream from topic will now have to perform a "hard case" recovery
       too!

REBASING MERGES
       The interactive rebase command was originally designed to handle
       individual patch series. As such, it makes sense to exclude merge
       commits from the todo list, as the developer may have merged the
       then-current main while working on the branch, only to rebase all the
       commits onto main eventually (skipping the merge commits).

       However, there are legitimate reasons why a developer may want to
       recreate merge commits: to keep the branch structure (or "commit
       topology") when working on multiple, inter-related branches.

       In the following example, the developer works on a topic branch that
       refactors the way buttons are defined, and on another topic branch that
       uses that refactoring to implement a "Report a bug" button. The output
       of git log --graph --format=%s -5 may look like this:

           *   Merge branch 'report-a-bug'
           |\
           | * Add the feedback button
           * | Merge branch 'refactor-button'
           |\ \
           | |/
           | * Use the Button class for all buttons
           | * Extract a generic Button class from the DownloadButton one


       The developer might want to rebase those commits to a newer main
       while keeping the branch topology, for example when the first topic
       branch is expected to be integrated into main much earlier than the
       second one, say, to resolve merge conflicts with changes to the
       DownloadButton class that made it into main.

       This rebase can be performed using the --rebase-merges option. It will
       generate a todo list looking like this:

           label onto

           # Branch: refactor-button
           reset onto
           pick 123456 Extract a generic Button class from the DownloadButton one
           pick 654321 Use the Button class for all buttons
           label refactor-button

           # Branch: report-a-bug
           reset refactor-button # Use the Button class for all buttons
           pick abcdef Add the feedback button
           label report-a-bug

           reset onto
           merge -C a1b2c3 refactor-button # Merge 'refactor-button'
           merge -C 6f5e4d report-a-bug # Merge 'report-a-bug'


       In contrast to a regular interactive rebase, there are label, reset and
       merge commands in addition to pick ones.

       The label command associates a label with the current HEAD when that
       command is executed. These labels are created as worktree-local refs
       (refs/rewritten/<label>) that will be deleted when the rebase finishes.
       That way, rebase operations in multiple worktrees linked to the same
       repository do not interfere with one another. If the label command
       fails, it is rescheduled immediately, with a helpful message how to
       proceed.

       The reset command resets the HEAD, index and worktree to the specified
       revision. It is similar to an exec git reset --hard <label>, but
       refuses to overwrite untracked files. If the reset command fails, it is
       rescheduled immediately, with a helpful message how to edit the todo
       list (this typically happens when a reset command was inserted into the
       todo list manually and contains a typo).

       The merge command will merge the specified revision(s) into whatever is
       HEAD at that time. With -C <original-commit>, the commit message of the
       specified merge commit will be used. When the -C is changed to a
       lower-case -c, the message will be opened in an editor after a
       successful merge so that the user can edit the message.

       If a merge command fails for any reason other than merge conflicts
       (i.e. when the merge operation did not even start), it is rescheduled
       immediately.

       At this time, the merge command will always use the recursive merge
       strategy for regular merges, and octopus for octopus merges, with no
       way to choose a different one. To work around this, an exec command can
       be used to call git merge explicitly, using the fact that the labels
       are worktree-local refs (the ref refs/rewritten/onto would correspond
       to the label onto, for example).

       Note: the first command (label onto) labels the revision onto which the
       commits are rebased; The name onto is just a convention, as a nod to
       the --onto option.

       It is also possible to introduce completely new merge commits from
       scratch by adding a command of the form merge <merge-head>. This form
       will generate a tentative commit message and always open an editor to
       let the user edit it. This can be useful e.g. when a topic branch turns
       out to address more than a single concern and wants to be split into
       two or even more topic branches. Consider this todo list:

           pick 192837 Switch from GNU Makefiles to CMake
           pick 5a6c7e Document the switch to CMake
           pick 918273 Fix detection of OpenSSL in CMake
           pick afbecd http: add support for TLS v1.3
           pick fdbaec Fix detection of cURL in CMake on Windows


       The one commit in this list that is not related to CMake may very well
       have been motivated by working on fixing all those bugs introduced by
       switching to CMake, but it addresses a different concern. To split this
       branch into two topic branches, the todo list could be edited like
       this:

           label onto

           pick afbecd http: add support for TLS v1.3
           label tlsv1.3

           reset onto
           pick 192837 Switch from GNU Makefiles to CMake
           pick 918273 Fix detection of OpenSSL in CMake
           pick fdbaec Fix detection of cURL in CMake on Windows
           pick 5a6c7e Document the switch to CMake
           label cmake

           reset onto
           merge tlsv1.3
           merge cmake


BUGS
       The todo list presented by the deprecated --preserve-merges
       --interactive does not represent the topology of the revision graph
       (use --rebase-merges instead). Editing commits and rewording their
       commit messages should work fine, but attempts to reorder commits tend
       to produce counterintuitive results. Use --rebase-merges in such
       scenarios instead.

       For example, an attempt to rearrange

           1 --- 2 --- 3 --- 4 --- 5


       to

           1 --- 2 --- 4 --- 3 --- 5


       by moving the "pick 4" line will result in the following history:

                   3
                  /
           1 --- 2 --- 4 --- 5


GIT
       Part of the git(1) suite

NOTES
        1. revert-a-faulty-merge How-To
           git-htmldocs/howto/revert-a-faulty-merge.html

        2. filter-repo
           https://github.com/newren/git-filter-repo



Git 2.30.1.378.g1d4f23            02/08/2021                     GIT-REBASE(1)
```



## `reset`




```
GIT-RESET(1)                      Git Manual                      GIT-RESET(1)



NAME
       git-reset - 現在のHEADを指定された状態にリセットする

SYNOPSIS
       git reset [-q] [<tree-ish>] [--] <pathspec>...
       git reset [-q] [--pathspec-from-file=<file> [--pathspec-file-nul]] [<tree-ish>]
       git reset (--patch | -p) [<tree-ish>] [--] [<pathspec>...]
       git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [<commit>]


DESCRIPTION
       最初の3つの形式で、エントリを <tree-ish> からインデックスにコピーします。
       最後の形式で、現在のブランチヘッド（HEAD）を <commit> に設定し、オプションでインデックスと
       作業ツリーを一致するように変更します。
       <tree-ish>/<commit> は、すべての形式でデフォルトで HEADになります。

       git reset [-q] [<tree-ish>] [--] <pathspec>..., git reset [-q]
       [--pathspec-from-file=<file> [--pathspec-file-nul]] [<tree-ish>]
           These forms reset the index entries for all paths that match the
           <pathspec> to their state at <tree-ish>. (It does not affect the
           working tree or the current branch.)

           This means that git reset <pathspec> is the opposite of git add
           <pathspec>. This command is equivalent to git restore
           [--source=<tree-ish>] --staged <pathspec>....

           After running git reset <pathspec> to update the index entry, you
           can use git-restore(1) to check the contents out of the index to
           the working tree. Alternatively, using git-restore(1) and
           specifying a commit with --source, you can copy the contents of a
           path out of a commit to the index and to the working tree in one
           go.

       git reset (--patch | -p) [<tree-ish>] [--] [<pathspec>...]
           Interactively select hunks in the difference between the index and
           <tree-ish> (defaults to HEAD). The chosen hunks are applied in
           reverse to the index.

           This means that git reset -p is the opposite of git add -p, i.e.
           you can use it to selectively reset hunks. See the "Interactive
           Mode" section of git-add(1) to learn how to operate the --patch
           mode.

       git reset [<mode>] [<commit>]
           This form resets the current branch head to <commit> and possibly
           updates the index (resetting it to the tree of <commit>) and the
           working tree depending on <mode>. If <mode> is omitted, defaults to
           --mixed. The <mode> must be one of the following:

           --soft
               Does not touch the index file or the working tree at all (but
               resets the head to <commit>, just like all modes do). This
               leaves all your changed files "Changes to be committed", as git
               status would put it.

           --mixed
               Resets the index but not the working tree (i.e., the changed
               files are preserved but not marked for commit) and reports what
               has not been updated. This is the default action.

               If -N is specified, removed paths are marked as intent-to-add
               (see git-add(1)).

           --hard
               Resets the index and working tree. Any changes to tracked files
               in the working tree since <commit> are discarded.

           --merge
               Resets the index and updates the files in the working tree that
               are different between <commit> and HEAD, but keeps those which
               are different between the index and working tree (i.e. which
               have changes which have not been added). If a file that is
               different between <commit> and the index has unstaged changes,
               reset is aborted.

               In other words, --merge does something like a git read-tree -u
               -m <commit>, but carries forward unmerged index entries.

           --keep
               Resets index entries and updates files in the working tree that
               are different between <commit> and HEAD. If a file that is
               different between <commit> and HEAD has local changes, reset is
               aborted.

           --[no-]recurse-submodules
               When the working tree is updated, using --recurse-submodules
               will also recursively reset the working tree of all active
               submodules according to the commit recorded in the
               superproject, also setting the submodules' HEAD to be detached
               at that commit.

       See "Reset, restore and revert" in git(1) for the differences between
       the three commands.

OPTIONS
       -q, --quiet, --no-quiet
           Be quiet, only report errors. The default behavior is set by the
           reset.quiet config option.  --quiet and --no-quiet will override
           the default behavior.

       --pathspec-from-file=<file>
           Pathspec is passed in <file> instead of commandline args. If <file>
           is exactly - then standard input is used. Pathspec elements are
           separated by LF or CR/LF. Pathspec elements can be quoted as
           explained for the configuration variable core.quotePath (see git-
           config(1)). See also --pathspec-file-nul and global
           --literal-pathspecs.

       --pathspec-file-nul
           Only meaningful with --pathspec-from-file. Pathspec elements are
           separated with NUL character and all other characters are taken
           literally (including newlines and quotes).

       --
           Do not interpret any more arguments as options.

       <pathspec>...
           Limits the paths affected by the operation.

           For more details, see the pathspec entry in gitglossary(7).

EXAMPLES
       Undo add

               $ edit                                     (1)
               $ git add frotz.c filfre.c
               $ mailx                                    (2)
               $ git reset                                (3)
               $ git pull git://info.example.com/ nitfol  (4)

           1. You are happily working on something, and find the changes in
           these files are in good order. You do not want to see them when you
           run git diff, because you plan to work on other files and changes
           with these files are distracting.
           2. Somebody asks you to pull, and the changes sound worthy of
           merging.
           3. However, you already dirtied the index (i.e. your index does not
           match the HEAD commit). But you know the pull you are going to make
           does not affect frotz.c or filfre.c, so you revert the index
           changes for these two files. Your changes in working tree remain
           there.
           4. Then you can pull and merge, leaving frotz.c and filfre.c
           changes still in the working tree.

       Undo a commit and redo

               $ git commit ...
               $ git reset --soft HEAD^      (1)
               $ edit                        (2)
               $ git commit -a -c ORIG_HEAD  (3)

           1. This is most often done when you remembered what you just
           committed is incomplete, or you misspelled your commit message, or
           both. Leaves working tree as it was before "reset".
           2. Make corrections to working tree files.
           3. "reset" copies the old head to .git/ORIG_HEAD; redo the commit
           by starting with its log message. If you do not need to edit the
           message further, you can give -C option instead.

           See also the --amend option to git-commit(1).

       Undo a commit, making it a topic branch

               $ git branch topic/wip          (1)
               $ git reset --hard HEAD~3       (2)
               $ git switch topic/wip          (3)

           1. You have made some commits, but realize they were premature to
           be in the main branch. You want to continue polishing them in a
           topic branch, so create topic/wip branch off of the current HEAD.
           2. Rewind the main branch to get rid of those three commits.
           3. Switch to topic/wip branch and keep working.

       Undo commits permanently

               $ git commit ...
               $ git reset --hard HEAD~3   (1)

           1. The last three commits (HEAD, HEAD^, and HEAD~2) were bad and
           you do not want to ever see them again. Do not do this if you have
           already given these commits to somebody else. (See the "RECOVERING
           FROM UPSTREAM REBASE" section in git-rebase(1) for the implications
           of doing so.)

       Undo a merge or pull

               $ git pull                         (1)
               Auto-merging nitfol
               CONFLICT (content): Merge conflict in nitfol
               Automatic merge failed; fix conflicts and then commit the result.
               $ git reset --hard                 (2)
               $ git pull . topic/branch          (3)
               Updating from 41223... to 13134...
               Fast-forward
               $ git reset --hard ORIG_HEAD       (4)

           1. Try to update from the upstream resulted in a lot of conflicts;
           you were not ready to spend a lot of time merging right now, so you
           decide to do that later.
           2. "pull" has not made merge commit, so git reset --hard which is a
           synonym for git reset --hard HEAD clears the mess from the index
           file and the working tree.
           3. Merge a topic branch into the current branch, which resulted in
           a fast-forward.
           4. But you decided that the topic branch is not ready for public
           consumption yet. "pull" or "merge" always leaves the original tip
           of the current branch in ORIG_HEAD, so resetting hard to it brings
           your index file and the working tree back to that state, and resets
           the tip of the branch to that commit.

       Undo a merge or pull inside a dirty working tree

               $ git pull                         (1)
               Auto-merging nitfol
               Merge made by recursive.
                nitfol                |   20 +++++----
                ...
               $ git reset --merge ORIG_HEAD      (2)

           1. Even if you may have local modifications in your working tree,
           you can safely say git pull when you know that the change in the
           other branch does not overlap with them.
           2. After inspecting the result of the merge, you may find that the
           change in the other branch is unsatisfactory. Running git reset
           --hard ORIG_HEAD will let you go back to where you were, but it
           will discard your local changes, which you do not want.  git reset
           --merge keeps your local changes.

       Interrupted workflow
           Suppose you are interrupted by an urgent fix request while you are
           in the middle of a large change. The files in your working tree are
           not in any shape to be committed yet, but you need to get to the
           other branch for a quick bugfix.

               $ git switch feature  ;# you were working in "feature" branch and
               $ work work work      ;# got interrupted
               $ git commit -a -m "snapshot WIP"                 (1)
               $ git switch main
               $ fix fix fix
               $ git commit ;# commit with real log
               $ git switch feature
               $ git reset --soft HEAD^ ;# go back to WIP state  (2)
               $ git reset                                       (3)

           1. This commit will get blown away so a throw-away log message is
           OK.
           2. This removes the WIP commit from the commit history, and sets
           your working tree to the state just before you made that snapshot.
           3. At this point the index file still has all the WIP changes you
           committed as snapshot WIP. This updates the index to show your WIP
           files as uncommitted.

           See also git-stash(1).

       Reset a single file in the index
           Suppose you have added a file to your index, but later decide you
           do not want to add it to your commit. You can remove the file from
           the index while keeping your changes with git reset.

               $ git reset -- frotz.c                      (1)
               $ git commit -m "Commit files in index"     (2)
               $ git add frotz.c                           (3)

           1. This removes the file from the index while keeping it in the
           working directory.
           2. This commits all other changes in the index.
           3. Adds the file to the index again.

       Keep changes in working tree while discarding some previous commits
           Suppose you are working on something and you commit it, and then
           you continue working a bit more, but now you think that what you
           have in your working tree should be in another branch that has
           nothing to do with what you committed previously. You can start a
           new branch and reset it while keeping the changes in your working
           tree.

               $ git tag start
               $ git switch -c branch1
               $ edit
               $ git commit ...                            (1)
               $ edit
               $ git switch -c branch2                     (2)
               $ git reset --keep start                    (3)

           1. This commits your first edits in branch1.
           2. In the ideal world, you could have realized that the earlier
           commit did not belong to the new topic when you created and
           switched to branch2 (i.e.  git switch -c branch2 start), but nobody
           is perfect.
           3. But you can use reset --keep to remove the unwanted commit after
           you switched to branch2.

       Split a commit apart into a sequence of commits
           Suppose that you have created lots of logically separate changes
           and committed them together. Then, later you decide that it might
           be better to have each logical chunk associated with its own
           commit. You can use git reset to rewind history without changing
           the contents of your local files, and then successively use git add
           -p to interactively select which hunks to include into each commit,
           using git commit -c to pre-populate the commit message.

               $ git reset -N HEAD^                        (1)
               $ git add -p                                (2)
               $ git diff --cached                         (3)
               $ git commit -c HEAD@{1}                    (4)
               ...                                         (5)
               $ git add ...                               (6)
               $ git diff --cached                         (7)
               $ git commit ...                            (8)

           1. First, reset the history back one commit so that we remove the
           original commit, but leave the working tree with all the changes.
           The -N ensures that any new files added with HEAD are still marked
           so that git add -p will find them.
           2. Next, we interactively select diff hunks to add using the git
           add -p facility. This will ask you about each diff hunk in sequence
           and you can use simple commands such as "yes, include this", "No
           don't include this" or even the very powerful "edit" facility.
           3. Once satisfied with the hunks you want to include, you should
           verify what has been prepared for the first commit by using git
           diff --cached. This shows all the changes that have been moved into
           the index and are about to be committed.
           4. Next, commit the changes stored in the index. The -c option
           specifies to pre-populate the commit message from the original
           message that you started with in the first commit. This is helpful
           to avoid retyping it. The HEAD@{1} is a special notation for the
           commit that HEAD used to be at prior to the original reset commit
           (1 change ago). See git-reflog(1) for more details. You may also
           use any other valid commit reference.
           5. You can repeat steps 2-4 multiple times to break the original
           code into any number of commits.
           6. Now you've split out many of the changes into their own commits,
           and might no longer use the patch mode of git add, in order to
           select all remaining uncommitted changes.
           7. Once again, check to verify that you've included what you want
           to. You may also wish to verify that git diff doesn't show any
           remaining changes to be committed later.
           8. And finally create the final commit.

DISCUSSION
       The tables below show what happens when running:

           git reset --option target


       to reset the HEAD to another commit (target) with the different reset
       options depending on the state of the files.

       In these tables, A, B, C and D are some different states of a file. For
       example, the first line of the first table means that if a file is in
       state A in the working tree, in state B in the index, in state C in
       HEAD and in state D in the target, then git reset --soft target will
       leave the file in the working tree in state A and in the index in state
       B. It resets (i.e. moves) the HEAD (i.e. the tip of the current branch,
       if you are on one) to target (which has the file in state D).

           working index HEAD target         working index HEAD
           ----------------------------------------------------
            A       B     C    D     --soft   A       B     D
                                     --mixed  A       D     D
                                     --hard   D       D     D
                                     --merge (disallowed)
                                     --keep  (disallowed)

           working index HEAD target         working index HEAD
           ----------------------------------------------------
            A       B     C    C     --soft   A       B     C
                                     --mixed  A       C     C
                                     --hard   C       C     C
                                     --merge (disallowed)
                                     --keep   A       C     C

           working index HEAD target         working index HEAD
           ----------------------------------------------------
            B       B     C    D     --soft   B       B     D
                                     --mixed  B       D     D
                                     --hard   D       D     D
                                     --merge  D       D     D
                                     --keep  (disallowed)

           working index HEAD target         working index HEAD
           ----------------------------------------------------
            B       B     C    C     --soft   B       B     C
                                     --mixed  B       C     C
                                     --hard   C       C     C
                                     --merge  C       C     C
                                     --keep   B       C     C

           working index HEAD target         working index HEAD
           ----------------------------------------------------
            B       C     C    D     --soft   B       C     D
                                     --mixed  B       D     D
                                     --hard   D       D     D
                                     --merge (disallowed)
                                     --keep  (disallowed)

           working index HEAD target         working index HEAD
           ----------------------------------------------------
            B       C     C    C     --soft   B       C     C
                                     --mixed  B       C     C
                                     --hard   C       C     C
                                     --merge  B       C     C
                                     --keep   B       C     C

       reset --merge is meant to be used when resetting out of a conflicted
       merge. Any mergy operation guarantees that the working tree file that
       is involved in the merge does not have a local change with respect to
       the index before it starts, and that it writes the result out to the
       working tree. So if we see some difference between the index and the
       target and also between the index and the working tree, then it means
       that we are not resetting out from a state that a mergy operation left
       after failing with a conflict. That is why we disallow --merge option
       in this case.

       reset --keep is meant to be used when removing some of the last commits
       in the current branch while keeping changes in the working tree. If
       there could be conflicts between the changes in the commit we want to
       remove and the changes in the working tree we want to keep, the reset
       is disallowed. That's why it is disallowed if there are both changes
       between the working tree and HEAD, and between HEAD and the target. To
       be safe, it is also disallowed when there are unmerged entries.

       The following tables show what happens when there are unmerged entries:

           working index HEAD target         working index HEAD
           ----------------------------------------------------
            X       U     A    B     --soft  (disallowed)
                                     --mixed  X       B     B
                                     --hard   B       B     B
                                     --merge  B       B     B
                                     --keep  (disallowed)

           working index HEAD target         working index HEAD
           ----------------------------------------------------
            X       U     A    A     --soft  (disallowed)
                                     --mixed  X       A     A
                                     --hard   A       A     A
                                     --merge  A       A     A
                                     --keep  (disallowed)

       X means any state and U means an unmerged index.

GIT
       Part of the git(1) suite



Git 2.30.1.378.g1d4f23            02/08/2021                      GIT-RESET(1)
```



## `switch`




```
GIT-SWITCH(1)                     Git Manual                     GIT-SWITCH(1)



NAME
       git-switch - ブランチを切り替える

SYNOPSIS
       git switch [<options>] [--no-guess] <branch>
       git switch [<options>] --detach [<start-point>]
       git switch [<options>] (-c|-C) <new-branch> [<start-point>]
       git switch [<options>] --orphan <new-branch>


DESCRIPTION
       
       指定されたブランチに切り替えます。
       作業ツリーとインデックスは、ブランチに一致するように更新されます。
       すべての新しいコミットは、このブランチの先端に追加されます。
       
       オプションで、同じ名前のリモートブランチから自動的に -c、-C を使用して
       新しいブランチを作成するか（--guess を参照）、切り替えと共に、
       --detach を使用して任意のブランチから作業ツリーをデタッチできます。
       
       ブランチを切り替えるには、クリーンなインデックスと作業ツリーは必要ありません
       （つまり、HEAD との違いはありません）。
       ただし、--discard-changes または --merge で特に指示されない限り、
       操作によってローカル変更が失われると、操作は中止されます。

       このコマンドは実験的なものです。動作が変わる可能性があります。

OPTIONS
       <branch>
           Branch to switch to.

       <new-branch>
           Name for the new branch.

       <start-point>
           The starting point for the new branch. Specifying a <start-point>
           allows you to create a branch based on some other point in history
           than where HEAD currently points. (Or, in the case of --detach,
           allows you to inspect and detach from some other point.)

           You can use the @{-N} syntax to refer to the N-th last
           branch/commit switched to using "git switch" or "git checkout"
           operation. You may also specify - which is synonymous to @{-1}.
           This is often used to switch quickly between two branches, or to
           undo a branch switch by mistake.

           As a special case, you may use A...B as a shortcut for the merge
           base of A and B if there is exactly one merge base. You can leave
           out at most one of A and B, in which case it defaults to HEAD.

       -c <new-branch>, --create <new-branch>
           Create a new branch named <new-branch> starting at <start-point>
           before switching to the branch. This is a convenient shortcut for:

               $ git branch <new-branch>
               $ git switch <new-branch>


       -C <new-branch>, --force-create <new-branch>
           Similar to --create except that if <new-branch> already exists, it
           will be reset to <start-point>. This is a convenient shortcut for:

               $ git branch -f <new-branch>
               $ git switch <new-branch>


       -d, --detach
           Switch to a commit for inspection and discardable experiments. See
           the "DETACHED HEAD" section in git-checkout(1) for details.

       --guess, --no-guess
           If <branch> is not found but there does exist a tracking branch in
           exactly one remote (call it <remote>) with a matching name, treat
           as equivalent to

               $ git switch -c <branch> --track <remote>/<branch>

           If the branch exists in multiple remotes and one of them is named
           by the checkout.defaultRemote configuration variable, we'll use
           that one for the purposes of disambiguation, even if the <branch>
           isn't unique across all remotes. Set it to e.g.
           checkout.defaultRemote=origin to always checkout remote branches
           from there if <branch> is ambiguous but exists on the origin
           remote. See also checkout.defaultRemote in git-config(1).

           --guess is the default behavior. Use --no-guess to disable it.

           The default behavior can be set via the checkout.guess
           configuration variable.

       -f, --force
           An alias for --discard-changes.

       --discard-changes
           Proceed even if the index or the working tree differs from HEAD.
           Both the index and working tree are restored to match the switching
           target. If --recurse-submodules is specified, submodule content is
           also restored to match the switching target. This is used to throw
           away local changes.

       -m, --merge
           If you have local modifications to one or more files that are
           different between the current branch and the branch to which you
           are switching, the command refuses to switch branches in order to
           preserve your modifications in context. However, with this option,
           a three-way merge between the current branch, your working tree
           contents, and the new branch is done, and you will be on the new
           branch.

           When a merge conflict happens, the index entries for conflicting
           paths are left unmerged, and you need to resolve the conflicts and
           mark the resolved paths with git add (or git rm if the merge should
           result in deletion of the path).

       --conflict=<style>
           The same as --merge option above, but changes the way the
           conflicting hunks are presented, overriding the merge.conflictStyle
           configuration variable. Possible values are "merge" (default) and
           "diff3" (in addition to what is shown by "merge" style, shows the
           original contents).

       -q, --quiet
           Quiet, suppress feedback messages.

       --progress, --no-progress
           Progress status is reported on the standard error stream by default
           when it is attached to a terminal, unless --quiet is specified.
           This flag enables progress reporting even if not attached to a
           terminal, regardless of --quiet.

       -t, --track
           When creating a new branch, set up "upstream" configuration.  -c is
           implied. See --track in git-branch(1) for details.

           If no -c option is given, the name of the new branch will be
           derived from the remote-tracking branch, by looking at the local
           part of the refspec configured for the corresponding remote, and
           then stripping the initial part up to the "*". This would tell us
           to use hack as the local branch when branching off of origin/hack
           (or remotes/origin/hack, or even refs/remotes/origin/hack). If the
           given name has no slash, or the above guessing results in an empty
           name, the guessing is aborted. You can explicitly give a name with
           -c in such a case.

       --no-track
           Do not set up "upstream" configuration, even if the
           branch.autoSetupMerge configuration variable is true.

       --orphan <new-branch>
           Create a new orphan branch, named <new-branch>. All tracked files
           are removed.

       --ignore-other-worktrees
           git switch refuses when the wanted ref is already checked out by
           another worktree. This option makes it check the ref out anyway. In
           other words, the ref can be held by more than one worktree.

       --recurse-submodules, --no-recurse-submodules
           Using --recurse-submodules will update the content of all active
           submodules according to the commit recorded in the superproject. If
           nothing (or --no-recurse-submodules) is used, submodules working
           trees will not be updated. Just like git-submodule(1), this will
           detach HEAD of the submodules.

EXAMPLES
       The following command switches to the "main" branch:

           $ git switch main


       After working in the wrong branch, switching to the correct branch
       would be done using:

           $ git switch mytopic


       However, your "wrong" branch and correct "mytopic" branch may differ in
       files that you have modified locally, in which case the above switch
       would fail like this:

           $ git switch mytopic
           error: You have local changes to 'frotz'; not switching branches.


       You can give the -m flag to the command, which would try a three-way
       merge:

           $ git switch -m mytopic
           Auto-merging frotz


       After this three-way merge, the local modifications are not registered
       in your index file, so git diff would show you what changes you made
       since the tip of the new branch.

       To switch back to the previous branch before we switched to mytopic
       (i.e. "main" branch):

           $ git switch -


       You can grow a new branch from any commit. For example, switch to
       "HEAD~3" and create branch "fixup":

           $ git switch -c fixup HEAD~3
           Switched to a new branch 'fixup'


       If you want to start a new branch from a remote branch of the same
       name:

           $ git switch new-topic
           Branch 'new-topic' set up to track remote branch 'new-topic' from 'origin'
           Switched to a new branch 'new-topic'


       To check out commit HEAD~3 for temporary inspection or experiment
       without creating a new branch:

           $ git switch --detach HEAD~3
           HEAD is now at 9fc9555312 Merge branch 'cc/shared-index-permbits'


       If it turns out whatever you have done is worth keeping, you can always
       create a new name for it (without switching away):

           $ git switch -c good-surprises


SEE ALSO
       git-checkout(1), git-branch(1)

GIT
       Part of the git(1) suite



Git 2.30.1.378.g1d4f23            02/08/2021                     GIT-SWITCH(1)
```



## `tag`




```
GIT-TAG(1)                        Git Manual                        GIT-TAG(1)



NAME
       git-tag - GPG で署名されたタグオブジェクトを作成、一覧表示、削除、または検証する

SYNOPSIS
       git tag [-a | -s | -u <keyid>] [-f] [-m <msg> | -F <file>] [-e]
               <tagname> [<commit> | <object>]
       git tag -d <tagname>...
       git tag [-n[<num>]] -l [--contains <commit>] [--no-contains <commit>]
               [--points-at <object>] [--column[=<options>] | --no-column]
               [--create-reflog] [--sort=<key>] [--format=<format>]
               [--merged <commit>] [--no-merged <commit>] [<pattern>...]
       git tag -v [--format=<format>] <tagname>...


DESCRIPTION
       タグの削除、一覧表示、または検証に -d/-l/-v が指定されていない限り、
       refs/tags/ にタグ参照を追加します。

       -f を指定しない限り、名前付きタグはまだ存在していてはなりません。
       
       -a、-s、または -u <keyid> のいずれかが渡されると、コマンドはタグオブジェクトを作成し、
       タグメッセージを要求します。
       -m <msg> または -F <file> が指定されていない限り、ユーザーがタグメッセージを
       入力するためのエディターが起動します。
       
       -m <msg> または -F <file> が指定され、-a、-s、および -u <keyid> が無い場合、
       -a が暗黙指定されます。
       
       それ以外の場合は、指定されたオブジェクトを直接指すタグ参照
       （つまり、軽量タグ）が作成されます。
       
       -s または -u <keyid> を使用すると、GnuPG 署名付きタグオブジェクトが作成されます。
       -u <keyid> が使用されていない場合、現在のユーザーのコミッター ID を使用して、
       署名用の GnuPG キーが検索されます。
       構成変数 gpg.program は、カスタム GnuPG バイナリを指定するために使用されます。

       タグオブジェクト（-a、-s、または-uで作成）は「注釈付き」タグと呼ばれます。
       これらには、作成日、タガー名と電子メール、タグ付けメッセージ、およびオプションの
       GnuPG 署名が含まれています。
       一方、「軽量」タグは単にオブジェクト（通常はコミットオブジェクト）の名前です。
       
       注釈付きタグはリリース用であり、軽量タグはプライベートまたは一時的なオブジェクトラベル用です。
       このため、オブジェクトに名前を付けるための一部の git コマンド（git describeなど）は、
       デフォルトで軽量タグを無視します。

OPTIONS
       -a, --annotate
           Make an unsigned, annotated tag object

       -s, --sign
           Make a GPG-signed tag, using the default e-mail address's key. The
           default behavior of tag GPG-signing is controlled by tag.gpgSign
           configuration variable if it exists, or disabled otherwise. See
           git-config(1).

       --no-sign
           Override tag.gpgSign configuration variable that is set to force
           each and every tag to be signed.

       -u <keyid>, --local-user=<keyid>
           Make a GPG-signed tag, using the given key.

       -f, --force
           Replace an existing tag with the given name (instead of failing)

       -d, --delete
           Delete existing tags with the given names.

       -v, --verify
           Verify the GPG signature of the given tag names.

       -n<num>
           <num> specifies how many lines from the annotation, if any, are
           printed when using -l. Implies --list.

           The default is not to print any annotation lines. If no number is
           given to -n, only the first line is printed. If the tag is not
           annotated, the commit message is displayed instead.

       -l, --list
           List tags. With optional <pattern>..., e.g.  git tag --list 'v-*',
           list only the tags that match the pattern(s).

           Running "git tag" without arguments also lists all tags. The
           pattern is a shell wildcard (i.e., matched using fnmatch(3)).
           Multiple patterns may be given; if any of them matches, the tag is
           shown.

           This option is implicitly supplied if any other list-like option
           such as --contains is provided. See the documentation for each of
           those options for details.

       --sort=<key>
           Sort based on the key given. Prefix - to sort in descending order
           of the value. You may use the --sort=<key> option multiple times,
           in which case the last key becomes the primary key. Also supports
           "version:refname" or "v:refname" (tag names are treated as
           versions). The "version:refname" sort order can also be affected by
           the "versionsort.suffix" configuration variable. The keys supported
           are the same as those in git for-each-ref. Sort order defaults to
           the value configured for the tag.sort variable if it exists, or
           lexicographic order otherwise. See git-config(1).

       --color[=<when>]
           Respect any colors specified in the --format option. The <when>
           field must be one of always, never, or auto (if <when> is absent,
           behave as if always was given).

       -i, --ignore-case
           Sorting and filtering tags are case insensitive.

       --column[=<options>], --no-column
           Display tag listing in columns. See configuration variable
           column.tag for option syntax.--column and --no-column without
           options are equivalent to always and never respectively.

           This option is only applicable when listing tags without annotation
           lines.

       --contains [<commit>]
           Only list tags which contain the specified commit (HEAD if not
           specified). Implies --list.

       --no-contains [<commit>]
           Only list tags which don't contain the specified commit (HEAD if
           not specified). Implies --list.

       --merged [<commit>]
           Only list tags whose commits are reachable from the specified
           commit (HEAD if not specified).

       --no-merged [<commit>]
           Only list tags whose commits are not reachable from the specified
           commit (HEAD if not specified).

       --points-at <object>
           Only list tags of the given object (HEAD if not specified). Implies
           --list.

       -m <msg>, --message=<msg>
           Use the given tag message (instead of prompting). If multiple -m
           options are given, their values are concatenated as separate
           paragraphs. Implies -a if none of -a, -s, or -u <keyid> is given.

       -F <file>, --file=<file>
           Take the tag message from the given file. Use - to read the message
           from the standard input. Implies -a if none of -a, -s, or -u
           <keyid> is given.

       -e, --edit
           The message taken from file with -F and command line with -m are
           usually used as the tag message unmodified. This option lets you
           further edit the message taken from these sources.

       --cleanup=<mode>
           This option sets how the tag message is cleaned up. The <mode> can
           be one of verbatim, whitespace and strip. The strip mode is
           default. The verbatim mode does not change message at all,
           whitespace removes just leading/trailing whitespace lines and strip
           removes both whitespace and commentary.

       --create-reflog
           Create a reflog for the tag. To globally enable reflogs for tags,
           see core.logAllRefUpdates in git-config(1). The negated form
           --no-create-reflog only overrides an earlier --create-reflog, but
           currently does not negate the setting of core.logAllRefUpdates.

       --format=<format>
           A string that interpolates %(fieldname) from a tag ref being shown
           and the object it points at. The format is the same as that of git-
           for-each-ref(1). When unspecified, defaults to %(refname:strip=2).

       <tagname>
           The name of the tag to create, delete, or describe. The new tag
           name must pass all checks defined by git-check-ref-format(1). Some
           of these checks may restrict the characters allowed in a tag name.

       <commit>, <object>
           The object that the new tag will refer to, usually a commit.
           Defaults to HEAD.

CONFIGURATION
       By default, git tag in sign-with-default mode (-s) will use your
       committer identity (of the form Your Name <your@email.address>) to find
       a key. If you want to use a different default key, you can specify it
       in the repository configuration as follows:

           [user]
               signingKey = <gpg-keyid>


       pager.tag is only respected when listing tags, i.e., when -l is used or
       implied. The default is to use a pager. See git-config(1).

DISCUSSION
   On Re-tagging
       What should you do when you tag a wrong commit and you would want to
       re-tag?

       If you never pushed anything out, just re-tag it. Use "-f" to replace
       the old one. And you're done.

       But if you have pushed things out (or others could just read your
       repository directly), then others will have already seen the old tag.
       In that case you can do one of two things:

        1. The sane thing. Just admit you screwed up, and use a different
           name. Others have already seen one tag-name, and if you keep the
           same name, you may be in the situation that two people both have
           "version X", but they actually have different "X"'s. So just call
           it "X.1" and be done with it.

        2. The insane thing. You really want to call the new version "X" too,
           even though others have already seen the old one. So just use git
           tag -f again, as if you hadn't already published the old one.

       However, Git does not (and it should not) change tags behind users
       back. So if somebody already got the old tag, doing a git pull on your
       tree shouldn't just make them overwrite the old one.

       If somebody got a release tag from you, you cannot just change the tag
       for them by updating your own one. This is a big security issue, in
       that people MUST be able to trust their tag-names. If you really want
       to do the insane thing, you need to just fess up to it, and tell people
       that you messed up. You can do that by making a very public
       announcement saying:

           Ok, I messed up, and I pushed out an earlier version tagged as X. I
           then fixed something, and retagged the *fixed* tree as X again.

           If you got the wrong tag, and want the new one, please delete
           the old one and fetch the new one by doing:

                   git tag -d X
                   git fetch origin tag X

           to get my updated tag.

           You can test which tag you have by doing

                   git rev-parse X

           which should return 0123456789abcdef.. if you have the new version.

           Sorry for the inconvenience.


       Does this seem a bit complicated? It should be. There is no way that it
       would be correct to just "fix" it automatically. People need to know
       that their tags might have been changed.

   On Automatic following
       If you are following somebody else's tree, you are most likely using
       remote-tracking branches (eg. refs/remotes/origin/main). You usually
       want the tags from the other end.

       On the other hand, if you are fetching because you would want a
       one-shot merge from somebody else, you typically do not want to get
       tags from there. This happens more often for people near the toplevel
       but not limited to them. Mere mortals when pulling from each other do
       not necessarily want to automatically get private anchor point tags
       from the other person.

       Often, "please pull" messages on the mailing list just provide two
       pieces of information: a repo URL and a branch name; this is designed
       to be easily cut&pasted at the end of a git fetch command line:

           Linus, please pull from

                   git://git..../proj.git main

           to get the following updates...


       becomes:

           $ git pull git://git..../proj.git main


       In such a case, you do not want to automatically follow the other
       person's tags.

       One important aspect of Git is its distributed nature, which largely
       means there is no inherent "upstream" or "downstream" in the system. On
       the face of it, the above example might seem to indicate that the tag
       namespace is owned by the upper echelon of people and that tags only
       flow downwards, but that is not the case. It only shows that the usage
       pattern determines who are interested in whose tags.

       A one-shot pull is a sign that a commit history is now crossing the
       boundary between one circle of people (e.g. "people who are primarily
       interested in the networking part of the kernel") who may have their
       own set of tags (e.g. "this is the third release candidate from the
       networking group to be proposed for general consumption with 2.6.21
       release") to another circle of people (e.g. "people who integrate
       various subsystem improvements"). The latter are usually not interested
       in the detailed tags used internally in the former group (that is what
       "internal" means). That is why it is desirable not to follow tags
       automatically in this case.

       It may well be that among networking people, they may want to exchange
       the tags internal to their group, but in that workflow they are most
       likely tracking each other's progress by having remote-tracking
       branches. Again, the heuristic to automatically follow such tags is a
       good thing.

   On Backdating Tags
       If you have imported some changes from another VCS and would like to
       add tags for major releases of your work, it is useful to be able to
       specify the date to embed inside of the tag object; such data in the
       tag object affects, for example, the ordering of tags in the gitweb
       interface.

       To set the date used in future tag objects, set the environment
       variable GIT_COMMITTER_DATE (see the later discussion of possible
       values; the most common form is "YYYY-MM-DD HH:MM").

       For example:

           $ GIT_COMMITTER_DATE="2006-10-02 10:31" git tag -s v1.0.1


DATE FORMATS
       The GIT_AUTHOR_DATE, GIT_COMMITTER_DATE environment variables support
       the following date formats:

       Git internal format
           It is <unix timestamp> <time zone offset>, where <unix timestamp>
           is the number of seconds since the UNIX epoch.  <time zone offset>
           is a positive or negative offset from UTC. For example CET (which
           is 1 hour ahead of UTC) is +0100.

       RFC 2822
           The standard email format as described by RFC 2822, for example
           Thu, 07 Apr 2005 22:13:13 +0200.

       ISO 8601
           Time and date specified by the ISO 8601 standard, for example
           2005-04-07T22:13:13. The parser accepts a space instead of the T
           character as well. Fractional parts of a second will be ignored,
           for example 2005-04-07T22:13:13.019 will be treated as
           2005-04-07T22:13:13.

               Note
               In addition, the date part is accepted in the following
               formats: YYYY.MM.DD, MM/DD/YYYY and DD.MM.YYYY.

NOTES
       When combining multiple --contains and --no-contains filters, only
       references that contain at least one of the --contains commits and
       contain none of the --no-contains commits are shown.

       When combining multiple --merged and --no-merged filters, only
       references that are reachable from at least one of the --merged commits
       and from none of the --no-merged commits are shown.

SEE ALSO
       git-check-ref-format(1). git-config(1).

GIT
       Part of the git(1) suite



Git 2.30.1.378.g1d4f23            02/08/2021                        GIT-TAG(1)
```



## `fetch`




```
GIT-FETCH(1)                      Git Manual                      GIT-FETCH(1)



NAME
       git-fetch - 別のリポジトリからオブジェクトと参照をダウンロードする

SYNOPSIS
       git fetch [<options>] [<repository> [<refspec>...]]
       git fetch [<options>] <group>
       git fetch --multiple [<options>] [(<repository> | <group>)...]
       git fetch --all [<options>]


DESCRIPTION
       履歴を完成させるために必要なオブジェクトと共に、1つ以上の他のリポジトリから
       ブランチやタグ（総称して「refs」）をフェッチします。
       リモート追跡ブランチが更新されます（この動作を制御する方法については、
       以下の <refspec> の説明を参照してください）。
       
       デフォルトでは、フェッチされている履歴を指すタグもフェッチされます。
       その効果は、関心のあるブランチを指すタグをフェッチすることです。
       このデフォルトの動作は、-tags または --no-tags オプションを使用するか、
       remote.<name>.tagOpt を構成することで変更できます。
       タグを明示的にフェッチするrefspecを使用することで、関心のあるブランチを指していないタグも
       フェッチできます。
       
       git fetch は、単一の名前付きリポジトリまたは URL から、または <group> が指定され、
       構成ファイルに remotes.<group> エントリがある場合は、一度に複数のリポジトリから
       フェッチできます。（git-config(1) を参照）。
       
       リモートが指定されていない場合、現在のブランチ用にアップストリームブランチが構成されていない限り、
       デフォルトで origin リモートが使用されます。
       
       フェッチされた参照の名前は、それらが指すオブジェクト名とともに、.git/FETCH_HEAD に書き込まれます。
       この情報は、スクリプトまたは git-pull(1) などの他の git コマンドで使用される場合があります。

OPTIONS
       --all
           Fetch all remotes.

       -a, --append
           Append ref names and object names of fetched refs to the existing
           contents of .git/FETCH_HEAD. Without this option old data in
           .git/FETCH_HEAD will be overwritten.

       --atomic
           Use an atomic transaction to update local refs. Either all refs are
           updated, or on error, no refs are updated.

       --depth=<depth>
           Limit fetching to the specified number of commits from the tip of
           each remote branch history. If fetching to a shallow repository
           created by git clone with --depth=<depth> option (see git-
           clone(1)), deepen or shorten the history to the specified number of
           commits. Tags for the deepened commits are not fetched.

       --deepen=<depth>
           Similar to --depth, except it specifies the number of commits from
           the current shallow boundary instead of from the tip of each remote
           branch history.

       --shallow-since=<date>
           Deepen or shorten the history of a shallow repository to include
           all reachable commits after <date>.

       --shallow-exclude=<revision>
           Deepen or shorten the history of a shallow repository to exclude
           commits reachable from a specified remote branch or tag. This
           option can be specified multiple times.

       --unshallow
           If the source repository is complete, convert a shallow repository
           to a complete one, removing all the limitations imposed by shallow
           repositories.

           If the source repository is shallow, fetch as much as possible so
           that the current repository has the same history as the source
           repository.

       --update-shallow
           By default when fetching from a shallow repository, git fetch
           refuses refs that require updating .git/shallow. This option
           updates .git/shallow and accept such refs.

       --negotiation-tip=<commit|glob>
           By default, Git will report, to the server, commits reachable from
           all local refs to find common commits in an attempt to reduce the
           size of the to-be-received packfile. If specified, Git will only
           report commits reachable from the given tips. This is useful to
           speed up fetches when the user knows which local ref is likely to
           have commits in common with the upstream ref being fetched.

           This option may be specified more than once; if so, Git will report
           commits reachable from any of the given commits.

           The argument to this option may be a glob on ref names, a ref, or
           the (possibly abbreviated) SHA-1 of a commit. Specifying a glob is
           equivalent to specifying this option multiple times, one for each
           matching ref name.

           See also the fetch.negotiationAlgorithm configuration variable
           documented in git-config(1).

       --dry-run
           Show what would be done, without making any changes.

       --[no-]write-fetch-head
           Write the list of remote refs fetched in the FETCH_HEAD file
           directly under $GIT_DIR. This is the default. Passing
           --no-write-fetch-head from the command line tells Git not to write
           the file. Under --dry-run option, the file is never written.

       -f, --force
           When git fetch is used with <src>:<dst> refspec it may refuse to
           update the local branch as discussed in the <refspec> part below.
           This option overrides that check.

       -k, --keep
           Keep downloaded pack.

       --multiple
           Allow several <repository> and <group> arguments to be specified.
           No <refspec>s may be specified.

       --[no-]auto-maintenance, --[no-]auto-gc
           Run git maintenance run --auto at the end to perform automatic
           repository maintenance if needed. (--[no-]auto-gc is a synonym.)
           This is enabled by default.

       --[no-]write-commit-graph
           Write a commit-graph after fetching. This overrides the config
           setting fetch.writeCommitGraph.

       -p, --prune
           Before fetching, remove any remote-tracking references that no
           longer exist on the remote. Tags are not subject to pruning if they
           are fetched only because of the default tag auto-following or due
           to a --tags option. However, if tags are fetched due to an explicit
           refspec (either on the command line or in the remote configuration,
           for example if the remote was cloned with the --mirror option),
           then they are also subject to pruning. Supplying --prune-tags is a
           shorthand for providing the tag refspec.

           See the PRUNING section below for more details.

       -P, --prune-tags
           Before fetching, remove any local tags that no longer exist on the
           remote if --prune is enabled. This option should be used more
           carefully, unlike --prune it will remove any local references
           (local tags) that have been created. This option is a shorthand for
           providing the explicit tag refspec along with --prune, see the
           discussion about that in its documentation.

           See the PRUNING section below for more details.

       -n, --no-tags
           By default, tags that point at objects that are downloaded from the
           remote repository are fetched and stored locally. This option
           disables this automatic tag following. The default behavior for a
           remote may be specified with the remote.<name>.tagOpt setting. See
           git-config(1).

       --refmap=<refspec>
           When fetching refs listed on the command line, use the specified
           refspec (can be given more than once) to map the refs to
           remote-tracking branches, instead of the values of remote.*.fetch
           configuration variables for the remote repository. Providing an
           empty <refspec> to the --refmap option causes Git to ignore the
           configured refspecs and rely entirely on the refspecs supplied as
           command-line arguments. See section on "Configured Remote-tracking
           Branches" for details.

       -t, --tags
           Fetch all tags from the remote (i.e., fetch remote tags refs/tags/*
           into local tags with the same name), in addition to whatever else
           would otherwise be fetched. Using this option alone does not
           subject tags to pruning, even if --prune is used (though tags may
           be pruned anyway if they are also the destination of an explicit
           refspec; see --prune).

       --recurse-submodules[=yes|on-demand|no]
           This option controls if and under what conditions new commits of
           populated submodules should be fetched too. It can be used as a
           boolean option to completely disable recursion when set to no or to
           unconditionally recurse into all populated submodules when set to
           yes, which is the default when this option is used without any
           value. Use on-demand to only recurse into a populated submodule
           when the superproject retrieves a commit that updates the
           submodule's reference to a commit that isn't already in the local
           submodule clone. By default, on-demand is used, unless
           fetch.recurseSubmodules is set (see git-config(1)).

       -j, --jobs=<n>
           Number of parallel children to be used for all forms of fetching.

           If the --multiple option was specified, the different remotes will
           be fetched in parallel. If multiple submodules are fetched, they
           will be fetched in parallel. To control them independently, use the
           config settings fetch.parallel and submodule.fetchJobs (see git-
           config(1)).

           Typically, parallel recursive and multi-remote fetches will be
           faster. By default fetches are performed sequentially, not in
           parallel.

       --no-recurse-submodules
           Disable recursive fetching of submodules (this has the same effect
           as using the --recurse-submodules=no option).

       --set-upstream
           If the remote is fetched successfully, add upstream (tracking)
           reference, used by argument-less git-pull(1) and other commands.
           For more information, see branch.<name>.merge and
           branch.<name>.remote in git-config(1).

       --submodule-prefix=<path>
           Prepend <path> to paths printed in informative messages such as
           "Fetching submodule foo". This option is used internally when
           recursing over submodules.

       --recurse-submodules-default=[yes|on-demand]
           This option is used internally to temporarily provide a
           non-negative default value for the --recurse-submodules option. All
           other methods of configuring fetch's submodule recursion (such as
           settings in gitmodules(5) and git-config(1)) override this option,
           as does specifying --[no-]recurse-submodules directly.

       -u, --update-head-ok
           By default git fetch refuses to update the head which corresponds
           to the current branch. This flag disables the check. This is purely
           for the internal use for git pull to communicate with git fetch,
           and unless you are implementing your own Porcelain you are not
           supposed to use it.

       --upload-pack <upload-pack>
           When given, and the repository to fetch from is handled by git
           fetch-pack, --exec=<upload-pack> is passed to the command to
           specify non-default path for the command run on the other end.

       -q, --quiet
           Pass --quiet to git-fetch-pack and silence any other internally
           used git commands. Progress is not reported to the standard error
           stream.

       -v, --verbose
           Be verbose.

       --progress
           Progress status is reported on the standard error stream by default
           when it is attached to a terminal, unless -q is specified. This
           flag forces progress status even if the standard error stream is
           not directed to a terminal.

       -o <option>, --server-option=<option>
           Transmit the given string to the server when communicating using
           protocol version 2. The given string must not contain a NUL or LF
           character. The server's handling of server options, including
           unknown ones, is server-specific. When multiple
           --server-option=<option> are given, they are all sent to the other
           side in the order listed on the command line.

       --show-forced-updates
           By default, git checks if a branch is force-updated during fetch.
           This can be disabled through fetch.showForcedUpdates, but the
           --show-forced-updates option guarantees this check occurs. See git-
           config(1).

       --no-show-forced-updates
           By default, git checks if a branch is force-updated during fetch.
           Pass --no-show-forced-updates or set fetch.showForcedUpdates to
           false to skip this check for performance reasons. If used during
           git-pull the --ff-only option will still check for forced updates
           before attempting a fast-forward update. See git-config(1).

       -4, --ipv4
           Use IPv4 addresses only, ignoring IPv6 addresses.

       -6, --ipv6
           Use IPv6 addresses only, ignoring IPv4 addresses.

       <repository>
           The "remote" repository that is the source of a fetch or pull
           operation. This parameter can be either a URL (see the section GIT
           URLS below) or the name of a remote (see the section REMOTES
           below).

       <group>
           A name referring to a list of repositories as the value of
           remotes.<group> in the configuration file. (See git-config(1)).

       <refspec>
           Specifies which refs to fetch and which local refs to update. When
           no <refspec>s appear on the command line, the refs to fetch are
           read from remote.<repository>.fetch variables instead (see
           CONFIGURED REMOTE-TRACKING BRANCHES below).

           The format of a <refspec> parameter is an optional plus +, followed
           by the source <src>, followed by a colon :, followed by the
           destination ref <dst>. The colon can be omitted when <dst> is
           empty. <src> is typically a ref, but it can also be a fully spelled
           hex object name.

           A <refspec> may contain a * in its <src> to indicate a simple
           pattern match. Such a refspec functions like a glob that matches
           any ref with the same prefix. A pattern <refspec> must have a * in
           both the <src> and <dst>. It will map refs to the destination by
           replacing the * with the contents matched from the source.

           If a refspec is prefixed by ^, it will be interpreted as a negative
           refspec. Rather than specifying which refs to fetch or which local
           refs to update, such a refspec will instead specify refs to
           exclude. A ref will be considered to match if it matches at least
           one positive refspec, and does not match any negative refspec.
           Negative refspecs can be useful to restrict the scope of a pattern
           refspec so that it will not include specific refs. Negative
           refspecs can themselves be pattern refspecs. However, they may only
           contain a <src> and do not specify a <dst>. Fully spelled out hex
           object names are also not supported.

           tag <tag> means the same as refs/tags/<tag>:refs/tags/<tag>; it
           requests fetching everything up to the given tag.

           The remote ref that matches <src> is fetched, and if <dst> is not
           an empty string, an attempt is made to update the local ref that
           matches it.

           Whether that update is allowed without --force depends on the ref
           namespace it's being fetched to, the type of object being fetched,
           and whether the update is considered to be a fast-forward.
           Generally, the same rules apply for fetching as when pushing, see
           the <refspec>...  section of git-push(1) for what those are.
           Exceptions to those rules particular to git fetch are noted below.

           Until Git version 2.20, and unlike when pushing with git-push(1),
           any updates to refs/tags/* would be accepted without + in the
           refspec (or --force). When fetching, we promiscuously considered
           all tag updates from a remote to be forced fetches. Since Git
           version 2.20, fetching to update refs/tags/* works the same way as
           when pushing. I.e. any updates will be rejected without + in the
           refspec (or --force).

           Unlike when pushing with git-push(1), any updates outside of
           refs/{tags,heads}/* will be accepted without + in the refspec (or
           --force), whether that's swapping e.g. a tree object for a blob, or
           a commit for another commit that's doesn't have the previous commit
           as an ancestor etc.

           Unlike when pushing with git-push(1), there is no configuration
           which'll amend these rules, and nothing like a pre-fetch hook
           analogous to the pre-receive hook.

           As with pushing with git-push(1), all of the rules described above
           about what's not allowed as an update can be overridden by adding
           an the optional leading + to a refspec (or using --force command
           line option). The only exception to this is that no amount of
           forcing will make the refs/heads/* namespace accept a non-commit
           object.

               Note
               When the remote branch you want to fetch is known to be rewound
               and rebased regularly, it is expected that its new tip will not
               be descendant of its previous tip (as stored in your
               remote-tracking branch the last time you fetched). You would
               want to use the + sign to indicate non-fast-forward updates
               will be needed for such branches. There is no way to determine
               or declare that a branch will be made available in a repository
               with this behavior; the pulling user simply must know this is
               the expected usage pattern for a branch.

       --stdin
           Read refspecs, one per line, from stdin in addition to those
           provided as arguments. The "tag <name>" format is not supported.

GIT URLS
       In general, URLs contain information about the transport protocol, the
       address of the remote server, and the path to the repository. Depending
       on the transport protocol, some of this information may be absent.

       Git supports ssh, git, http, and https protocols (in addition, ftp, and
       ftps can be used for fetching, but this is inefficient and deprecated;
       do not use it).

       The native transport (i.e. git:// URL) does no authentication and
       should be used with caution on unsecured networks.

       The following syntaxes may be used with them:

       o   ssh://[user@]host.xz[:port]/path/to/repo.git/

       o   git://host.xz[:port]/path/to/repo.git/

       o   http[s]://host.xz[:port]/path/to/repo.git/

       o   ftp[s]://host.xz[:port]/path/to/repo.git/

       An alternative scp-like syntax may also be used with the ssh protocol:

       o   [user@]host.xz:path/to/repo.git/

       This syntax is only recognized if there are no slashes before the first
       colon. This helps differentiate a local path that contains a colon. For
       example the local path foo:bar could be specified as an absolute path
       or ./foo:bar to avoid being misinterpreted as an ssh url.

       The ssh and git protocols additionally support ~username expansion:

       o   ssh://[user@]host.xz[:port]/~[user]/path/to/repo.git/

       o   git://host.xz[:port]/~[user]/path/to/repo.git/

       o   [user@]host.xz:/~[user]/path/to/repo.git/

       For local repositories, also supported by Git natively, the following
       syntaxes may be used:

       o   /path/to/repo.git/

       o   file:///path/to/repo.git/

       These two syntaxes are mostly equivalent, except when cloning, when the
       former implies --local option. See git-clone(1) for details.

       git clone, git fetch and git pull, but not git push, will also accept a
       suitable bundle file. See git-bundle(1).

       When Git doesn't know how to handle a certain transport protocol, it
       attempts to use the remote-<transport> remote helper, if one exists. To
       explicitly request a remote helper, the following syntax may be used:

       o   <transport>::<address>

       where <address> may be a path, a server and path, or an arbitrary
       URL-like string recognized by the specific remote helper being invoked.
       See gitremote-helpers(7) for details.

       If there are a large number of similarly-named remote repositories and
       you want to use a different format for them (such that the URLs you use
       will be rewritten into URLs that work), you can create a configuration
       section of the form:

                   [url "<actual url base>"]
                           insteadOf = <other url base>


       For example, with this:

                   [url "git://git.host.xz/"]
                           insteadOf = host.xz:/path/to/
                           insteadOf = work:


       a URL like "work:repo.git" or like "host.xz:/path/to/repo.git" will be
       rewritten in any context that takes a URL to be
       "git://git.host.xz/repo.git".

       If you want to rewrite URLs for push only, you can create a
       configuration section of the form:

                   [url "<actual url base>"]
                           pushInsteadOf = <other url base>


       For example, with this:

                   [url "ssh://example.org/"]
                           pushInsteadOf = git://example.org/


       a URL like "git://example.org/path/to/repo.git" will be rewritten to
       "ssh://example.org/path/to/repo.git" for pushes, but pulls will still
       use the original URL.

REMOTES
       The name of one of the following can be used instead of a URL as
       <repository> argument:

       o   a remote in the Git configuration file: $GIT_DIR/config,

       o   a file in the $GIT_DIR/remotes directory, or

       o   a file in the $GIT_DIR/branches directory.

       All of these also allow you to omit the refspec from the command line
       because they each contain a refspec which git will use by default.

   Named remote in configuration file
       You can choose to provide the name of a remote which you had previously
       configured using git-remote(1), git-config(1) or even by a manual edit
       to the $GIT_DIR/config file. The URL of this remote will be used to
       access the repository. The refspec of this remote will be used by
       default when you do not provide a refspec on the command line. The
       entry in the config file would appear like this:

                   [remote "<name>"]
                           url = <url>
                           pushurl = <pushurl>
                           push = <refspec>
                           fetch = <refspec>


       The <pushurl> is used for pushes only. It is optional and defaults to
       <url>.

   Named file in $GIT_DIR/remotes
       You can choose to provide the name of a file in $GIT_DIR/remotes. The
       URL in this file will be used to access the repository. The refspec in
       this file will be used as default when you do not provide a refspec on
       the command line. This file should have the following format:

                   URL: one of the above URL format
                   Push: <refspec>
                   Pull: <refspec>


       Push: lines are used by git push and Pull: lines are used by git pull
       and git fetch. Multiple Push: and Pull: lines may be specified for
       additional branch mappings.

   Named file in $GIT_DIR/branches
       You can choose to provide the name of a file in $GIT_DIR/branches. The
       URL in this file will be used to access the repository. This file
       should have the following format:

                   <url>#<head>


       <url> is required; #<head> is optional.

       Depending on the operation, git will use one of the following refspecs,
       if you don't provide one on the command line. <branch> is the name of
       this file in $GIT_DIR/branches and <head> defaults to main.

       git fetch uses:

                   refs/heads/<head>:refs/heads/<branch>


       git push uses:

                   HEAD:refs/heads/<head>


CONFIGURED REMOTE-TRACKING BRANCHES
       You often interact with the same remote repository by regularly and
       repeatedly fetching from it. In order to keep track of the progress of
       such a remote repository, git fetch allows you to configure
       remote.<repository>.fetch configuration variables.

       Typically such a variable may look like this:

           [remote "origin"]
                   fetch = +refs/heads/*:refs/remotes/origin/*


       This configuration is used in two ways:

       o   When git fetch is run without specifying what branches and/or tags
           to fetch on the command line, e.g.  git fetch origin or git fetch,
           remote.<repository>.fetch values are used as the refspecs--they
           specify which refs to fetch and which local refs to update. The
           example above will fetch all branches that exist in the origin
           (i.e. any ref that matches the left-hand side of the value,
           refs/heads/*) and update the corresponding remote-tracking branches
           in the refs/remotes/origin/* hierarchy.

       o   When git fetch is run with explicit branches and/or tags to fetch
           on the command line, e.g.  git fetch origin main, the <refspec>s
           given on the command line determine what are to be fetched (e.g.
           main in the example, which is a short-hand for main:, which in
           turn means "fetch the main branch but I do not explicitly say
           what remote-tracking branch to update with it from the command
           line"), and the example command will fetch only the main branch.
           The remote.<repository>.fetch values determine which
           remote-tracking branch, if any, is updated. When used in this way,
           the remote.<repository>.fetch values do not have any effect in
           deciding what gets fetched (i.e. the values are not used as
           refspecs when the command-line lists refspecs); they are only used
           to decide where the refs that are fetched are stored by acting as a
           mapping.

       The latter use of the remote.<repository>.fetch values can be
       overridden by giving the --refmap=<refspec> parameter(s) on the command
       line.

PRUNING
       Git has a default disposition of keeping data unless it's explicitly
       thrown away; this extends to holding onto local references to branches
       on remotes that have themselves deleted those branches.

       If left to accumulate, these stale references might make performance
       worse on big and busy repos that have a lot of branch churn, and e.g.
       make the output of commands like git branch -a --contains <commit>
       needlessly verbose, as well as impacting anything else that'll work
       with the complete set of known references.

       These remote-tracking references can be deleted as a one-off with
       either of:

           # While fetching
           $ git fetch --prune <name>

           # Only prune, don't fetch
           $ git remote prune <name>


       To prune references as part of your normal workflow without needing to
       remember to run that, set fetch.prune globally, or remote.<name>.prune
       per-remote in the config. See git-config(1).

       Here's where things get tricky and more specific. The pruning feature
       doesn't actually care about branches, instead it'll prune local <->
       remote-references as a function of the refspec of the remote (see
       <refspec> and CONFIGURED REMOTE-TRACKING BRANCHES above).

       Therefore if the refspec for the remote includes e.g.
       refs/tags/*:refs/tags/*, or you manually run e.g. git fetch --prune
       <name> "refs/tags/*:refs/tags/*" it won't be stale remote tracking
       branches that are deleted, but any local tag that doesn't exist on the
       remote.

       This might not be what you expect, i.e. you want to prune remote
       <name>, but also explicitly fetch tags from it, so when you fetch from
       it you delete all your local tags, most of which may not have come from
       the <name> remote in the first place.

       So be careful when using this with a refspec like
       refs/tags/*:refs/tags/*, or any other refspec which might map
       references from multiple remotes to the same local namespace.

       Since keeping up-to-date with both branches and tags on the remote is a
       common use-case the --prune-tags option can be supplied along with
       --prune to prune local tags that don't exist on the remote, and
       force-update those tags that differ. Tag pruning can also be enabled
       with fetch.pruneTags or remote.<name>.pruneTags in the config. See git-
       config(1).

       The --prune-tags option is equivalent to having refs/tags/*:refs/tags/*
       declared in the refspecs of the remote. This can lead to some seemingly
       strange interactions:

           # These both fetch tags
           $ git fetch --no-tags origin 'refs/tags/*:refs/tags/*'
           $ git fetch --no-tags --prune-tags origin


       The reason it doesn't error out when provided without --prune or its
       config versions is for flexibility of the configured versions, and to
       maintain a 1=1 mapping between what the command line flags do, and what
       the configuration versions do.

       It's reasonable to e.g. configure fetch.pruneTags=true in ~/.gitconfig
       to have tags pruned whenever git fetch --prune is run, without making
       every invocation of git fetch without --prune an error.

       Pruning tags with --prune-tags also works when fetching a URL instead
       of a named remote. These will all prune tags not found on origin:

           $ git fetch origin --prune --prune-tags
           $ git fetch origin --prune 'refs/tags/*:refs/tags/*'
           $ git fetch <url of origin> --prune --prune-tags
           $ git fetch <url of origin> --prune 'refs/tags/*:refs/tags/*'


OUTPUT
       The output of "git fetch" depends on the transport method used; this
       section describes the output when fetching over the Git protocol
       (either locally or via ssh) and Smart HTTP protocol.

       The status of the fetch is output in tabular form, with each line
       representing the status of a single ref. Each line is of the form:

            <flag> <summary> <from> -> <to> [<reason>]


       The status of up-to-date refs is shown only if the --verbose option is
       used.

       In compact output mode, specified with configuration variable
       fetch.output, if either entire <from> or <to> is found in the other
       string, it will be substituted with * in the other string. For example,
       main -> origin/main becomes main -> origin/*.

       flag
           A single character indicating the status of the ref:

           (space)
               for a successfully fetched fast-forward;

           +
               for a successful forced update;

           -
               for a successfully pruned ref;

           t
               for a successful tag update;

           *
               for a successfully fetched new ref;

           !
               for a ref that was rejected or failed to update; and

           =
               for a ref that was up to date and did not need fetching.

       summary
           For a successfully fetched ref, the summary shows the old and new
           values of the ref in a form suitable for using as an argument to
           git log (this is <old>..<new> in most cases, and <old>...<new> for
           forced non-fast-forward updates).

       from
           The name of the remote ref being fetched from, minus its
           refs/<type>/ prefix. In the case of deletion, the name of the
           remote ref is "(none)".

       to
           The name of the local ref being updated, minus its refs/<type>/
           prefix.

       reason
           A human-readable explanation. In the case of successfully fetched
           refs, no explanation is needed. For a failed ref, the reason for
           failure is described.

EXAMPLES
       o   Update the remote-tracking branches:

               $ git fetch origin

           The above command copies all branches from the remote refs/heads/
           namespace and stores them to the local refs/remotes/origin/
           namespace, unless the branch.<name>.fetch option is used to specify
           a non-default refspec.

       o   Using refspecs explicitly:

               $ git fetch origin +seen:seen maint:tmp

           This updates (or creates, as necessary) branches seen and tmp in
           the local repository by fetching from the branches (respectively)
           seen and maint from the remote repository.

           The seen branch will be updated even if it does not fast-forward,
           because it is prefixed with a plus sign; tmp will not be.

       o   Peek at a remote's branch, without configuring the remote in your
           local repository:

               $ git fetch git://git.kernel.org/pub/scm/git/git.git maint
               $ git log FETCH_HEAD

           The first command fetches the maint branch from the repository at
           git://git.kernel.org/pub/scm/git/git.git and the second command
           uses FETCH_HEAD to examine the branch with git-log(1). The fetched
           objects will eventually be removed by git's built-in housekeeping
           (see git-gc(1)).

SECURITY
       The fetch and push protocols are not designed to prevent one side from
       stealing data from the other repository that was not intended to be
       shared. If you have private data that you need to protect from a
       malicious peer, your best option is to store it in another repository.
       This applies to both clients and servers. In particular, namespaces on
       a server are not effective for read access control; you should only
       grant read access to a namespace to clients that you would trust with
       read access to the entire repository.

       The known attack vectors are as follows:

        1. The victim sends "have" lines advertising the IDs of objects it has
           that are not explicitly intended to be shared but can be used to
           optimize the transfer if the peer also has them. The attacker
           chooses an object ID X to steal and sends a ref to X, but isn't
           required to send the content of X because the victim already has
           it. Now the victim believes that the attacker has X, and it sends
           the content of X back to the attacker later. (This attack is most
           straightforward for a client to perform on a server, by creating a
           ref to X in the namespace the client has access to and then
           fetching it. The most likely way for a server to perform it on a
           client is to "merge" X into a public branch and hope that the user
           does additional work on this branch and pushes it back to the
           server without noticing the merge.)

        2. As in #1, the attacker chooses an object ID X to steal. The victim
           sends an object Y that the attacker already has, and the attacker
           falsely claims to have X and not Y, so the victim sends Y as a
           delta against X. The delta reveals regions of X that are similar to
           Y to the attacker.

BUGS
       Using --recurse-submodules can only fetch new commits in already
       checked out submodules right now. When e.g. upstream added a new
       submodule in the just fetched commits of the superproject the submodule
       itself cannot be fetched, making it impossible to check out that
       submodule later without having to do a fetch again. This is expected to
       be fixed in a future Git version.

SEE ALSO
       git-pull(1)

GIT
       Part of the git(1) suite



Git 2.30.1.378.g1d4f23            02/08/2021                      GIT-FETCH(1)
```



## `pull`




```
GIT-PULL(1)                       Git Manual                       GIT-PULL(1)



NAME
       git-pull - 別のリポジトリまたはローカルブランチから取得して統合する

SYNOPSIS
       git pull [<options>] [<repository> [<refspec>...]]


DESCRIPTION
       Incorporates changes from a remote repository into the current branch.
       In its default mode, git pull is shorthand for git fetch followed by
       git merge FETCH_HEAD.
       
       リモートリポジトリからの変更を現在のブランチに組み込みます。
        デフォルトモードでは、git pull は git fetch とそれに続く 
       git merge FETCH_HEAD の省略形です。
       
       より正確には、git pull は、指定されたパラメーターを使用して git fetch を実行し、
       git merge を呼び出して、取得したブランチヘッドを現在のブランチにマージします。
       --rebase を使用すると、git merge の代わりに git rebase を実行します。
       
       <repository> は、git-fetch(1) に渡されるリモートリポジトリの名前である必要があります。
       <refspec> は、任意のリモート ref（タグの名前など）または対応するリモート追跡ブランチを持つ
       ref のコレクション（refs/heads/*:refs/remotes/origin/* など）に
       名前を付けることができますが、通常、これはリモートリポジトリ内のブランチの名前です。
       
       <repository> と <branch> のデフォルト値は、git-branch (1) --track によって設定された
       現在のブランチの「remote」および「merge」構成から読み取られます。
       
       次の履歴が存在し、現在のブランチが「main」であると想定します：

                     A---B---C main on origin
                    /
               D---E---F---G main
                   ^
                   origin/main in your repository


       Then "git pull" will fetch and replay the changes from the remote
       main branch since it diverged from the local main (i.e., E) until
       its current commit (C) on top of main and record the result in a new
       commit along with the names of the two parent commits and a log message
       from the user describing the changes.
       
       次に、「git pull」は、ローカル main （つまり E）から分岐してから、
       main 上の現在のコミット（C）まで、リモート main ブランチから変更をフェッチして再生し、
       結果を、2つの親コミットの名前と、変更を説明するユーザーからのログメッセージとともに、
       新しいコミットに記録します。

                     A---B---C origin/main
                    /         \
               D---E---F---G---H main


      コンフリクトの表示方法や処理方法などの詳細については、git-merge(1) を参照してください。
       
       Git 1.7.0 以降では、コンフリクトするマージをキャンセルするには、git reset--merge を
       使用します。
       警告：古いバージョンの Git では、コミットされていない変更を加えて git pull を実行することは
       お勧めしません。可能ではありますが、競合が発生した場合に元に戻すのが難しい状態になります。
       
       リモートの変更のいずれかがローカルのコミットされていない変更と重複する場合、
       マージは自動的にキャンセルされ、作業ツリーは変更されません。
       一般に、git-stash(1) を使用してローカルの変更をプルまたは隠しておく前に、
       作業順序のローカルな変更を取得するのが最善です。

OPTIONS
       -q, --quiet
           This is passed to both underlying git-fetch to squelch reporting of
           during transfer, and underlying git-merge to squelch output during
           merging.

       -v, --verbose
           Pass --verbose to git-fetch and git-merge.

       --[no-]recurse-submodules[=yes|on-demand|no]
           This option controls if new commits of populated submodules should
           be fetched, and if the working trees of active submodules should be
           updated, too (see git-fetch(1), git-config(1) and gitmodules(5)).

           If the checkout is done via rebase, local submodule commits are
           rebased as well.

           If the update is done via merge, the submodule conflicts are
           resolved and checked out.

   Options related to merging
       --commit, --no-commit
           Perform the merge and commit the result. This option can be used to
           override --no-commit.

           With --no-commit perform the merge and stop just before creating a
           merge commit, to give the user a chance to inspect and further
           tweak the merge result before committing.

           Note that fast-forward updates do not create a merge commit and
           therefore there is no way to stop those merges with --no-commit.
           Thus, if you want to ensure your branch is not changed or updated
           by the merge command, use --no-ff with --no-commit.

       --edit, -e, --no-edit
           Invoke an editor before committing successful mechanical merge to
           further edit the auto-generated merge message, so that the user can
           explain and justify the merge. The --no-edit option can be used to
           accept the auto-generated message (this is generally discouraged).

           Older scripts may depend on the historical behaviour of not
           allowing the user to edit the merge log message. They will see an
           editor opened when they run git merge. To make it easier to adjust
           such scripts to the updated behaviour, the environment variable
           GIT_MERGE_AUTOEDIT can be set to no at the beginning of them.

       --cleanup=<mode>
           This option determines how the merge message will be cleaned up
           before committing. See git-commit(1) for more details. In addition,
           if the <mode> is given a value of scissors, scissors will be
           appended to MERGE_MSG before being passed on to the commit
           machinery in the case of a merge conflict.

       --ff, --no-ff, --ff-only
           Specifies how a merge is handled when the merged-in history is
           already a descendant of the current history.  --ff is the default
           unless merging an annotated (and possibly signed) tag that is not
           stored in its natural place in the refs/tags/ hierarchy, in which
           case --no-ff is assumed.

           With --ff, when possible resolve the merge as a fast-forward (only
           update the branch pointer to match the merged branch; do not create
           a merge commit). When not possible (when the merged-in history is
           not a descendant of the current history), create a merge commit.

           With --no-ff, create a merge commit in all cases, even when the
           merge could instead be resolved as a fast-forward.

           With --ff-only, resolve the merge as a fast-forward when possible.
           When not possible, refuse to merge and exit with a non-zero status.

       -S[<keyid>], --gpg-sign[=<keyid>], --no-gpg-sign
           GPG-sign the resulting merge commit. The keyid argument is optional
           and defaults to the committer identity; if specified, it must be
           stuck to the option without a space.  --no-gpg-sign is useful to
           countermand both commit.gpgSign configuration variable, and earlier
           --gpg-sign.

       --log[=<n>], --no-log
           In addition to branch names, populate the log message with one-line
           descriptions from at most <n> actual commits that are being merged.
           See also git-fmt-merge-msg(1).

           With --no-log do not list one-line descriptions from the actual
           commits being merged.

       --signoff, --no-signoff
           Add a Signed-off-by trailer by the committer at the end of the
           commit log message. The meaning of a signoff depends on the project
           to which you're committing. For example, it may certify that the
           committer has the rights to submit the work under the project's
           license or agrees to some contributor representation, such as a
           Developer Certificate of Origin. (See
           http://developercertificate.org for the one used by the Linux
           kernel and Git projects.) Consult the documentation or leadership
           of the project to which you're contributing to understand how the
           signoffs are used in that project.

           The --no-signoff option can be used to countermand an earlier
           --signoff option on the command line.

       --stat, -n, --no-stat
           Show a diffstat at the end of the merge. The diffstat is also
           controlled by the configuration option merge.stat.

           With -n or --no-stat do not show a diffstat at the end of the
           merge.

       --squash, --no-squash
           Produce the working tree and index state as if a real merge
           happened (except for the merge information), but do not actually
           make a commit, move the HEAD, or record $GIT_DIR/MERGE_HEAD (to
           cause the next git commit command to create a merge commit). This
           allows you to create a single commit on top of the current branch
           whose effect is the same as merging another branch (or more in case
           of an octopus).

           With --no-squash perform the merge and commit the result. This
           option can be used to override --squash.

           With --squash, --commit is not allowed, and will fail.

       --no-verify
           This option bypasses the pre-merge and commit-msg hooks. See also
           githooks(5).

       -s <strategy>, --strategy=<strategy>
           Use the given merge strategy; can be supplied more than once to
           specify them in the order they should be tried. If there is no -s
           option, a built-in list of strategies is used instead (git
           merge-recursive when merging a single head, git merge-octopus
           otherwise).

       -X <option>, --strategy-option=<option>
           Pass merge strategy specific option through to the merge strategy.

       --verify-signatures, --no-verify-signatures
           Verify that the tip commit of the side branch being merged is
           signed with a valid key, i.e. a key that has a valid uid: in the
           default trust model, this means the signing key has been signed by
           a trusted key. If the tip commit of the side branch is not signed
           with a valid key, the merge is aborted.

       --summary, --no-summary
           Synonyms to --stat and --no-stat; these are deprecated and will be
           removed in the future.

       --autostash, --no-autostash
           Automatically create a temporary stash entry before the operation
           begins, and apply it after the operation ends. This means that you
           can run the operation on a dirty worktree. However, use with care:
           the final stash application after a successful merge might result
           in non-trivial conflicts.

       --allow-unrelated-histories
           By default, git merge command refuses to merge histories that do
           not share a common ancestor. This option can be used to override
           this safety when merging histories of two projects that started
           their lives independently. As that is a very rare occasion, no
           configuration variable to enable this by default exists and will
           not be added.

       -r, --rebase[=false|true|merges|preserve|interactive]
           When true, rebase the current branch on top of the upstream branch
           after fetching. If there is a remote-tracking branch corresponding
           to the upstream branch and the upstream branch was rebased since
           last fetched, the rebase uses that information to avoid rebasing
           non-local changes.

           When set to merges, rebase using git rebase --rebase-merges so that
           the local merge commits are included in the rebase (see git-
           rebase(1) for details).

           When set to preserve (deprecated in favor of merges), rebase with
           the --preserve-merges option passed to git rebase so that locally
           created merge commits will not be flattened.

           When false, merge the current branch into the upstream branch.

           When interactive, enable the interactive mode of rebase.

           See pull.rebase, branch.<name>.rebase and branch.autoSetupRebase in
           git-config(1) if you want to make git pull always use --rebase
           instead of merging.

               Note
               This is a potentially dangerous mode of operation. It rewrites
               history, which does not bode well when you published that
               history already. Do not use this option unless you have read
               git-rebase(1) carefully.

       --no-rebase
           Override earlier --rebase.

   Options related to fetching
       --all
           Fetch all remotes.

       -a, --append
           Append ref names and object names of fetched refs to the existing
           contents of .git/FETCH_HEAD. Without this option old data in
           .git/FETCH_HEAD will be overwritten.

       --atomic
           Use an atomic transaction to update local refs. Either all refs are
           updated, or on error, no refs are updated.

       --depth=<depth>
           Limit fetching to the specified number of commits from the tip of
           each remote branch history. If fetching to a shallow repository
           created by git clone with --depth=<depth> option (see git-
           clone(1)), deepen or shorten the history to the specified number of
           commits. Tags for the deepened commits are not fetched.

       --deepen=<depth>
           Similar to --depth, except it specifies the number of commits from
           the current shallow boundary instead of from the tip of each remote
           branch history.

       --shallow-since=<date>
           Deepen or shorten the history of a shallow repository to include
           all reachable commits after <date>.

       --shallow-exclude=<revision>
           Deepen or shorten the history of a shallow repository to exclude
           commits reachable from a specified remote branch or tag. This
           option can be specified multiple times.

       --unshallow
           If the source repository is complete, convert a shallow repository
           to a complete one, removing all the limitations imposed by shallow
           repositories.

           If the source repository is shallow, fetch as much as possible so
           that the current repository has the same history as the source
           repository.

       --update-shallow
           By default when fetching from a shallow repository, git fetch
           refuses refs that require updating .git/shallow. This option
           updates .git/shallow and accept such refs.

       --negotiation-tip=<commit|glob>
           By default, Git will report, to the server, commits reachable from
           all local refs to find common commits in an attempt to reduce the
           size of the to-be-received packfile. If specified, Git will only
           report commits reachable from the given tips. This is useful to
           speed up fetches when the user knows which local ref is likely to
           have commits in common with the upstream ref being fetched.

           This option may be specified more than once; if so, Git will report
           commits reachable from any of the given commits.

           The argument to this option may be a glob on ref names, a ref, or
           the (possibly abbreviated) SHA-1 of a commit. Specifying a glob is
           equivalent to specifying this option multiple times, one for each
           matching ref name.

           See also the fetch.negotiationAlgorithm configuration variable
           documented in git-config(1).

       --dry-run
           Show what would be done, without making any changes.

       -f, --force
           When git fetch is used with <src>:<dst> refspec it may refuse to
           update the local branch as discussed in the <refspec> part of the
           git-fetch(1) documentation. This option overrides that check.

       -k, --keep
           Keep downloaded pack.

       -p, --prune
           Before fetching, remove any remote-tracking references that no
           longer exist on the remote. Tags are not subject to pruning if they
           are fetched only because of the default tag auto-following or due
           to a --tags option. However, if tags are fetched due to an explicit
           refspec (either on the command line or in the remote configuration,
           for example if the remote was cloned with the --mirror option),
           then they are also subject to pruning. Supplying --prune-tags is a
           shorthand for providing the tag refspec.

       --no-tags
           By default, tags that point at objects that are downloaded from the
           remote repository are fetched and stored locally. This option
           disables this automatic tag following. The default behavior for a
           remote may be specified with the remote.<name>.tagOpt setting. See
           git-config(1).

       --refmap=<refspec>
           When fetching refs listed on the command line, use the specified
           refspec (can be given more than once) to map the refs to
           remote-tracking branches, instead of the values of remote.*.fetch
           configuration variables for the remote repository. Providing an
           empty <refspec> to the --refmap option causes Git to ignore the
           configured refspecs and rely entirely on the refspecs supplied as
           command-line arguments. See section on "Configured Remote-tracking
           Branches" for details.

       -t, --tags
           Fetch all tags from the remote (i.e., fetch remote tags refs/tags/*
           into local tags with the same name), in addition to whatever else
           would otherwise be fetched. Using this option alone does not
           subject tags to pruning, even if --prune is used (though tags may
           be pruned anyway if they are also the destination of an explicit
           refspec; see --prune).

       -j, --jobs=<n>
           Number of parallel children to be used for all forms of fetching.

           If the --multiple option was specified, the different remotes will
           be fetched in parallel. If multiple submodules are fetched, they
           will be fetched in parallel. To control them independently, use the
           config settings fetch.parallel and submodule.fetchJobs (see git-
           config(1)).

           Typically, parallel recursive and multi-remote fetches will be
           faster. By default fetches are performed sequentially, not in
           parallel.

       --set-upstream
           If the remote is fetched successfully, add upstream (tracking)
           reference, used by argument-less git-pull(1) and other commands.
           For more information, see branch.<name>.merge and
           branch.<name>.remote in git-config(1).

       --upload-pack <upload-pack>
           When given, and the repository to fetch from is handled by git
           fetch-pack, --exec=<upload-pack> is passed to the command to
           specify non-default path for the command run on the other end.

       --progress
           Progress status is reported on the standard error stream by default
           when it is attached to a terminal, unless -q is specified. This
           flag forces progress status even if the standard error stream is
           not directed to a terminal.

       -o <option>, --server-option=<option>
           Transmit the given string to the server when communicating using
           protocol version 2. The given string must not contain a NUL or LF
           character. The server's handling of server options, including
           unknown ones, is server-specific. When multiple
           --server-option=<option> are given, they are all sent to the other
           side in the order listed on the command line.

       --show-forced-updates
           By default, git checks if a branch is force-updated during fetch.
           This can be disabled through fetch.showForcedUpdates, but the
           --show-forced-updates option guarantees this check occurs. See git-
           config(1).

       --no-show-forced-updates
           By default, git checks if a branch is force-updated during fetch.
           Pass --no-show-forced-updates or set fetch.showForcedUpdates to
           false to skip this check for performance reasons. If used during
           git-pull the --ff-only option will still check for forced updates
           before attempting a fast-forward update. See git-config(1).

       -4, --ipv4
           Use IPv4 addresses only, ignoring IPv6 addresses.

       -6, --ipv6
           Use IPv6 addresses only, ignoring IPv4 addresses.

       <repository>
           The "remote" repository that is the source of a fetch or pull
           operation. This parameter can be either a URL (see the section GIT
           URLS below) or the name of a remote (see the section REMOTES
           below).

       <refspec>
           Specifies which refs to fetch and which local refs to update. When
           no <refspec>s appear on the command line, the refs to fetch are
           read from remote.<repository>.fetch variables instead (see the
           section "CONFIGURED REMOTE-TRACKING BRANCHES" in git-fetch(1)).

           The format of a <refspec> parameter is an optional plus +, followed
           by the source <src>, followed by a colon :, followed by the
           destination ref <dst>. The colon can be omitted when <dst> is
           empty. <src> is typically a ref, but it can also be a fully spelled
           hex object name.

           A <refspec> may contain a * in its <src> to indicate a simple
           pattern match. Such a refspec functions like a glob that matches
           any ref with the same prefix. A pattern <refspec> must have a * in
           both the <src> and <dst>. It will map refs to the destination by
           replacing the * with the contents matched from the source.

           If a refspec is prefixed by ^, it will be interpreted as a negative
           refspec. Rather than specifying which refs to fetch or which local
           refs to update, such a refspec will instead specify refs to
           exclude. A ref will be considered to match if it matches at least
           one positive refspec, and does not match any negative refspec.
           Negative refspecs can be useful to restrict the scope of a pattern
           refspec so that it will not include specific refs. Negative
           refspecs can themselves be pattern refspecs. However, they may only
           contain a <src> and do not specify a <dst>. Fully spelled out hex
           object names are also not supported.

           tag <tag> means the same as refs/tags/<tag>:refs/tags/<tag>; it
           requests fetching everything up to the given tag.

           The remote ref that matches <src> is fetched, and if <dst> is not
           an empty string, an attempt is made to update the local ref that
           matches it.

           Whether that update is allowed without --force depends on the ref
           namespace it's being fetched to, the type of object being fetched,
           and whether the update is considered to be a fast-forward.
           Generally, the same rules apply for fetching as when pushing, see
           the <refspec>...  section of git-push(1) for what those are.
           Exceptions to those rules particular to git fetch are noted below.

           Until Git version 2.20, and unlike when pushing with git-push(1),
           any updates to refs/tags/* would be accepted without + in the
           refspec (or --force). When fetching, we promiscuously considered
           all tag updates from a remote to be forced fetches. Since Git
           version 2.20, fetching to update refs/tags/* works the same way as
           when pushing. I.e. any updates will be rejected without + in the
           refspec (or --force).

           Unlike when pushing with git-push(1), any updates outside of
           refs/{tags,heads}/* will be accepted without + in the refspec (or
           --force), whether that's swapping e.g. a tree object for a blob, or
           a commit for another commit that's doesn't have the previous commit
           as an ancestor etc.

           Unlike when pushing with git-push(1), there is no configuration
           which'll amend these rules, and nothing like a pre-fetch hook
           analogous to the pre-receive hook.

           As with pushing with git-push(1), all of the rules described above
           about what's not allowed as an update can be overridden by adding
           an the optional leading + to a refspec (or using --force command
           line option). The only exception to this is that no amount of
           forcing will make the refs/heads/* namespace accept a non-commit
           object.

               Note
               When the remote branch you want to fetch is known to be rewound
               and rebased regularly, it is expected that its new tip will not
               be descendant of its previous tip (as stored in your
               remote-tracking branch the last time you fetched). You would
               want to use the + sign to indicate non-fast-forward updates
               will be needed for such branches. There is no way to determine
               or declare that a branch will be made available in a repository
               with this behavior; the pulling user simply must know this is
               the expected usage pattern for a branch.

               Note
               There is a difference between listing multiple <refspec>
               directly on git pull command line and having multiple
               remote.<repository>.fetch entries in your configuration for a
               <repository> and running a git pull command without any
               explicit <refspec> parameters. <refspec>s listed explicitly on
               the command line are always merged into the current branch
               after fetching. In other words, if you list more than one
               remote ref, git pull will create an Octopus merge. On the other
               hand, if you do not list any explicit <refspec> parameter on
               the command line, git pull will fetch all the <refspec>s it
               finds in the remote.<repository>.fetch configuration and merge
               only the first <refspec> found into the current branch. This is
               because making an Octopus from remote refs is rarely done,
               while keeping track of multiple remote heads in one-go by
               fetching more than one is often useful.

GIT URLS
       In general, URLs contain information about the transport protocol, the
       address of the remote server, and the path to the repository. Depending
       on the transport protocol, some of this information may be absent.

       Git supports ssh, git, http, and https protocols (in addition, ftp, and
       ftps can be used for fetching, but this is inefficient and deprecated;
       do not use it).

       The native transport (i.e. git:// URL) does no authentication and
       should be used with caution on unsecured networks.

       The following syntaxes may be used with them:

       o   ssh://[user@]host.xz[:port]/path/to/repo.git/

       o   git://host.xz[:port]/path/to/repo.git/

       o   http[s]://host.xz[:port]/path/to/repo.git/

       o   ftp[s]://host.xz[:port]/path/to/repo.git/

       An alternative scp-like syntax may also be used with the ssh protocol:

       o   [user@]host.xz:path/to/repo.git/

       This syntax is only recognized if there are no slashes before the first
       colon. This helps differentiate a local path that contains a colon. For
       example the local path foo:bar could be specified as an absolute path
       or ./foo:bar to avoid being misinterpreted as an ssh url.

       The ssh and git protocols additionally support ~username expansion:

       o   ssh://[user@]host.xz[:port]/~[user]/path/to/repo.git/

       o   git://host.xz[:port]/~[user]/path/to/repo.git/

       o   [user@]host.xz:/~[user]/path/to/repo.git/

       For local repositories, also supported by Git natively, the following
       syntaxes may be used:

       o   /path/to/repo.git/

       o   file:///path/to/repo.git/

       These two syntaxes are mostly equivalent, except when cloning, when the
       former implies --local option. See git-clone(1) for details.

       git clone, git fetch and git pull, but not git push, will also accept a
       suitable bundle file. See git-bundle(1).

       When Git doesn't know how to handle a certain transport protocol, it
       attempts to use the remote-<transport> remote helper, if one exists. To
       explicitly request a remote helper, the following syntax may be used:

       o   <transport>::<address>

       where <address> may be a path, a server and path, or an arbitrary
       URL-like string recognized by the specific remote helper being invoked.
       See gitremote-helpers(7) for details.

       If there are a large number of similarly-named remote repositories and
       you want to use a different format for them (such that the URLs you use
       will be rewritten into URLs that work), you can create a configuration
       section of the form:

                   [url "<actual url base>"]
                           insteadOf = <other url base>


       For example, with this:

                   [url "git://git.host.xz/"]
                           insteadOf = host.xz:/path/to/
                           insteadOf = work:


       a URL like "work:repo.git" or like "host.xz:/path/to/repo.git" will be
       rewritten in any context that takes a URL to be
       "git://git.host.xz/repo.git".

       If you want to rewrite URLs for push only, you can create a
       configuration section of the form:

                   [url "<actual url base>"]
                           pushInsteadOf = <other url base>


       For example, with this:

                   [url "ssh://example.org/"]
                           pushInsteadOf = git://example.org/


       a URL like "git://example.org/path/to/repo.git" will be rewritten to
       "ssh://example.org/path/to/repo.git" for pushes, but pulls will still
       use the original URL.

REMOTES
       The name of one of the following can be used instead of a URL as
       <repository> argument:

       o   a remote in the Git configuration file: $GIT_DIR/config,

       o   a file in the $GIT_DIR/remotes directory, or

       o   a file in the $GIT_DIR/branches directory.

       All of these also allow you to omit the refspec from the command line
       because they each contain a refspec which git will use by default.

   Named remote in configuration file
       You can choose to provide the name of a remote which you had previously
       configured using git-remote(1), git-config(1) or even by a manual edit
       to the $GIT_DIR/config file. The URL of this remote will be used to
       access the repository. The refspec of this remote will be used by
       default when you do not provide a refspec on the command line. The
       entry in the config file would appear like this:

                   [remote "<name>"]
                           url = <url>
                           pushurl = <pushurl>
                           push = <refspec>
                           fetch = <refspec>


       The <pushurl> is used for pushes only. It is optional and defaults to
       <url>.

   Named file in $GIT_DIR/remotes
       You can choose to provide the name of a file in $GIT_DIR/remotes. The
       URL in this file will be used to access the repository. The refspec in
       this file will be used as default when you do not provide a refspec on
       the command line. This file should have the following format:

                   URL: one of the above URL format
                   Push: <refspec>
                   Pull: <refspec>


       Push: lines are used by git push and Pull: lines are used by git pull
       and git fetch. Multiple Push: and Pull: lines may be specified for
       additional branch mappings.

   Named file in $GIT_DIR/branches
       You can choose to provide the name of a file in $GIT_DIR/branches. The
       URL in this file will be used to access the repository. This file
       should have the following format:

                   <url>#<head>


       <url> is required; #<head> is optional.

       Depending on the operation, git will use one of the following refspecs,
       if you don't provide one on the command line. <branch> is the name of
       this file in $GIT_DIR/branches and <head> defaults to main.

       git fetch uses:

                   refs/heads/<head>:refs/heads/<branch>


       git push uses:

                   HEAD:refs/heads/<head>


MERGE STRATEGIES
       The merge mechanism (git merge and git pull commands) allows the
       backend merge strategies to be chosen with -s option. Some strategies
       can also take their own options, which can be passed by giving
       -X<option> arguments to git merge and/or git pull.

       resolve
           This can only resolve two heads (i.e. the current branch and
           another branch you pulled from) using a 3-way merge algorithm. It
           tries to carefully detect criss-cross merge ambiguities and is
           considered generally safe and fast.

       recursive
           This can only resolve two heads using a 3-way merge algorithm. When
           there is more than one common ancestor that can be used for 3-way
           merge, it creates a merged tree of the common ancestors and uses
           that as the reference tree for the 3-way merge. This has been
           reported to result in fewer merge conflicts without causing
           mismerges by tests done on actual merge commits taken from Linux
           2.6 kernel development history. Additionally this can detect and
           handle merges involving renames, but currently cannot make use of
           detected copies. This is the default merge strategy when pulling or
           merging one branch.

           The recursive strategy can take the following options:

           ours
               This option forces conflicting hunks to be auto-resolved
               cleanly by favoring our version. Changes from the other tree
               that do not conflict with our side are reflected in the merge
               result. For a binary file, the entire contents are taken from
               our side.

               This should not be confused with the ours merge strategy, which
               does not even look at what the other tree contains at all. It
               discards everything the other tree did, declaring our history
               contains all that happened in it.

           theirs
               This is the opposite of ours; note that, unlike ours, there is
               no theirs merge strategy to confuse this merge option with.

           patience
               With this option, merge-recursive spends a little extra time to
               avoid mismerges that sometimes occur due to unimportant
               matching lines (e.g., braces from distinct functions). Use this
               when the branches to be merged have diverged wildly. See also
               git-diff(1) --patience.

           diff-algorithm=[patience|minimal|histogram|myers]
               Tells merge-recursive to use a different diff algorithm, which
               can help avoid mismerges that occur due to unimportant matching
               lines (such as braces from distinct functions). See also git-
               diff(1) --diff-algorithm.

           ignore-space-change, ignore-all-space, ignore-space-at-eol,
           ignore-cr-at-eol
               Treats lines with the indicated type of whitespace change as
               unchanged for the sake of a three-way merge. Whitespace changes
               mixed with other changes to a line are not ignored. See also
               git-diff(1) -b, -w, --ignore-space-at-eol, and
               --ignore-cr-at-eol.

               o   If their version only introduces whitespace changes to a
                   line, our version is used;

               o   If our version introduces whitespace changes but their
                   version includes a substantial change, their version is
                   used;

               o   Otherwise, the merge proceeds in the usual way.

           renormalize
               This runs a virtual check-out and check-in of all three stages
               of a file when resolving a three-way merge. This option is
               meant to be used when merging branches with different clean
               filters or end-of-line normalization rules. See "Merging
               branches with differing checkin/checkout attributes" in
               gitattributes(5) for details.

           no-renormalize
               Disables the renormalize option. This overrides the
               merge.renormalize configuration variable.

           no-renames
               Turn off rename detection. This overrides the merge.renames
               configuration variable. See also git-diff(1) --no-renames.

           find-renames[=<n>]
               Turn on rename detection, optionally setting the similarity
               threshold. This is the default. This overrides the
               merge.renames configuration variable. See also git-diff(1)
               --find-renames.

           rename-threshold=<n>
               Deprecated synonym for find-renames=<n>.

           subtree[=<path>]
               This option is a more advanced form of subtree strategy, where
               the strategy makes a guess on how two trees must be shifted to
               match with each other when merging. Instead, the specified path
               is prefixed (or stripped from the beginning) to make the shape
               of two trees to match.

       octopus
           This resolves cases with more than two heads, but refuses to do a
           complex merge that needs manual resolution. It is primarily meant
           to be used for bundling topic branch heads together. This is the
           default merge strategy when pulling or merging more than one
           branch.

       ours
           This resolves any number of heads, but the resulting tree of the
           merge is always that of the current branch head, effectively
           ignoring all changes from all other branches. It is meant to be
           used to supersede old development history of side branches. Note
           that this is different from the -Xours option to the recursive
           merge strategy.

       subtree
           This is a modified recursive strategy. When merging trees A and B,
           if B corresponds to a subtree of A, B is first adjusted to match
           the tree structure of A, instead of reading the trees at the same
           level. This adjustment is also done to the common ancestor tree.

       With the strategies that use 3-way merge (including the default,
       recursive), if a change is made on both branches, but later reverted on
       one of the branches, that change will be present in the merged result;
       some people find this behavior confusing. It occurs because only the
       heads and the merge base are considered when performing a merge, not
       the individual commits. The merge algorithm therefore considers the
       reverted change as no change at all, and substitutes the changed
       version instead.

DEFAULT BEHAVIOUR
       Often people use git pull without giving any parameter. Traditionally,
       this has been equivalent to saying git pull origin. However, when
       configuration branch.<name>.remote is present while on branch <name>,
       that value is used instead of origin.

       In order to determine what URL to use to fetch from, the value of the
       configuration remote.<origin>.url is consulted and if there is not any
       such variable, the value on the URL: line in $GIT_DIR/remotes/<origin>
       is used.

       In order to determine what remote branches to fetch (and optionally
       store in the remote-tracking branches) when the command is run without
       any refspec parameters on the command line, values of the configuration
       variable remote.<origin>.fetch are consulted, and if there aren't any,
       $GIT_DIR/remotes/<origin> is consulted and its Pull: lines are used. In
       addition to the refspec formats described in the OPTIONS section, you
       can have a globbing refspec that looks like this:

           refs/heads/*:refs/remotes/origin/*


       A globbing refspec must have a non-empty RHS (i.e. must store what were
       fetched in remote-tracking branches), and its LHS and RHS must end with
       /*. The above specifies that all remote branches are tracked using
       remote-tracking branches in refs/remotes/origin/ hierarchy under the
       same name.

       The rule to determine which remote branch to merge after fetching is a
       bit involved, in order not to break backward compatibility.

       If explicit refspecs were given on the command line of git pull, they
       are all merged.

       When no refspec was given on the command line, then git pull uses the
       refspec from the configuration or $GIT_DIR/remotes/<origin>. In such
       cases, the following rules apply:

        1. If branch.<name>.merge configuration for the current branch <name>
           exists, that is the name of the branch at the remote site that is
           merged.

        2. If the refspec is a globbing one, nothing is merged.

        3. Otherwise the remote branch of the first refspec is merged.

EXAMPLES
       o   Update the remote-tracking branches for the repository you cloned
           from, then merge one of them into your current branch:

               $ git pull
               $ git pull origin

           Normally the branch merged in is the HEAD of the remote repository,
           but the choice is determined by the branch.<name>.remote and
           branch.<name>.merge options; see git-config(1) for details.

       o   Merge into the current branch the remote branch next:

               $ git pull origin next

           This leaves a copy of next temporarily in FETCH_HEAD, and updates
           the remote-tracking branch origin/next. The same can be done by
           invoking fetch and merge:

               $ git fetch origin
               $ git merge origin/next


       If you tried a pull which resulted in complex conflicts and would want
       to start over, you can recover with git reset.

SECURITY
       The fetch and push protocols are not designed to prevent one side from
       stealing data from the other repository that was not intended to be
       shared. If you have private data that you need to protect from a
       malicious peer, your best option is to store it in another repository.
       This applies to both clients and servers. In particular, namespaces on
       a server are not effective for read access control; you should only
       grant read access to a namespace to clients that you would trust with
       read access to the entire repository.

       The known attack vectors are as follows:

        1. The victim sends "have" lines advertising the IDs of objects it has
           that are not explicitly intended to be shared but can be used to
           optimize the transfer if the peer also has them. The attacker
           chooses an object ID X to steal and sends a ref to X, but isn't
           required to send the content of X because the victim already has
           it. Now the victim believes that the attacker has X, and it sends
           the content of X back to the attacker later. (This attack is most
           straightforward for a client to perform on a server, by creating a
           ref to X in the namespace the client has access to and then
           fetching it. The most likely way for a server to perform it on a
           client is to "merge" X into a public branch and hope that the user
           does additional work on this branch and pushes it back to the
           server without noticing the merge.)

        2. As in #1, the attacker chooses an object ID X to steal. The victim
           sends an object Y that the attacker already has, and the attacker
           falsely claims to have X and not Y, so the victim sends Y as a
           delta against X. The delta reveals regions of X that are similar to
           Y to the attacker.

BUGS
       Using --recurse-submodules can only fetch new commits in already
       checked out submodules right now. When e.g. upstream added a new
       submodule in the just fetched commits of the superproject the submodule
       itself cannot be fetched, making it impossible to check out that
       submodule later without having to do a fetch again. This is expected to
       be fixed in a future Git version.

SEE ALSO
       git-fetch(1), git-merge(1), git-config(1)

GIT
       Part of the git(1) suite



Git 2.30.1.378.g1d4f23            02/08/2021                       GIT-PULL(1)
```

